Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/nettle-frp-0.1.1/src/Nettle/FRPControl/AFRPTask.hs
Monad instance: 



------------------------------------------------------------------------------
-- Monad instance
------------------------------------------------------------------------------

instance Monad (Task a b) where
    tk >>= f = Task (\k -> (unTask tk) (\c -> unTask (f c) k))
    return x = Task (\k -> k x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/GLFW-0.5.2.5/Setup.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (StateT s m) where
  pure a  = StateT $ \s -> return (a, s)
  f <*> x = StateT $ \s -> do
        ~(f', s')  <- runStateT f s
        ~(x', s'') <- runStateT x s'
        return (f' x', s'')
Monad instance: 


instance (Functor m, Monad m) => Monad (StateT s m) where
    return = pure
    m >>= k  = StateT $ \s -> do
        ~(a, s') <- runStateT m s
        runStateT (k a) s'
    fail str = StateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/york-lava-0.2/modules/Lava/JList.hs
Monad instance: 


instance Monad JList where
  return a = One a
  Zero >>= f = Zero
  One a >>= f = f a
  (as :+: bs) >>= f = (as >>= f) :+: (bs >>= f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/york-lava-0.2/modules/Recipe.hs
Monad instance: 


instance Monad (RWS r w s) where
  return a = RWS (\r s -> (s, [], a))
  m >>= f = RWS (\r s -> let (s0, w0, a) = runRWS m r s
                             (s1, w1, b) = runRWS (f a) r s0
                         in  (s1, w0 ++ w1, b))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tardis-0.4.1.0/Control/Monad/Trans/Tardis.hs
Monad instance: 



-- Instances
-------------------------------------------------

instance MonadFix m => Monad (TardisT bw fw m) where
  return x = tardis $ \s -> (x, s)
  m >>= f  = TardisT $ \ ~(bw, fw) -> do
    rec (x,  ~(bw'', fw' )) <- runTardisT m (bw', fw)
        (x', ~(bw' , fw'')) <- runTardisT (f x) (bw, fw')
    return (x', (bw'', fw''))
Applicative instance: 


instance MonadFix m => Applicative (TardisT bw fw m) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SGplus-1.1/Data/SG/Vector/Basic.hs
Applicative instance: 


instance Applicative Pair where
  pure a = Pair (a, a)
  (<*>) (Pair (fa, fb)) (Pair (a, b)) = Pair (fa a, fb b)
Applicative instance: 


instance Applicative Triple where
  pure a = Triple (a, a, a)
  (<*>) (Triple (fa, fb, fc)) (Triple (a, b, c)) = Triple (fa a, fb b, fc c)
Applicative instance: 


instance Applicative Quad where
  pure a = Quad (a, a, a, a)
  (<*>) (Quad (fa, fb, fc, fd)) (Quad (a, b, c, d))
    = Quad (fa a, fb b, fc c, fd d)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SGplus-1.1/Data/SG/Geometry/ThreeDim.hs
Applicative instance: 


instance Applicative Point3' where
  pure a = Point3 (a, a, a)
  (<*>) (Point3 (fa, fb, fc)) (Point3 (a, b, c)) = Point3 (fa a, fb b, fc c)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SGplus-1.1/Data/SG/Geometry/TwoDim.hs
Applicative instance: 


instance Applicative Point2' where
  pure a = Point2 (a, a)
  (<*>) (Point2 (fa, fb)) (Point2 (a, b)) = Point2 (fa a, fb b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SGplus-1.1/Data/SG/Matrix.hs
Applicative instance: 


instance Applicative c => Applicative (SquareMatrix c) where
  pure = SquareMatrix . pure . pure
  (SquareMatrix f) <*> (SquareMatrix m) = SquareMatrix $ (fmap (<*>) f) <*> m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monoid-subclasses-0.4.2.1/Data/Monoid/Instances/Positioned.hs
Applicative instance: 


instance Applicative OffsetPositioned where
   pure = OffsetPositioned 0
   OffsetPositioned _ f <*> OffsetPositioned p c = OffsetPositioned p (f c)
Applicative instance: 


instance Applicative LinePositioned where
   pure = LinePositioned 0 0 0
   LinePositioned _ _ _ f <*> LinePositioned p l lp c = LinePositioned p l lp (f c)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monoid-subclasses-0.4.2.1/Data/Monoid/Instances/Concat.hs
Applicative instance: 


instance Applicative Concat where
   pure a = Concat (Seq.singleton a)
   Concat x <*> Concat y = Concat (x <*> y)
   Concat x *> Concat y = Concat (x *> y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monoid-subclasses-0.4.2.1/Data/Monoid/Instances/Stateful.hs
Applicative instance: 


instance Monoid a => Applicative (Stateful a) where
   pure m = Stateful (m, mempty)
   Stateful (f, s1) <*> Stateful (x, s2) = Stateful (f x, s1 <> s2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rev-state-0.1.2/src/Control/Monad/Trans/RevState.hs
Monad instance: 


instance MonadFix m => Monad (StateT s m) where
  return x = state $ \s -> (x, s)
  m >>= f = StateT $ \s -> do
    rec
      (x, s'') <- runStateT m s'
      (x', s') <- runStateT (f x) s
    return (x', s'')
Applicative instance: 


instance MonadFix m => Applicative (StateT s m) where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CC-delcont-alt-0.1.1.1/Generator2.hs
Monad instance: 


instance Monad Identity where
    return = Identity
    m >>= f = f $ runIdentity m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CC-delcont-alt-0.1.1.1/Bench_nondet.hs
Monad instance: 


instance Monad CPS where
    return x = CPS $ \k -> k x
    m >>= f  = CPS $ \k -> unCPS m (\a -> unCPS (f a) k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-ran-0.1.0/Control/Monad/Ran.hs
Applicative instance: 


instance Applicative (Ran Identity) where
    pure = returnRanCodensity
    (<*>) = apRanCodensity
Monad instance: 


instance Monad (Ran Identity) where
    return = returnRanCodensity
    (>>=) = bindRanCodensity
Applicative instance: 


instance Applicative (Ran (State s)) where
    pure = returnRanCodensity
    (<*>) = apRanCodensity
Monad instance: 


instance Monad (Ran (State s)) where
    return = returnRanCodensity
    (>>=) = bindRanCodensity
Applicative instance: 


instance Monoid w => Applicative (Ran (Writer w)) where
    pure = returnRanCodensity
    (<*>) = apRanCodensity
Monad instance: 


instance Monoid w => Monad (Ran (Writer w)) where
    return = returnRanCodensity
    (>>=) = bindRanCodensity
Applicative instance: 


instance Applicative (Ran IO) where
    pure = returnRanCodensity
    (<*>) = apRanCodensity
Monad instance: 


instance Monad (Ran IO) where
    return = returnRanCodensity
    (>>=) = bindRanCodensity
Applicative instance: 


instance Applicative (Ran (ST s)) where
    pure = returnRanCodensity
    (<*>) = apRanCodensity
Monad instance: 


instance Monad (Ran (ST s)) where
    return = returnRanCodensity
    (>>=) = bindRanCodensity
Applicative instance: 


instance Applicative (Ran STM) where
    pure = returnRanCodensity
    (<*>) = apRanCodensity
Monad instance: 


instance Monad (Ran STM) where
    return = returnRanCodensity
    (>>=) = bindRanCodensity
Applicative instance: 


instance Applicative f => Applicative (Ran (Yoneda f)) where
    pure = liftRan . pure
    m <*> n = liftRan (lowerRan m <*> lowerRan n)
Monad instance: 


instance Monad f => Monad (Ran (Yoneda f)) where
    return = liftRan . return
    m >>= k = liftRan (lowerRan m >>= lowerRan . k)
Monad instance: 


instance Monad (Ran Maybe) where
    return x = Ran (\k -> Endo (\_ -> runIdentity (k x)))
    Ran g >>= f = Ran (\k -> Endo (\z -> appEndo (g (\a -> Identity (appEndo (getRan (f a) k) z))) z))
    fail _ = mzero
Applicative instance: 


instance Applicative (Ran Maybe) where
    pure x = Ran (\k -> Endo (\_ -> runIdentity (k x)))
    Ran f <*> Ran g = Ran (\k -> Endo (\z -> appEndo (f (\f' -> Identity (appEndo (g (k . f')) z))) z))
Monad instance: 


instance Error e => Monad (Ran (Either e)) where
    return x = Ran (\k -> ErrorH (\_ -> runIdentity (k x)))
    fail = throwError . strMsg
    Ran g >>= f = Ran (\k -> ErrorH (\z -> getErrorH (g (\a -> Identity (getErrorH (getRan (f a) k) z))) z))
Applicative instance: 


instance Applicative (Ran ((->)e)) where
    pure = return
    Ran f <*> Ran g = Ran (\k r -> runIdentity (k (f Identity r (g Identity r))))
Monad instance: 


instance Monad (Ran ((->)e)) where
    return a = Ran (\f _ -> runIdentity (f a))
    Ran f >>= h = Ran (\k r -> getRan (h (f Identity r)) k r)
Applicative instance: 


instance Applicative (Ran (Reader e)) where
    pure = return
    Ran f <*> Ran g = Ran (\k -> Reader (\r -> runIdentity (k (runReader (f Identity) r (runReader (g Identity) r)))))
Monad instance: 


instance Monad (Ran (Reader e)) where
    return a = Ran (\f -> Reader (\_ -> runIdentity (f a)))
    Ran f >>= h = Ran (\k -> Reader (\r -> runReader(getRan (h (runReader (f Identity) r)) k) r))
Applicative instance: 


instance RanMonad m => Applicative (Ran (ReaderT e m)) where
    pure = inRan . return
    f <*> g = inRan (outRan f `ap` outRan g)
Monad instance: 


instance RanMonad m => Monad (Ran (ReaderT e m)) where
    return = inRan . return
    m >>= f = inRan (outRan m >>= outRan . f)
Applicative instance: 


instance (RanMonad m, Error e) => Applicative (Ran (ErrorT e m)) where
    pure = inRan . return
    f <*> g = inRan (outRan f `ap` outRan g)
Monad instance: 


instance (RanMonad m, Error e)  => Monad (Ran (ErrorT e m)) where
    return = inRan . return
    m >>= f = inRan (outRan m >>= outRan . f)
Applicative instance: 


instance (Monoid w, RanMonad m) => Applicative (Ran (WriterT w m)) where
    pure = inRan . return
    f <*> g = inRan (outRan f `ap` outRan g)
Monad instance: 


instance (Monoid w, RanMonad m) => Monad (Ran (WriterT w m)) where
    return = inRan . return
    m >>= f = inRan (outRan m >>= outRan . f)
Applicative instance: 


instance (Monoid w, RanMonad m) => Applicative (Ran (SW.WriterT w m)) where
    pure = inRan . return
    f <*> g = inRan (outRan f `ap` outRan g)
Monad instance: 


instance (Monoid w, RanMonad m) => Monad (Ran (SW.WriterT w m)) where
    return = inRan . return
    m >>= f = inRan (outRan m >>= outRan . f)
Applicative instance: 


instance RanMonad m => Applicative (Ran (StateT e m)) where
    pure = inRan . return
    f <*> g = inRan (outRan f `ap` outRan g)
Monad instance: 


instance RanMonad m => Monad (Ran (StateT s m)) where
    return = inRan . return
    m >>= f = inRan (outRan m >>= outRan . f)
Applicative instance: 


instance RanMonad m => Applicative (Ran (SS.StateT e m)) where
    pure = inRan . return
    f <*> g = inRan (outRan f `ap` outRan g)
Monad instance: 


instance RanMonad m => Monad (Ran (SS.StateT s m)) where
    return = inRan . return
    m >>= f = inRan (outRan m >>= outRan . f)
Applicative instance: 


instance (RanMonad m, Monoid w) => Applicative (Ran (RWST r w s m)) where
    pure = inRan . return
    f <*> g = inRan (outRan f `ap` outRan g)
Monad instance: 


instance (RanMonad m, Monoid w) => Monad (Ran (RWST r w s m)) where
    return = inRan . return
    m >>= f = inRan (outRan m >>= outRan . f)
Applicative instance: 


instance (RanMonad m, Monoid w) => Applicative (Ran (SR.RWST r w s m)) where
    pure = inRan . return
    f <*> g = inRan (outRan f `ap` outRan g)
Monad instance: 


instance (RanMonad m, Monoid w) => Monad (Ran (SR.RWST r w s m)) where
    return = inRan . return
    m >>= f = inRan (outRan m >>= outRan . f)
Applicative instance: 


instance Applicative (Codensity f) where
    pure x = Codensity (\k -> k x)
    Codensity f <*> Codensity x = Codensity (\k -> f (\f' -> x (k . f')))
Monad instance: 


instance Monad (Codensity f) where
    return x = Codensity (\k -> k x)
    Codensity m >>= k = Codensity
        (\c -> m (\a -> getCodensity (k a) c))
Applicative instance: 


instance Applicative (Ran (Codensity f)) where
    pure = returnRanCodensity
    (<*>) = apRanCodensity
Monad instance: 


instance Monad (Ran (Codensity f)) where
    return = returnRanCodensity
    (>>=) = bindRanCodensity
Applicative instance: 


instance Applicative f => Applicative (Yoneda f) where
    pure a = Yoneda (\f -> pure (f a))
    m <*> n = Yoneda (\f -> getYoneda m (f .) <*> getYoneda n id)
Monad instance: 


instance Monad f => Monad (Yoneda f) where
    return a = Yoneda (\f -> return (f a))
    m >>= k = Yoneda (\f -> getYoneda m id >>= \a -> getYoneda (k a) f)
Applicative instance: 


instance Applicative (Ran (Cont r)) where
    pure = returnRanCodensity
    (<*>) = apRanCodensity
Monad instance: 


instance Monad (Ran (Cont r)) where
    return = returnRanCodensity
    (>>=) = bindRanCodensity
Monad instance: 


instance Monad (Ran (ContT r m)) where
    return = returnRanCodensity
    (>>=) = bindRanCodensity
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/attoparsec-0.9.1.2/tests/QCSupport.hs
Applicative instance: 


instance Applicative NonEmpty where
    NonEmpty f <*> NonEmpty a = NonEmpty (f a)
    pure a                    = NonEmpty a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/attoparsec-0.9.1.2/Data/Attoparsec/Zepto.hs
Monad instance: 


instance Monad Parser where
    return a = Parser $ \s -> (# OK a, s #)
    {-# INLINE return #-}

    m >>= k   = Parser $ \s -> case runParser m s of
                                 (# OK a, s' #) -> runParser (k a) s'
                                 (# Fail err, s' #) -> (# Fail err, s' #)
    {-# INLINE (>>=) #-}

    fail msg = Parser $ \s -> (# Fail msg, s #)
Applicative instance: 


instance Applicative Parser where
    pure   = return
    {-# INLINE pure #-}
    (<*>)  = ap
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/search-0.1.0.1/src/Data/Search.hs
Applicative instance: 


instance Applicative (Search a) where
  pure b = Search $ \_ -> b
  fs <*> as = Search $ \p ->
    let go q = q $ optimum as (p.q)
    in  go $ optimum fs (p.go)
Monad instance: 


instance Monad (Search a) where
  return a = Search $ \_ -> a
  Search ma >>= f = Search $ \p ->
    optimum (f (ma (\a -> p (optimum (f a) p)))) p
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/search-0.1.0.1/src/Data/Search/Intensional.hs
Applicative instance: 


instance Applicative (Search a) where
  pure a = Search $ \_ -> return a
  (<*>) = ap
Monad instance: 


instance Monad (Search a) where
  return a = Search $ \_ -> return a
  m >>= k = jn (fmap k m) where
    jn x = Search $ \p -> do
      z <- optimumM x $ \ y -> optimumM y p >>= p
      optimumM z p
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chalmers-lava2000-1.6.1/Lava/Property.hs
Applicative instance: 


instance Applicative Gen where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad Gen where
  return a =
    Gen (\t -> a)

  Gen m >>= k =
    Gen (\(Fork _ t1 t2) -> let a = m t1 ; Gen m2 = k a in m2 t2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/non-empty-0.3/src/Data/Zip.hs
Applicative instance: 


instance (C.Zip f, C.Repeat f) => Applicative (T f) where
   pure a = Cons $ C.repeat a
   Cons f <*> Cons x = Cons $ C.zipWith ($) f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/non-empty-0.3/src/Data/NonEmptyPrivate.hs
Applicative instance: 


instance
   (Applicative f, C.Empty f, C.Cons f, C.Append f) =>
      Applicative (T f) where
   pure = singleton
   (<*>) = apply
Monad instance: 


instance (Monad f, C.Empty f, C.Cons f, C.Append f) =>
      Monad (T f) where
   return = singleton
   (>>=) = bind
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/vector-space-map-0.2.0/src/Data/Map/Vector.hs
Applicative instance: 


instance (Ord k) => Applicative (MapVector k) where
    pure = ConstantMap
    (ConstantMap f) <*> (ConstantMap v) = ConstantMap $ f v
    (ConstantMap f) <*> (MapVector vs)  = MapVector   $ f     <$> vs
    (MapVector fs)  <*> (ConstantMap v) = MapVector   $ ($ v) <$> fs
    (MapVector fs)  <*> (MapVector vs)  = MapVector   $ Map.intersectionWith ($) fs vs
    {-# INLINABLE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hmatrix-tests-0.5.0.0/src/Numeric/LinearAlgebra/Tests.hs
Applicative instance: 


instance Applicative (State s)
  where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad (State s) where
    return a = State $ \s -> (a,s)
    m >>= f = State $ \s -> let (a,s') = runState m s
                            in runState (f a) s'
Applicative instance: 


instance Monad m => Applicative (MaybeT m)
  where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad m => Monad (MaybeT m) where
    return a = MaybeT $ return $ Just a
    m >>= f  = MaybeT $ do
                        res <- runMaybeT m
                        case res of
                                 Nothing -> return Nothing
                                 Just r  -> runMaybeT (f r)
    fail _   = MaybeT $ return Nothing
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtlparse-0.1.4.0/Text/ParserCombinators/MTLParse/MTLParseCore.hs
Applicative instance: 


instance Applicative ( Parse p ) where
  pure = return; (<*>) = ap
Monad instance: 


instance Monad ( Parse a ) where
  return = Parse . \val inp -> [ (val, inp) ]
  Parse pr >>= f
         = Parse ( \st -> concat
             [ runParse ( f a ) rest | ( a, rest ) <- pr st ] )
Applicative instance: 


instance Monad m => Applicative ( ParseT a m ) where
  pure = return; (<*>) = ap
Monad instance: 


instance Monad m => Monad ( ParseT a m ) where
  return b = ParseT $ \a -> return [ (b, a) ]
  ParseT pr >>= f
    = ParseT $ \a ->
        pr a >>=
          liftM concat . mapM ( \(a', rest) -> runParseT (f a') rest )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/caledon-3.2.2.0/Choice.hs
Monad instance: 


instance Monad Choice where
  fail = Fail
  return = Success
  Fail a >>= _ = Fail a
  (m :<|>: m') >>= f = (m >>= f) :<|>: (m' >>= f)
  Success a >>= f = f a
Applicative instance: 


instance Applicative Choice where
  pure = Success
  mf <*> ma = mf >>= (<$> ma)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/Cont.hs
Monad instance: 


instance Monad (Cont r) where
    return a = Cont ($ a)
    m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
Monad instance: 


instance (Monad m) => Monad (ContT r m) where
    return a = ContT ($ a)
    m >>= k  = ContT $ \c -> runContT m (\a -> runContT (k a) c)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/Error.hs
Monad instance: 


instance (Monad m, Error e) => Monad (ErrorT e m) where
    return a = ErrorT $ return (Right a)
    m >>= k  = ErrorT $ do
        a <- runErrorT m
        case a of
            Left  l -> return (Left l)
            Right r -> runErrorT (k r)
    fail msg = ErrorT $ return (Left (strMsg msg))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/Identity.hs
Monad instance: 


instance Monad Identity where
    return a = Identity a
    m >>= k  = k (runIdentity m)
Monad instance: 


instance Monad m => Monad (IdentityT m) where
  return   =  IdentityT . return
  m >>= f  =  IdentityT $ runIdentityT m >>= runIdentityT . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/State/Strict.hs
Monad instance: 


instance Monad (State s) where
    return a = State $ \s -> (a, s)
    m >>= k  = State $ \s -> case runState m s of
                                 (a, s') -> runState (k a) s'
Monad instance: 


instance (Monad m) => Monad (StateT s m) where
    return a = StateT $ \s -> return (a, s)
    m >>= k  = StateT $ \s -> do
        (a, s') <- runStateT m s
        runStateT (k a) s'
    fail str = StateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/State/Lazy.hs
Monad instance: 


instance Monad (State s) where
    return a = State $ \s -> (a, s)
    m >>= k  = State $ \s -> let
        (a, s') = runState m s
        in runState (k a) s'
Monad instance: 


instance (Monad m) => Monad (StateT s m) where
    return a = StateT $ \s -> return (a, s)
    m >>= k  = StateT $ \s -> do
        ~(a, s') <- runStateT m s
        runStateT (k a) s'
    fail str = StateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/Mask.hs
Monad instance: 


instance Monad m => Monad (Tagged tag m) where
  return   = Tag . return
  m >>= f  = Tag $ unTag m >>= unTag . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/RWS/Strict.hs
Monad instance: 


instance (Monoid w) => Monad (RWS r w s) where
    return a = RWS $ \_ s -> (a, s, mempty)
    m >>= k  = RWS $ \r s -> case runRWS m r s of
                                 (a, s',  w) ->
                                     case runRWS (k a) r s' of
                                         (b, s'', w') ->
                                             (b, s'', w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (RWST r w s m) where
    return a = RWST $ \_ s -> return (a, s, mempty)
    m >>= k  = RWST $ \r s -> do
        (a, s', w)  <- runRWST m r s
        (b, s'',w') <- runRWST (k a) r s'
        return (b, s'', w `mappend` w')
    fail msg = RWST $ \_ _ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/RWS/Lazy.hs
Monad instance: 


instance (Monoid w) => Monad (RWS r w s) where
    return a = RWS $ \_ s -> (a, s, mempty)
    m >>= k  = RWS $ \r s -> let
        (a, s',  w)  = runRWS m r s
        (b, s'', w') = runRWS (k a) r s'
        in (b, s'', w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (RWST r w s m) where
    return a = RWST $ \_ s -> return (a, s, mempty)
    m >>= k  = RWST $ \r s -> do
        ~(a, s', w)  <- runRWST m r s
        ~(b, s'',w') <- runRWST (k a) r s'
        return (b, s'', w `mappend` w')
    fail msg = RWST $ \_ _ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/Reader.hs
Monad instance: 


instance Monad (Reader r) where
    return a = Reader $ \_ -> a
    m >>= k  = Reader $ \r -> runReader (k (runReader m r)) r
Monad instance: 


instance (Monad m) => Monad (ReaderT r m) where
    return a = ReaderT $ \_ -> return a
    m >>= k  = ReaderT $ \r -> do
        a <- runReaderT m r
        runReaderT (k a) r
    fail msg = ReaderT $ \_ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/Zipper.hs
Monad instance: 


instance (MonadTrans t1, MonadTrans t2, Monad m) => Monad ((t1 :> t2) m) where
  return x  = returnZ x
  m >>= f   = m `bindZ` f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/Views.hs
Monad instance: 


instance Monad m => Monad (MonadStateReaderT s m) where
  return   = MonadStateReaderT . return
  x >>= f  = MonadStateReaderT $ runMonadStateReaderT x >>= runMonadStateReaderT . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/List.hs
Monad instance: 


instance (Monad m) => Monad (ListT m) where
    return a = ListT $ return [a]
    m >>= k  = ListT $ do
        a <- runListT m
        b <- mapM (runListT . k) a
        return (concat b)
    fail _ = ListT $ return []
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/Writer/Strict.hs
Monad instance: 


instance (Monoid w) => Monad (Writer w) where
    return a = Writer (a, mempty)
    m >>= k  = Writer $ case runWriter m of
                            (a, w) -> case runWriter (k a) of
                                (b, w') -> (b, w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (WriterT w m) where
    return a = WriterT $ return (a, mempty)
    m >>= k  = WriterT $ do
        (a, w)  <- runWriterT m
        (b, w') <- runWriterT (k a)
        return (b, w `mappend` w')
    fail msg = WriterT $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/Writer/Lazy.hs
Monad instance: 


instance (Monoid w) => Monad (Writer w) where
    return a = Writer (a, mempty)
    m >>= k  = Writer $ let
        (a, w)  = runWriter m
        (b, w') = runWriter (k a)
        in (b, w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (WriterT w m) where
    return a = WriterT $ return (a, mempty)
    m >>= k  = WriterT $ do
        ~(a, w)  <- runWriterT m
        ~(b, w') <- runWriterT (k a)
        return (b, w `mappend` w')
    fail msg = WriterT $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/language-c-0.5.0/src/Language/C/Parser/ParserMonad.hs
Applicative instance: 


instance Applicative P where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad P where
  return = returnP
  (>>=) = thenP
  fail m = getPos >>= \pos -> failP pos [m]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/language-c-0.5.0/src/Language/C/Analysis/TravMonad.hs
Applicative instance: 


instance Applicative (Trav s) where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad (Trav s) where
    return x  = Trav (\s -> Right (x,s))
    m >>= k   = Trav (\s -> case unTrav m s of
                              Right (x,s1) -> unTrav (k x) s1
                              Left e       -> Left e)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/DSTM-0.1.2/Control/Distributed/STM/STM.hs
Monad instance: 


instance Monad STM where
  -- (>>=) :: STM a -> (a -> STM b) -> STM b
  (STM tr1)  >>= k = STM (\state -> do
                          stmRes <- tr1 state
                          case stmRes of
                            Success newState v ->
                               let (STM tr2) = k v in
                                 tr2 newState
                            Retry newState -> return (Retry newState)
                            Exception newState e -> return (Exception newState e)
                       )
  -- return :: a -> STM a
  return x      = STM (\state -> return (Success state x))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bake-0.4/src/General/HTML.hs
Applicative instance: 


instance Applicative HTML_ where
    pure = HTML_ mempty
    HTML_ x1 x2 <*> HTML_ y1 y2 = HTML_ (x1 `mappend` y1) (x2 y2)
Monad instance: 


instance Monad HTML_ where
    return = pure
    HTML_ x1 x2 >>= f = let HTML_ y1 y2 = f x2 in HTML_ (x1 `mappend` y1) y2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/STMonadTrans-0.3.3/Control/Monad/ST/Trans.hs
Monad instance: 


#if __GLASGOW_HASKELL__ < 708
isTrue# :: Bool -> Bool
isTrue# x = x
#endif

instance Monad m => Monad (STT s m) where
  return a = STT $ \st -> return (STTRet st a)
  STT m >>= k = STT $ \st ->
    do ret <- m st
       case ret of
         STTRet new_st a ->
             unSTT (k a) new_st
  fail msg = lift (fail msg)
Applicative instance: 


instance (Monad m, Functor m) => Applicative (STT s m) where
  pure a = STT $ \s# -> return (STTRet s# a)
  (STT m) <*> (STT n) = STT $ \s1 ->
                        do (STTRet s2 f) <- m s1
                           (STTRet s3 x) <- n s2
                           return (STTRet s3 (f x))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrowapply-utils-0.2/Control/Arrow/ApplyUtils.hs
Monad instance: 


-- | An instance that lets you work with Arrows that support ArrowApply as monads.
-- | Example:
-- |   myarrow :: ArrowApply a => a Int Int
-- |   myarrow = monadicA $ \v -> do
-- |               let vp1 = v + 1
-- |               v' <- unmonadicA anotherIntToIntArrow vp1
-- |               return (v' * 10)
instance (Arrow a, ArrowApply a) => Monad (ArrowAsMonad a)
  where
    (ArrowAsMonad x) >>= y =
      ArrowAsMonad $ (x >>^ (\v -> (unApplyAsMonad (y v), ()))) >>> app
    return = ArrowAsMonad . arr . const
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/remote-monad-0.2/src/Control/Remote/Monad/Packet/Applicative.hs
Applicative instance: 


instance Applicative (ApplicativePacket c p) where
  pure a = Pure a
  (Pure f) <*> m = fmap f m
  (Command g c)   <*> (Pure a)        = Command (fmap (\ f -> f a) g) c
  (Procedure g p) <*> (Pure a)        = Procedure (fmap (\ f a1 -> f a1 a) g) p
  m <*> (Command g2 c2)               = Command  (m           <*> g2) c2
  m <*> (Procedure g2 p2)             = Procedure (fmap (.) m <*> g2) p2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/remote-monad-0.2/src/Control/Remote/Monad/Types.hs
Applicative instance: 


instance Applicative (RemoteMonad c p) where
  pure a                = Appl (pure a)
  Appl f   <*> Appl g   = Appl (f <*> g)
  Appl f   <*> Bind m k = Bind (pure (,) <*> f <*> m) (\ (a,b) -> pure a <*> k b)
  Bind m k <*> r        = Bind m (\ a -> k a <*> r)

  Appl f   *> Appl g   = Appl (f *> g)
  Appl f   *> Bind m k = Bind (f *> m) k
  Bind m k *> r        = Bind m (\ a -> k a *> r)

  Appl f   <* Appl g   = Appl (f <* g)
  Appl f   <* Bind m k = Bind (pure (,) <*> f <*> m) (\ (a,b) -> pure a <* k b)
  Bind m k <* r        = Bind m (\ a -> k a <* r)
Monad instance: 


instance Monad (RemoteMonad c p) where
  return = pure
  Appl m >>= k    = Bind m k
  Bind m k >>= k2 = Bind m (\ a -> k a >>= k2)

  m1 >> m2 = m1 *> m2
Applicative instance: 


instance Applicative (RemoteApplicative c p) where
  pure a = RemoteApplicative (pure a)
  (RemoteApplicative f) <*> (RemoteApplicative g) = RemoteApplicative (f <*> g)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Cabal-1.8.0.6/Distribution/Compat/ReadP.hs
Monad instance: 
 -- invariant: list is non-empty!

-- Monad, MonadPlus

instance Monad (P s) where
  return x = Result x Fail

  (Get f)      >>= k = Get (\c -> f c >>= k)
  (Look f)     >>= k = Look (\s -> f s >>= k)
  Fail         >>= _ = Fail
  (Result x p) >>= k = k x `mplus` (p >>= k)
  (Final r)    >>= k = final [ys' | (x,s) <- r, ys' <- run (k x) s]

  fail _ = Fail
Monad instance: 


instance Monad (Parser r s) where
  return x  = R (\k -> k x)
  fail _    = R (\_ -> Fail)
  R m >>= f = R (\k -> m (\a -> let R m' = f a in m' k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Cabal-1.8.0.6/Distribution/PackageDescription/Parse.hs
Monad instance: 


instance Monad m => Monad (StT s m) where
    return a = StT (\s -> return (a,s))
    StT f >>= g = StT $ \s -> do
                        (a,s') <- f s
                        runStT (g a) s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Cabal-1.8.0.6/Distribution/ParseUtils.hs
Monad instance: 


instance Monad ParseResult where
        return x = ParseOk [] x
        ParseFailed err >>= _ = ParseFailed err
        ParseOk ws x >>= f = case f x of
                               ParseFailed err -> ParseFailed err
                               ParseOk ws' x' -> ParseOk (ws'++ws) x'
        fail s = ParseFailed (FromString s Nothing)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/archlinux-1.3/Distribution/ArchLinux/PkgBuild.hs
Monad instance: 


instance Monad GetPKG where
  return x       = GetPKG (\s -> Right (x,s))
  fail x         = GetPKG (\_ -> Left x)
  GetPKG m >>= f = GetPKG (\s -> case m s of
                                     Left err -> Left err
                                     Right (a,s1) -> un (f a) s1)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/redHandlers-0.1/Network/HTTP/RedHandler/Response.hs
Monad instance: 
 -- The redirect address is encoded on the headers
--                    | ErrorResp ErrorResp
--data ErrorResp = ForbiddenResp | ...

instance Monad HandlerRsp where
  return x = HandlerRsp [] (Right x)
  (HandlerRsp hdrs (Right x)) >>= f = insertHeaders hdrs $ f x
  (HandlerRsp hdrs (Left non200resp)) >>= f = (HandlerRsp hdrs (Left non200resp))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/welshy-0.1.0.0/Web/Welshy/Action.hs
Applicative instance: 


instance Applicative Action where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad Action where
    return a = Action $ \_ s -> return $ Ok a s
    m >>= k  = Action $ \r s -> runAction m r s >>= \case
        Ok a s1 -> runAction (k a) r s1
        Halt s1 -> return $ Halt s1
        Pass    -> return $ Pass

    fail msg = halt $ error msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hans-3.0.0.1/src/Hans/Monad.hs
Applicative instance: 


instance A.Applicative Hans where
  pure x  = Hans (\ _ k -> k x)

  f <*> x = Hans $ \ e k -> unHans f e
                 $ \ g   -> unHans x e
                 $ \ y   -> k (g y)

  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Hans where
  return  = A.pure

  m >>= f = Hans $ \ e k -> unHans m e
                 $ \ a   -> unHans (f a) e k

  {-# INLINE return #-}
  {-# INLINE (>>=)  #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/numeric-tools-0.2.0.1/Numeric/Tools/Equation.hs
Monad instance: 


instance Monad Root where
  NotBracketed >>= _ = NotBracketed
  SearchFailed >>= _ = SearchFailed
  Root a       >>= m = m a
  return = Root
Applicative instance: 


instance Applicative Root where
  pure  = Root
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/midair-0.2.0.0/Midair/Core.hs
Applicative instance: 


instance Applicative (SFlow a) where
   pure x = SF_Map $ \_ -> x
   (<*>) a b = SF_Compose (SF_Map (\(f, x) -> f x)) (SF_Zip a b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/Cont.hs
Monad instance: 


instance Monad (Cont r) where
    return a = Cont ($ a)
    m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
Monad instance: 


instance (Monad m) => Monad (ContT r m) where
    return a = ContT ($ a)
    m >>= k  = ContT $ \c -> runContT m (\a -> runContT (k a) c)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/Error.hs
Monad instance: 


-- ---------------------------------------------------------------------------
-- Our parameterizable error monad

instance (Error e) => Monad (Either e) where
    return        = Right
    Left  l >>= _ = Left l
    Right r >>= k = k r
    fail msg      = Left (strMsg msg)
Monad instance: 


instance (Monad m, Error e) => Monad (ErrorT e m) where
    return a = ErrorT $ return (Right a)
    m >>= k  = ErrorT $ do
        a <- runErrorT m
        case a of
            Left  l -> return (Left l)
            Right r -> runErrorT (k r)
    fail msg = ErrorT $ return (Left (strMsg msg))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/Identity.hs
Monad instance: 


instance Monad Identity where
    return a = Identity a
    m >>= k  = k (runIdentity m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/State/Strict.hs
Monad instance: 


instance Monad (State s) where
    return a = State $ \s -> (a, s)
    m >>= k  = State $ \s -> case runState m s of
                                 (a, s') -> runState (k a) s'
Monad instance: 


instance (Monad m) => Monad (StateT s m) where
    return a = StateT $ \s -> return (a, s)
    m >>= k  = StateT $ \s -> do
        (a, s') <- runStateT m s
        runStateT (k a) s'
    fail str = StateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/State/Lazy.hs
Monad instance: 


instance Monad (State s) where
    return a = State $ \s -> (a, s)
    m >>= k  = State $ \s -> let
        (a, s') = runState m s
        in runState (k a) s'
Monad instance: 


instance (Monad m) => Monad (StateT s m) where
    return a = StateT $ \s -> return (a, s)
    m >>= k  = StateT $ \s -> do
        ~(a, s') <- runStateT m s
        runStateT (k a) s'
    fail str = StateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/Codensity.hs
Monad instance: 


instance Monad (Codensity f) where
    return a = Codensity (\k -> k a)
    c >>= f  = Codensity (\k -> runCodensity c (\a -> runCodensity (f a) k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/Reader.hs
Monad instance: 


instance Monad (Reader r) where
    return a = Reader $ \_ -> a
    m >>= k  = Reader $ \r -> runReader (k (runReader m r)) r
Monad instance: 


instance (Monad m) => Monad (ReaderT r m) where
    return a = ReaderT $ \_ -> return a
    m >>= k  = ReaderT $ \r -> do
        a <- runReaderT m r
        runReaderT (k a) r
    fail msg = ReaderT $ \_ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/List.hs
Monad instance: 


instance (Monad m) => Monad (ListT m) where
    return a = ListT $ return [a]
    m >>= k  = ListT $ do
        a <- runListT m
        b <- mapM (runListT . k) a
        return (concat b)
    fail _ = ListT $ return []
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/Writer/Strict.hs
Monad instance: 


instance (Monoid w) => Monad (Writer w) where
    return a = Writer (a, mempty)
    m >>= k  = Writer $ case runWriter m of
                            (a, w) -> case runWriter (k a) of
                                (b, w') -> (b, w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (WriterT w m) where
    return a = WriterT $ return (a, mempty)
    m >>= k  = WriterT $ do
        (a, w)  <- runWriterT m
        (b, w') <- runWriterT (k a)
        return (b, w `mappend` w')
    fail msg = WriterT $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/Writer/Lazy.hs
Monad instance: 


instance (Monoid w) => Monad (Writer w) where
    return a = Writer (a, mempty)
    m >>= k  = Writer $ let
        (a, w)  = runWriter m
        (b, w') = runWriter (k a)
        in (b, w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (WriterT w m) where
    return a = WriterT $ return (a, mempty)
    m >>= k  = WriterT $ do
        ~(a, w)  <- runWriterT m
        ~(b, w') <- runWriterT (k a)
        return (b, w `mappend` w')
    fail msg = WriterT $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/error-message-1.1/Data/ErrorMessage.hs
Applicative instance: 

-- @-node:gcross.20091202203048.1607:ErrorMessage
-- @-node:gcross.20091202203048.1606:Types
-- @+node:gcross.20091202203048.1608:Instances
-- @+node:gcross.20091202203048.1609:Applicative (Either e a)
-- @@raw
-- @@end_raw

instance (Monoid e) => Applicative (Either e) where
    pure = Right
    (<*>) (Left error2) (Left error1) = Left (error1 `mappend` error2)
    (<*>) (Left error) _ = Left error
    (<*>) _ (Left error) = Left error
    (<*>) (Right function) (Right argument) = Right (function argument)
Applicative instance: 

-- @-node:gcross.20091202203048.1609:Applicative (Either e a)
-- @+node:gcross.20091202203048.1610:Applicative (ErrorT e m a)
instance (Monoid e, Error e, Monad m) => Applicative (ErrorT e m) where
    pure = return
    e_fn <*> e_arg = ErrorT $ liftM2 (<*>) (runErrorT e_fn) (runErrorT e_arg)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gll-0.3.0.9/src/GLL/Parser.hs
Applicative instance: 


instance Applicative (GLL t) where
    (<*>) = ap
    pure  = return
Monad instance: 

instance Monad (GLL t) where
    return a = GLL $ \_ p -> (a, p)
    (GLL m) >>= f  = GLL $ \o p -> let (a, p')  = m o p
                                       (GLL m') = f a
                                    in m' o p'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dejafu-0.3.2.1/Test/DejaFu/Deterministic/Internal/Common.hs
Applicative instance: 


instance Applicative (M n r s) where
    pure x  = M $ \c -> AReturn $ c x
    f <*> v = M $ \c -> runM f (\g -> runM v (c . g))
Monad instance: 


instance Monad (M n r s) where
    return  = pure
    m >>= k = M $ \c -> runM m (\x -> runM (k x) c)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/minioperational-0.4.9/Control/Monad/Trans/Operational/Mini.hs
Applicative instance: 


instance Applicative (ProgramT t m) where
    pure a = ProgramT $ \p _ _ -> p a
    ProgramT mf <*> ProgramT ma = ProgramT $ \p l i -> mf (\f -> ma (p . f) l i) l i
Monad instance: 


instance Monad (ProgramT t m) where
    return a = ProgramT $ \p _ _ -> p a
    ProgramT m >>= k = ProgramT $ \p l i -> m (\a -> unProgramT (k a) p l i) l i
Applicative instance: 


instance Monad m => Applicative (ReifiedProgramT t m) where
    pure = Return
    {-# INLINE pure #-}
    Return f <*> Return a = Return (f a)
    mf <*> m = mf >>= \f -> fmap f m
Monad instance: 


instance Monad m => Monad (ReifiedProgramT t m) where
    return = Return
    {-# INLINE return #-}
    Return a >>= f = f a
    (t :>>= m) >>= k = t :>>= (>>= k) . m
    Lift a c >>= f = Lift a (c >=> f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/minioperational-0.4.9/Control/Monad/Operational/Mini.hs
Applicative instance: 


instance Applicative (Program t) where
    pure a = Program $ \p _ -> p a
    Program mf <*> Program ma = Program $ \p i -> mf (\f -> ma (p . f) i) i
Monad instance: 


instance Monad (Program t) where
    return a = Program $ \p _ -> p a
    Program m >>= k = Program $ \p i -> m (\a -> unProgram (k a) p i) i
Applicative instance: 


instance Applicative (ReifiedProgram t) where
    pure = Return
    {-# INLINE pure #-}
    Return f <*> Return a = Return (f a)
    mf <*> m = mf >>= \f -> fmap f m
Monad instance: 


instance Monad (ReifiedProgram t) where
    return = Return
    {-# INLINE return #-}
    Return a >>= f = f a
    (t :>>= m) >>= k = t :>>= (>>= k) . m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mac-0.1.3.0/MAC/Core.hs
Applicative instance: 


instance Applicative (MAC l) where
    pure = MkMAC . return
    (<*>) (MkMAC f) (MkMAC a) = MkMAC (f <*> a)
Monad instance: 


instance Monad (MAC l) where
   return = pure
   MkMAC m >>= k = ioTCB (m >>= runMAC . k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/protocol-buffers-fork-2.0.16/Text/ProtocolBuffers/Get.hs
Monad instance: 


instance Monad Get where
  return a = seq a $ Get (\sc -> sc a)
  {-# INLINE return #-}
  m >>= k  = Get (\sc -> unGet m (\ a -> seq a $ unGet (k a) sc))
  {-# INLINE (>>=) #-}
  fail = throwError . strMsg
Applicative instance: 


instance Applicative Get where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tuples-homogenous-h98-0.1.1.0/Data/Tuple/Homogenous.hs
Applicative instance: 

instance Applicative Tuple0 where
    pure _ = tuple0
    {-# INLINE pure #-}
    _ <*> _ = tuple0
    {-# INLINE (<*>) #-}
    _  *> _ = tuple0
    {-# INLINE (*>) #-}
    _ <*  _ = tuple0
    {-# INLINE (<*) #-}
Monad instance: 

instance Monad Tuple0 where
    return = pure
    {-# INLINE return #-}
    _ >>= _ = tuple0
    {-# INLINE (>>=) #-}
    (>>)    = (*>)
    {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple1 where
    pure = tuple1
    {-# INLINE pure #-}
    (Tuple1 f) <*> (Tuple1 k) = tuple1 (f k)
    {-# INLINE (<*>) #-}
    _  *> k = k
    {-# INLINE (*>) #-}
    k <*  _ = k
    {-# INLINE (<*) #-}
Monad instance: 

instance Monad Tuple1 where
    return = pure
    {-# INLINE return #-}
    (Tuple1 k) >>= f = f k
    {-# INLINE (>>=) #-}
    (>>)    = (*>)
    {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple2
    where pure x = Tuple2 (x, x)
          {-# INLINE pure #-}
          (<*>) (Tuple2 (f1, f2)) (Tuple2 (x1,
                                                             x2)) = Tuple2 (f1 x1, f2 x2)
          {-# INLINEABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple2
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple2 (x1, x2)) f = Tuple2 (case f x1 of
                                                         Tuple2 (y, _) -> y,
                                                     case f x2 of
                                                         Tuple2 (_, y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple3
    where pure x = Tuple3 (x, x, x)
          {-# INLINE pure #-}
          (<*>) (Tuple3 (f1, f2, f3)) (Tuple3 (x1,
                                                                 x2,
                                                                 x3)) = Tuple3 (f1 x1, f2 x2, f3 x3)
          {-# INLINEABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple3
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple3 (x1, x2, x3)) f = Tuple3 (case f x1 of
                                                             Tuple3 (y, _, _) -> y,
                                                         case f x2 of
                                                             Tuple3 (_, y, _) -> y,
                                                         case f x3 of
                                                             Tuple3 (_, _, y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple4
    where pure x = Tuple4 (x, x, x, x)
          {-# INLINE pure #-}
          (<*>) (Tuple4 (f1, f2, f3, f4)) (Tuple4 (x1,
                                                                     x2,
                                                                     x3,
                                                                     x4)) = Tuple4 (f1 x1,
                                                                                    f2 x2,
                                                                                    f3 x3,
                                                                                    f4 x4)
          {-# INLINEABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple4
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple4 (x1, x2, x3, x4)) f = Tuple4 (case f x1 of
                                                                 Tuple4 (y, _, _, _) -> y,
                                                             case f x2 of
                                                                 Tuple4 (_, y, _, _) -> y,
                                                             case f x3 of
                                                                 Tuple4 (_, _, y, _) -> y,
                                                             case f x4 of
                                                                 Tuple4 (_, _, _, y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple5
    where pure x = Tuple5 (x, x, x, x, x)
          {-# INLINE pure #-}
          (<*>) (Tuple5 (f1, f2, f3, f4, f5)) (Tuple5 (x1,
                                                                         x2,
                                                                         x3,
                                                                         x4,
                                                                         x5)) = Tuple5 (f1 x1,
                                                                                        f2 x2,
                                                                                        f3 x3,
                                                                                        f4 x4,
                                                                                        f5 x5)
          {-# INLINEABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple5
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple5 (x1, x2, x3, x4, x5)) f = Tuple5 (case f x1 of
                                                                     Tuple5 (y, _, _, _, _) -> y,
                                                                 case f x2 of
                                                                     Tuple5 (_, y, _, _, _) -> y,
                                                                 case f x3 of
                                                                     Tuple5 (_, _, y, _, _) -> y,
                                                                 case f x4 of
                                                                     Tuple5 (_, _, _, y, _) -> y,
                                                                 case f x5 of
                                                                     Tuple5 (_, _, _, _, y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple6
    where pure x = Tuple6 (x, x, x, x, x, x)
          {-# INLINE pure #-}
          (<*>) (Tuple6 (f1,
                                           f2,
                                           f3,
                                           f4,
                                           f5,
                                           f6)) (Tuple6 (x1, x2, x3, x4, x5, x6)) = Tuple6 (f1 x1,
                                                                                            f2 x2,
                                                                                            f3 x3,
                                                                                            f4 x4,
                                                                                            f5 x5,
                                                                                            f6 x6)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple6
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple6 (x1,
                                x2,
                                x3,
                                x4,
                                x5,
                                x6)) f = Tuple6 (case f x1 of
                                                     Tuple6 (y, _, _, _, _, _) -> y,
                                                 case f x2 of
                                                     Tuple6 (_, y, _, _, _, _) -> y,
                                                 case f x3 of
                                                     Tuple6 (_, _, y, _, _, _) -> y,
                                                 case f x4 of
                                                     Tuple6 (_, _, _, y, _, _) -> y,
                                                 case f x5 of
                                                     Tuple6 (_, _, _, _, y, _) -> y,
                                                 case f x6 of
                                                     Tuple6 (_, _, _, _, _, y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple7
    where pure x = Tuple7 (x, x, x, x, x, x, x)
          {-# INLINE pure #-}
          (<*>) (Tuple7 (f1,
                                           f2,
                                           f3,
                                           f4,
                                           f5,
                                           f6,
                                           f7)) (Tuple7 (x1,
                                                         x2,
                                                         x3,
                                                         x4,
                                                         x5,
                                                         x6,
                                                         x7)) = Tuple7 (f1 x1,
                                                                        f2 x2,
                                                                        f3 x3,
                                                                        f4 x4,
                                                                        f5 x5,
                                                                        f6 x6,
                                                                        f7 x7)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple7
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple7 (x1,
                                x2,
                                x3,
                                x4,
                                x5,
                                x6,
                                x7)) f = Tuple7 (case f x1 of
                                                     Tuple7 (y, _, _, _, _, _, _) -> y,
                                                 case f x2 of
                                                     Tuple7 (_, y, _, _, _, _, _) -> y,
                                                 case f x3 of
                                                     Tuple7 (_, _, y, _, _, _, _) -> y,
                                                 case f x4 of
                                                     Tuple7 (_, _, _, y, _, _, _) -> y,
                                                 case f x5 of
                                                     Tuple7 (_, _, _, _, y, _, _) -> y,
                                                 case f x6 of
                                                     Tuple7 (_, _, _, _, _, y, _) -> y,
                                                 case f x7 of
                                                     Tuple7 (_, _, _, _, _, _, y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple8
    where pure x = Tuple8 (x, x, x, x, x, x, x, x)
          {-# INLINE pure #-}
          (<*>) (Tuple8 (f1,
                                           f2,
                                           f3,
                                           f4,
                                           f5,
                                           f6,
                                           f7,
                                           f8)) (Tuple8 (x1,
                                                         x2,
                                                         x3,
                                                         x4,
                                                         x5,
                                                         x6,
                                                         x7,
                                                         x8)) = Tuple8 (f1 x1,
                                                                        f2 x2,
                                                                        f3 x3,
                                                                        f4 x4,
                                                                        f5 x5,
                                                                        f6 x6,
                                                                        f7 x7,
                                                                        f8 x8)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple8
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple8 (x1,
                                x2,
                                x3,
                                x4,
                                x5,
                                x6,
                                x7,
                                x8)) f = Tuple8 (case f x1 of
                                                     Tuple8 (y, _, _, _, _, _, _, _) -> y,
                                                 case f x2 of
                                                     Tuple8 (_, y, _, _, _, _, _, _) -> y,
                                                 case f x3 of
                                                     Tuple8 (_, _, y, _, _, _, _, _) -> y,
                                                 case f x4 of
                                                     Tuple8 (_, _, _, y, _, _, _, _) -> y,
                                                 case f x5 of
                                                     Tuple8 (_, _, _, _, y, _, _, _) -> y,
                                                 case f x6 of
                                                     Tuple8 (_, _, _, _, _, y, _, _) -> y,
                                                 case f x7 of
                                                     Tuple8 (_, _, _, _, _, _, y, _) -> y,
                                                 case f x8 of
                                                     Tuple8 (_, _, _, _, _, _, _, y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple9
    where pure x = Tuple9 (x,
                                               x,
                                               x,
                                               x,
                                               x,
                                               x,
                                               x,
                                               x,
                                               x)
          {-# INLINE pure #-}
          (<*>) (Tuple9 (f1,
                                           f2,
                                           f3,
                                           f4,
                                           f5,
                                           f6,
                                           f7,
                                           f8,
                                           f9)) (Tuple9 (x1,
                                                         x2,
                                                         x3,
                                                         x4,
                                                         x5,
                                                         x6,
                                                         x7,
                                                         x8,
                                                         x9)) = Tuple9 (f1 x1,
                                                                        f2 x2,
                                                                        f3 x3,
                                                                        f4 x4,
                                                                        f5 x5,
                                                                        f6 x6,
                                                                        f7 x7,
                                                                        f8 x8,
                                                                        f9 x9)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple9
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple9 (x1,
                                x2,
                                x3,
                                x4,
                                x5,
                                x6,
                                x7,
                                x8,
                                x9)) f = Tuple9 (case f x1 of
                                                     Tuple9 (y, _, _, _, _, _, _, _, _) -> y,
                                                 case f x2 of
                                                     Tuple9 (_, y, _, _, _, _, _, _, _) -> y,
                                                 case f x3 of
                                                     Tuple9 (_, _, y, _, _, _, _, _, _) -> y,
                                                 case f x4 of
                                                     Tuple9 (_, _, _, y, _, _, _, _, _) -> y,
                                                 case f x5 of
                                                     Tuple9 (_, _, _, _, y, _, _, _, _) -> y,
                                                 case f x6 of
                                                     Tuple9 (_, _, _, _, _, y, _, _, _) -> y,
                                                 case f x7 of
                                                     Tuple9 (_, _, _, _, _, _, y, _, _) -> y,
                                                 case f x8 of
                                                     Tuple9 (_, _, _, _, _, _, _, y, _) -> y,
                                                 case f x9 of
                                                     Tuple9 (_, _, _, _, _, _, _, _, y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple10
    where pure x = Tuple10 (x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x)
          {-# INLINE pure #-}
          (<*>) (Tuple10 (f1,
                                            f2,
                                            f3,
                                            f4,
                                            f5,
                                            f6,
                                            f7,
                                            f8,
                                            f9,
                                            f10)) (Tuple10 (x1,
                                                            x2,
                                                            x3,
                                                            x4,
                                                            x5,
                                                            x6,
                                                            x7,
                                                            x8,
                                                            x9,
                                                            x10)) = Tuple10 (f1 x1,
                                                                             f2 x2,
                                                                             f3 x3,
                                                                             f4 x4,
                                                                             f5 x5,
                                                                             f6 x6,
                                                                             f7 x7,
                                                                             f8 x8,
                                                                             f9 x9,
                                                                             f10 x10)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple10
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple10 (x1,
                                 x2,
                                 x3,
                                 x4,
                                 x5,
                                 x6,
                                 x7,
                                 x8,
                                 x9,
                                 x10)) f = Tuple10 (case f x1 of
                                                        Tuple10 (y, _, _, _, _, _, _, _, _, _) -> y,
                                                    case f x2 of
                                                        Tuple10 (_, y, _, _, _, _, _, _, _, _) -> y,
                                                    case f x3 of
                                                        Tuple10 (_, _, y, _, _, _, _, _, _, _) -> y,
                                                    case f x4 of
                                                        Tuple10 (_, _, _, y, _, _, _, _, _, _) -> y,
                                                    case f x5 of
                                                        Tuple10 (_, _, _, _, y, _, _, _, _, _) -> y,
                                                    case f x6 of
                                                        Tuple10 (_, _, _, _, _, y, _, _, _, _) -> y,
                                                    case f x7 of
                                                        Tuple10 (_, _, _, _, _, _, y, _, _, _) -> y,
                                                    case f x8 of
                                                        Tuple10 (_, _, _, _, _, _, _, y, _, _) -> y,
                                                    case f x9 of
                                                        Tuple10 (_, _, _, _, _, _, _, _, y, _) -> y,
                                                    case f x10 of
                                                        Tuple10 (_, _, _, _, _, _, _, _, _, y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple11
    where pure x = Tuple11 (x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x)
          {-# INLINE pure #-}
          (<*>) (Tuple11 (f1,
                                            f2,
                                            f3,
                                            f4,
                                            f5,
                                            f6,
                                            f7,
                                            f8,
                                            f9,
                                            f10,
                                            f11)) (Tuple11 (x1,
                                                            x2,
                                                            x3,
                                                            x4,
                                                            x5,
                                                            x6,
                                                            x7,
                                                            x8,
                                                            x9,
                                                            x10,
                                                            x11)) = Tuple11 (f1 x1,
                                                                             f2 x2,
                                                                             f3 x3,
                                                                             f4 x4,
                                                                             f5 x5,
                                                                             f6 x6,
                                                                             f7 x7,
                                                                             f8 x8,
                                                                             f9 x9,
                                                                             f10 x10,
                                                                             f11 x11)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple11
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple11 (x1,
                                 x2,
                                 x3,
                                 x4,
                                 x5,
                                 x6,
                                 x7,
                                 x8,
                                 x9,
                                 x10,
                                 x11)) f = Tuple11 (case f x1 of
                                                        Tuple11 (y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x2 of
                                                        Tuple11 (_,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x3 of
                                                        Tuple11 (_,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x4 of
                                                        Tuple11 (_,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x5 of
                                                        Tuple11 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x6 of
                                                        Tuple11 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x7 of
                                                        Tuple11 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x8 of
                                                        Tuple11 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x9 of
                                                        Tuple11 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _) -> y,
                                                    case f x10 of
                                                        Tuple11 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _) -> y,
                                                    case f x11 of
                                                        Tuple11 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple12
    where pure x = Tuple12 (x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x)
          {-# INLINE pure #-}
          (<*>) (Tuple12 (f1,
                                            f2,
                                            f3,
                                            f4,
                                            f5,
                                            f6,
                                            f7,
                                            f8,
                                            f9,
                                            f10,
                                            f11,
                                            f12)) (Tuple12 (x1,
                                                            x2,
                                                            x3,
                                                            x4,
                                                            x5,
                                                            x6,
                                                            x7,
                                                            x8,
                                                            x9,
                                                            x10,
                                                            x11,
                                                            x12)) = Tuple12 (f1 x1,
                                                                             f2 x2,
                                                                             f3 x3,
                                                                             f4 x4,
                                                                             f5 x5,
                                                                             f6 x6,
                                                                             f7 x7,
                                                                             f8 x8,
                                                                             f9 x9,
                                                                             f10 x10,
                                                                             f11 x11,
                                                                             f12 x12)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple12
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple12 (x1,
                                 x2,
                                 x3,
                                 x4,
                                 x5,
                                 x6,
                                 x7,
                                 x8,
                                 x9,
                                 x10,
                                 x11,
                                 x12)) f = Tuple12 (case f x1 of
                                                        Tuple12 (y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x2 of
                                                        Tuple12 (_,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x3 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x4 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x5 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x6 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x7 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x8 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x9 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x10 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _) -> y,
                                                    case f x11 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _) -> y,
                                                    case f x12 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple13
    where pure x = Tuple13 (x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x)
          {-# INLINE pure #-}
          (<*>) (Tuple13 (f1,
                                            f2,
                                            f3,
                                            f4,
                                            f5,
                                            f6,
                                            f7,
                                            f8,
                                            f9,
                                            f10,
                                            f11,
                                            f12,
                                            f13)) (Tuple13 (x1,
                                                            x2,
                                                            x3,
                                                            x4,
                                                            x5,
                                                            x6,
                                                            x7,
                                                            x8,
                                                            x9,
                                                            x10,
                                                            x11,
                                                            x12,
                                                            x13)) = Tuple13 (f1 x1,
                                                                             f2 x2,
                                                                             f3 x3,
                                                                             f4 x4,
                                                                             f5 x5,
                                                                             f6 x6,
                                                                             f7 x7,
                                                                             f8 x8,
                                                                             f9 x9,
                                                                             f10 x10,
                                                                             f11 x11,
                                                                             f12 x12,
                                                                             f13 x13)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple13
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple13 (x1,
                                 x2,
                                 x3,
                                 x4,
                                 x5,
                                 x6,
                                 x7,
                                 x8,
                                 x9,
                                 x10,
                                 x11,
                                 x12,
                                 x13)) f = Tuple13 (case f x1 of
                                                        Tuple13 (y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x2 of
                                                        Tuple13 (_,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x3 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x4 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x5 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x6 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x7 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x8 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x9 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x10 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x11 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _) -> y,
                                                    case f x12 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _) -> y,
                                                    case f x13 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple14
    where pure x = Tuple14 (x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x)
          {-# INLINE pure #-}
          (<*>) (Tuple14 (f1,
                                            f2,
                                            f3,
                                            f4,
                                            f5,
                                            f6,
                                            f7,
                                            f8,
                                            f9,
                                            f10,
                                            f11,
                                            f12,
                                            f13,
                                            f14)) (Tuple14 (x1,
                                                            x2,
                                                            x3,
                                                            x4,
                                                            x5,
                                                            x6,
                                                            x7,
                                                            x8,
                                                            x9,
                                                            x10,
                                                            x11,
                                                            x12,
                                                            x13,
                                                            x14)) = Tuple14 (f1 x1,
                                                                             f2 x2,
                                                                             f3 x3,
                                                                             f4 x4,
                                                                             f5 x5,
                                                                             f6 x6,
                                                                             f7 x7,
                                                                             f8 x8,
                                                                             f9 x9,
                                                                             f10 x10,
                                                                             f11 x11,
                                                                             f12 x12,
                                                                             f13 x13,
                                                                             f14 x14)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple14
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple14 (x1,
                                 x2,
                                 x3,
                                 x4,
                                 x5,
                                 x6,
                                 x7,
                                 x8,
                                 x9,
                                 x10,
                                 x11,
                                 x12,
                                 x13,
                                 x14)) f = Tuple14 (case f x1 of
                                                        Tuple14 (y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x2 of
                                                        Tuple14 (_,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x3 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x4 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x5 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x6 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x7 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x8 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x9 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x10 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x11 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x12 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _) -> y,
                                                    case f x13 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _) -> y,
                                                    case f x14 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple15
    where pure x = Tuple15 (x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x)
          {-# INLINE pure #-}
          (<*>) (Tuple15 (f1,
                                            f2,
                                            f3,
                                            f4,
                                            f5,
                                            f6,
                                            f7,
                                            f8,
                                            f9,
                                            f10,
                                            f11,
                                            f12,
                                            f13,
                                            f14,
                                            f15)) (Tuple15 (x1,
                                                            x2,
                                                            x3,
                                                            x4,
                                                            x5,
                                                            x6,
                                                            x7,
                                                            x8,
                                                            x9,
                                                            x10,
                                                            x11,
                                                            x12,
                                                            x13,
                                                            x14,
                                                            x15)) = Tuple15 (f1 x1,
                                                                             f2 x2,
                                                                             f3 x3,
                                                                             f4 x4,
                                                                             f5 x5,
                                                                             f6 x6,
                                                                             f7 x7,
                                                                             f8 x8,
                                                                             f9 x9,
                                                                             f10 x10,
                                                                             f11 x11,
                                                                             f12 x12,
                                                                             f13 x13,
                                                                             f14 x14,
                                                                             f15 x15)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple15
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple15 (x1,
                                 x2,
                                 x3,
                                 x4,
                                 x5,
                                 x6,
                                 x7,
                                 x8,
                                 x9,
                                 x10,
                                 x11,
                                 x12,
                                 x13,
                                 x14,
                                 x15)) f = Tuple15 (case f x1 of
                                                        Tuple15 (y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x2 of
                                                        Tuple15 (_,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x3 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x4 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x5 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x6 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x7 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x8 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x9 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x10 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x11 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x12 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x13 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _) -> y,
                                                    case f x14 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _) -> y,
                                                    case f x15 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/PermuteEffects-0.2/Control/Permute.hs
Applicative instance: 


-- | 'pure' represents the empty list of computations while '<*>' acts like
-- '++'.
instance Applicative (Effects f) where
  pure             = Nil
  Nil g <*> y      = fmap g y
  Cons a r x <*> y = Cons a r (flip <$> x <*> y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghc-parmake-0.1.9/src/Distribution/Compat/ReadP.hs
Applicative instance: 


instance Applicative (P s) where
  pure x = Result x Fail
  (<*>) = ap
Monad instance: 


instance Monad (P s) where
  return = AP.pure

  (Get f)      >>= k = Get (f >=> k)
  (Look f)     >>= k = Look (f >=> k)
  Fail         >>= _ = Fail
  (Result x p) >>= k = k x `mplus` (p >>= k)
  (Final r)    >>= k = final [ys' | (x,s) <- r, ys' <- run (k x) s]

  fail _ = Fail
Applicative instance: 


instance Applicative (Parser r s) where
  pure x  = R (\k -> k x)
  (<*>) = ap
Monad instance: 


instance Monad (Parser r s) where
  return = AP.pure
  fail _    = R (const Fail)
  R m >>= f = R (\k -> m (\a -> let R m' = f a in m' k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/feldspar-language-0.7/src/Feldspar/Option.hs
Applicative instance: 


instance Applicative Option
  where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad Option
  where
    return = some
    a >>= f = b { isSome = isSome a ? isSome b $ false }
      where
        b = f (fromSome a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fortran-src-0.1.0.3/src/Language/Fortran/ParserMonad.hs
Monad instance: 


instance (Loc b, LastToken b c, Show c) => Monad (Parse b c) where
  return a = Parse $ \s -> ParseOk a s

  (Parse m) >>= f = Parse $ \s ->
    case m s of
      ParseOk a s' -> unParse (f a) s'
      ParseFailed e -> ParseFailed e

  fail msg = Parse $ \s -> ParseFailed ParseError
    { errPos        = (getPos . psAlexInput) s
    , errLastToken  = (getLastToken . psAlexInput) s
    , errFilename   = psFilename s
    , errMsg        = msg }
Applicative instance: 


instance (Loc b, LastToken b c, Show c) => Applicative (Parse b c) where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrowp-0.5.0.2/preprocessor/State.hs
Monad instance: 


instance Monad (State s) where
        return x = State (\n -> (x, n))
        State v >>= f = State (\n -> let (x, n') = v n in runState (f x) n')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/skulk-0.1.3.0/src/Skulk/Deep.hs
Applicative instance: 


#if __GLASGOW_HASKELL__ < 710
instance (Applicative a, Monad a, Applicative b) => Applicative (Deep a b) where
#else
instance (Monad a, Applicative b) => Applicative (Deep a b) where
#endif
    pure = Deep . pure . pure
    (Deep abf) <*> (Deep abx) = Deep $ do
        bf <- abf
        bx <- abx
        let by = bf <*> bx
        return by
Monad instance: 


#if __GLASGOW_HASKELL__ < 710
instance (Applicative a, Monad a, Monad b, Traversable b) => Monad (Deep a b) where
#else
instance (Monad a, Monad b, Traversable b) => Monad (Deep a b) where
#endif
    return = Deep . return . return
    fail = Deep . return . fail
    (Deep abx) >>= f = Deep $ do
        bx <- abx
        let baby = expose . f <$> bx
        let abby = sequenceA baby
        let aby = join <$> abby
        aby
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/skulk-0.1.3.0/src/Skulk/Outcome.hs
Applicative instance: 


instance Applicative Outcome where
    pure = OK
    (OK f) <*> ax = f <$> ax
    (Fail msg) <*> _ = Fail msg
    (Skip msg) <*> _ = Skip msg
Monad instance: 


instance Monad Outcome where
    OK x >>= f = f x
    Fail msg >>= _ = Fail msg
    Skip msg >>= _ = Skip msg
    return = OK
    fail = Fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/async-pool-0.9.0/Control/Concurrent/Async/Pool/Internal.hs
Applicative instance: 


instance Applicative Task where
    pure x = Task $ \_ -> return (return x)
    Task f <*> Task x = Task $ \tg -> do
        xa <- x tg
        x' <- wait <$> async tg xa
        fa <- f tg
        return $ fa <*> x'
Monad instance: 


instance Monad Task where
    return = pure
    Task m >>= f = Task $ \tg -> join (m tg) >>= flip runTask' tg . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/async-pool-0.9.0/Control/Concurrent/Async/Pool/Async.hs
Applicative instance: 


instance Applicative Concurrently where
  pure x = Concurrently $ \_ -> return x
  Concurrently fs <*> Concurrently as =
    Concurrently $ \tg -> (\(f, a) -> f a) <$> concurrently tg (fs tg) (as tg)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/termination-combinators-0.1/Control/Termination.hs
Applicative instance: 


instance Applicative (Gather a) where
    pure _ = Gather id
    Gather xs <*> Gather ys = Gather (xs . ys)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/parsergen-0.2.0.7/src/ParserGen/Parser.hs
Monad instance: 


instance Monad Parser where
    return a = Parser $ \s -> (# OK a, s #)
    {-# INLINE return #-}

    m >>= k   = Parser $ \s -> case runParser m s of
                                 (# OK a, s' #) -> runParser (k a) s'
                                 (# Fail err, s' #) -> (# Fail err, s' #)
    {-# INLINE (>>=) #-}

    fail msg = Parser $ \s -> (# Fail msg, s #)
Applicative instance: 


instance Applicative Parser where
    pure   = return
    {-# INLINE pure #-}
    (<*>)  = ap
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hfusion-0.0.6.1/HFusion/Internal/Compositions.hs
Monad instance: 


instance Monad (TreeT b m) where
  return a = C ($ a)
  C f >>= fc = C$ \k -> f (\a -> runC (fc a) k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bindings-bfd-1.2.0.0/dist/build/Bindings/Bfd/Disasm/I386/Parse.hs
Monad instance: 


instance Monad HappyIdentity where
    return = HappyIdentity
    (HappyIdentity p) >>= q = q p
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pipes-transduce-0.4/src/Pipes/Transduce.hs
Applicative instance: 


{-| 
    'pure' creates a 'Fold1' that does nothing besides draining the
    'Producer'. 

    '<*>' feeds both folds with the data of the same 'Producer'. If any of
    them fails the combination fails.
-}
instance Applicative (Fold1 b e) where
    pure a = Fold1 (pure a)
    Fold1 fa <*> Fold1 a = Fold1 (fa <*> a)
Applicative instance: 


instance Applicative (Fold1_ b e) where
    pure a = ExhaustiveCont (\producer -> do
        r <- runEffect (producer >-> Pipes.drain)
        pure (Right (a,r)))

    TrueFold f1 <*> TrueFold f2 = TrueFold (f1 <*> f2)
    s1 <*> s2 = bifurcate (nonexhaustiveCont s1) (nonexhaustiveCont s2)
        where
        bifurcate fs as = ExhaustiveCont (\producer -> do
            (outbox1,inbox1,seal1) <- spawn' (bounded 1)
            (outbox2,inbox2,seal2) <- spawn' (bounded 1)
            runConceit $
                (\f x r -> (f x,r))
                <$>
                Conceit (fs (fromInput inbox1) `finally` atomically seal1)
                <*>
                Conceit (as (fromInput inbox2) `finally` atomically seal2)
                <*>
                (_Conceit $
                    (runEffect (producer >-> Pipes.tee (toOutput outbox1 *> Pipes.drain)
                                         >->           (toOutput outbox2 *> Pipes.drain)))
                    `finally` atomically seal1
                    `finally` atomically seal2))
Applicative instance: 


instance Applicative (Fold2 b1 b2 e) where
    pure a = Fold2 (pure a)
    Fold2 fa <*> Fold2 a = Fold2 (fa <*> a)
Applicative instance: 


instance Applicative (Fold2_ b1 b2 e) where
    pure a = fmap (const a) (separated_ (pure ()) (pure ()))

    Both fs <*> Both as = Both (\producer1 producer2 -> do
        (outbox1a,inbox1a,seal1a) <- spawn' (bounded 1)
        (outbox2a,inbox2a,seal2a) <- spawn' (bounded 1)
        (outbox1b,inbox1b,seal1b) <- spawn' (bounded 1)
        (outbox2b,inbox2b,seal2b) <- spawn' (bounded 1)
        runConceit $
            (\(f,(),()) (x,(),()) r1 r2 -> (f x,r1,r2))
            <$>
            Conceit (fs (fromInput inbox1a) (fromInput inbox1b) `finally` atomically seal1a `finally` atomically seal1b)
            <*>
            Conceit (as (fromInput inbox2a) (fromInput inbox2b) `finally` atomically seal2a `finally` atomically seal2b)
            <*>
            (_Conceit $
                (runEffect (producer1 >-> Pipes.tee (toOutput outbox1a *> Pipes.drain)
                                      >->           (toOutput outbox2a *> Pipes.drain)))
                `finally` atomically seal1a
                `finally` atomically seal2a)
            <*>
            (_Conceit $
                (runEffect (producer2 >-> Pipes.tee (toOutput outbox1b *> Pipes.drain)
                                      >->           (toOutput outbox2b *> Pipes.drain)))
                `finally` atomically seal1b
                `finally` atomically seal2b))
    First fs <*> First as = First (fs <*> as)
    Second fs <*> Second as = Second (fs <*> as)
    First fs <*> Second as = uncurry ($) <$> separated_ fs as
    Second fs <*> First as = uncurry (flip ($)) <$> separated_ as fs
    First fs <*> Both as =  (\(f,()) x -> f x) <$> separated_ fs (pure ()) <*> Both as
    Both fs <*> First as =  (\f (x,()) -> f x) <$> Both fs <*> separated_ as (pure ())
    Second fs <*> Both as = (\((),f) x -> f x) <$> separated_ (pure ()) fs <*> Both as
    Both fs <*> Second as = (\f ((),x) -> f x) <$> Both fs <*> separated_ (pure ()) as
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/yesod-form-1.4.7.1/Yesod/Form/Input.hs
Applicative instance: 

instance Monad m => Applicative (FormInput m) where
    pure = FormInput . const . const . const . const . return . Right
    (FormInput f) <*> (FormInput x) = FormInput $ \c d e e' -> do
        res1 <- f c d e e'
        res2 <- x c d e e'
        return $ case (res1, res2) of
            (Left a, Left b) -> Left $ a . b
            (Left a, _) -> Left a
            (_, Left b) -> Left b
            (Right a, Right b) -> Right $ a b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/yesod-form-1.4.7.1/Yesod/Form/Types.hs
Applicative instance: 

instance Applicative FormResult where
    pure = FormSuccess
    (FormSuccess f) <*> (FormSuccess g) = FormSuccess $ f g
    (FormFailure x) <*> (FormFailure y) = FormFailure $ x ++ y
    (FormFailure x) <*> _ = FormFailure x
    _ <*> (FormFailure y) = FormFailure y
    _ <*> _ = FormMissing
Applicative instance: 

instance Monad m => Applicative (AForm m) where
    pure x = AForm $ const $ const $ \ints -> return (FormSuccess x, id, ints, mempty)
    (AForm f) <*> (AForm g) = AForm $ \mr env ints -> do
        (a, b, ints', c) <- f mr env ints
        (x, y, ints'', z) <- g mr env ints'
        return (a <*> x, b . y, ints'', c `mappend` z)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pugs-DrIFT-2.2.3.20150815/src/ParseLib2.hs
Monad instance: 


instance Monad Parser where
   -- return      :: a -> Parser a
   return v        = P (\pos inp -> [(v,inp)])

   -- >>=         :: Parser a -> (a -> Parser b) -> Parser b
   (P p) >>= f     = P (\pos inp -> concat [papply (f v) pos out
                                                | (v,out) <- p pos inp])
   fail s          = P (\pos inp -> [])
Applicative instance: 


instance AP.Applicative Parser where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/adjunctions-4.3/src/Control/Comonad/Representable/Store.hs
Applicative instance: 


instance (Applicative w, Monoid (Rep g), Representable g) => Applicative (StoreT g w) where
  pure a = StoreT (pure (pureRep a)) mempty
  StoreT ff m <*> StoreT fa n = StoreT (apRep <$> ff <*> fa) (m `mappend` n)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/adjunctions-4.3/src/Control/Monad/Trans/Contravariant/Adjoint.hs
Applicative instance: 


instance (Adjunction f g, Comonad w) => Applicative (AdjointT f g w) where
  pure = AdjointT . leftAdjunct extract
  (<*>) = ap
Monad instance: 


instance (Adjunction f g, Comonad w) => Monad (AdjointT f g w) where
  return = pure
  AdjointT m >>= f = AdjointT $ contramap (extend (rightAdjunct (runAdjointT . f))) m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/adjunctions-4.3/src/Control/Monad/Trans/Conts.hs
Applicative instance: 


instance Comonad w => Applicative (ContsT r w m) where
  pure x = ContsT $ \f -> extract f x
  (<*>) = ap
Monad instance: 


instance Comonad w => Monad (ContsT r w m) where
  return = pure
  ContsT k >>= f = ContsT $ k . extend (\wa a -> runContsT (f a) wa)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/adjunctions-4.3/src/Control/Monad/Trans/Adjoint.hs
Applicative instance: 


instance (Adjunction f g, Monad m) => Applicative (AdjointT f g m) where
  pure = AdjointT . leftAdjunct return
  (<*>) = ap
Monad instance: 


instance (Adjunction f g, Monad m) => Monad (AdjointT f g m) where
  return = pure
  AdjointT m >>= f = AdjointT $ fmap (>>= rightAdjunct (runAdjointT . f)) m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/adjunctions-4.3/src/Control/Monad/Representable/Reader.hs
Applicative instance: 


instance (Representable f, Applicative m) => Applicative (ReaderT f m) where
  pure = ReaderT . pureRep . pure
  ReaderT ff <*> ReaderT fa = ReaderT (unCo ((<*>) <$> Co ff <*> Co fa))
Monad instance: 


instance (Representable f, Monad m) => Monad (ReaderT f m) where
#if __GLASGOW_HASKELL__ < 710
  return = ReaderT . pureRep . return
#endif
  ReaderT fm >>= f = ReaderT $ tabulate (\a -> index fm a >>= flip index a . getReaderT . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HCodecs-0.5/src/Codec/ByteString/Parser.hs
Monad instance: 


instance Monad Parser where
    return a  = Parser (\s -> Right (a, s))
    m >>= k   = Parser $ \s -> case (unParser m) s of
      Left e -> Left e
      Right (a, s') -> (unParser (k a)) s'
    fail  err  = Parser $ \(S _ _ bytes) ->
        Left (err ++ ". Failed reading at byte position " ++ show bytes)
Applicative instance: 


instance Applicative Parser where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cao-0.1.1/src/Language/CAO/Common/Monad.hs
Monad instance: 


instance Monad CaoResult  where
    return !x = CaoResult $! \ st -> return (Right (x, mempty), st)
    (>>=)     = bindTcMonad
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Top-1.7/src/Top/Monad/StateFix.hs
Monad instance: 


instance Monad m => Monad (StateFixT s m) where
   return  = Fix . return
   m >>= f = Fix (unFix m >>= unFix . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Top-1.7/src/Top/Monad/Select.hs
Monad instance: 


instance Monad m => Monad (Select t m) where
   return a       = Select (return a)
   Select f >>= g = Select (do x <- f
                               let Select h = g x
                               h)
Monad instance: 


instance Monad m => Monad (SelectFix t m) where
   return a          = SelectFix (return a)
   SelectFix f >>= g = SelectFix (do x <- f
                                     let SelectFix h = g x
                                     h)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/language-c-quote-0.9.0/Language/C/Parser/Monad.hs
Applicative instance: 


instance Applicative P where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad P where
    m >>= k = P $ \s ->
        case runP m s of
          Left e         -> Left e
          Right (a, s')  -> runP (k a) s'

    m1 >> m2 = P $ \s ->
        case runP m1 s of
          Left e         -> Left e
          Right (_, s')  -> runP m2 s'

    return a = P $ \s -> Right (a, s)

    fail msg = do
        inp <- getInput
        throw $ ParserException (Loc (alexPos inp) (alexPos inp))
                                (ppr (alexPos inp) <> colon <+> text msg)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pipes-core-0.1.0/Control/Pipe/Common.hs
Monad instance: 


instance Monad m => Monad (Pipe a b m) where
  return r = Pure r []
  Pure r w >>= f = case f r of
    Pure r' w' -> Pure r' (w ++ w')
    Throw e w' -> Throw e (w ++ w')
    p'         -> foldr run p' w
      where
        run m p = M Masked (m >> return p) throwP
  Throw e w >>= _ = Throw e w
  Await k h >>= f = Await (k >=> f) (h >=> f)
  M s m h >>= f = M s (m >>= \p -> return $ p >>= f) (h >=> f)
  Yield x p w >>= f = Yield x (p >>= f) w
Applicative instance: 


instance Monad m => Applicative (Pipe a b m) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/typed-spreadsheet-1.1.0/src/Typed/Spreadsheet.hs
Applicative instance: 


instance Applicative Cell where
    pure a = Cell (pure (empty, pure a))

    Cell mF <*> Cell mX = Cell (liftA2 helper mF mX)
      where
        helper (inputF, foldF) (inputX, foldX) = (input, fold )
          where
            input = fmap Left inputF <|> fmap Right inputX

            fold = Fold.handles _Left foldF <*> Fold.handles _Right foldX
Applicative instance: 


instance Applicative Updatable where
    pure a = Updatable (pure (pure a))

    Updatable mf <*> Updatable mx = Updatable (liftA2 (<*>) mf mx)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ruin-0.1.0.1/Data/Ruin/Eval.hs
Applicative instance: 


instance Applicative Eval where
  {-# INLINE pure #-}
  pure = Done
  {-# INLINE (<*>) #-}
  Done f <*> Done a = Done (f a)
Monad instance: 


instance Monad Eval where
  {-# INLINE return #-}
  return = Done
  {-# INLINE (>>=) #-}
  Done a >>= k = k a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-task-0.1.0/Control/Monad/Trans/Task.hs
Monad instance: 


instance Monad m => Monad (TaskT e m) where
  return = TaskT . return
  (>>=) m f = TaskT $ runTaskT m >>= runTaskT . f
  fail _ = TaskT $ ContT $ \_ -> return EXIT
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unm-hip-0.3.1.6/Data/Image/Boxed.hs
Applicative instance: 


instance Applicative BoxedImage where
  pure a = Image 1 1 (V.fromList [a])
  (<*>) (Image rows cols partial) (Image rows' cols' toApply)
    | rows /= rows' && cols /= cols' = error "Cannot apply images of unequal dimensions."
    | otherwise = Image rows cols (V.fromList applied) where
       indices = [ r*cols + c | r <- [0..rows-1], c <- [0..cols-1]]
       applied = map func indices
       func i = (partial V.! i) (toApply V.! i)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/twilio-0.1.3.1/src/Control/Monad/Twilio.hs
Applicative instance: 


instance Applicative m => Applicative (TwilioT m) where
  pure = liftTwilioT . pure
  f <*> v = TwilioT $ \r -> getTwilioT f r <*> getTwilioT v r
Monad instance: 


{-
instance Alternative m => Alternative (TwilioT m) where
  empty = liftTwilioT empty
  m <|> n = TwilioT $ \r -> getTwilioT m r <|> getTwilioT n r
-}

instance Monad m => Monad (TwilioT m) where
  return a = TwilioT (return . const a)
  m >>= k = TwilioT $ \client -> do
    a <- getTwilioT m client
    getTwilioT (k a) client
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liquidhaskell-0.6.0.0/tests/pos/ToyMVar.hs
Monad instance: 


instance Monad IO where --  GHC-Base.lhs
  return = undefined
  _ >> _ = undefined
Applicative instance: 


instance Applicative IO where
  pure  = undefined
  (<*>) = undefined
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liquidhaskell-0.6.0.0/tests/pos/CountMonad.hs
Applicative instance: 

instance Applicative Count where
  pure  = undefined
  (<*>) = undefined
Monad instance: 


instance Monad Count where
{-@
instance Monad Count where 
  >>=    :: forall <r :: Count a -> Prop, p :: Count b -> Prop, q :: Count b -> Prop>.
            {x::Count a <<r>>, y :: Count b <<p>>  |- {v:Count b | count v == count x + count y} <: Count b <<q>>} 
            Count a <<r>> -> (a -> Count b<<p>>) -> Count b <<q>> ; 
  >>     :: x:Count a -> y:Count b -> {v:Count b | count v == count x + count y}; 
  return :: a -> {v:Count a | count v == 0 } 
@-}
  return x        = let r = Count x in assertCount 0 (Count x)
  (Count x) >>= f = let r = f x in assertCount (getCount (Count x) + getCount r) r
  x >> y = assertCount (getCount x + getCount y) y
  fail          = error
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liquidhaskell-0.6.0.0/tests/pos/StateConstraints0.hs
Monad instance: 



instance Monad (ST s) where
  {-@ instance Monad ST s where
    return :: forall s a <p :: s -> Prop >. x:a -> ST <p, {\s v -> v == s}, {\s v -> x == v}> s a;
    >>= :: forall s a b  < pref :: s -> Prop, postf :: s -> s -> Prop
              , pre  :: s -> Prop, postg :: s -> s -> Prop
              , post :: s -> s -> Prop
              , rg   :: s -> a -> Prop
              , rf   :: s -> b -> Prop
              , r    :: s -> b -> Prop
              , pref0 :: a -> Prop 
              >. 
       {x::s<pre> |- a<rg x> <: a<pref0>}      
       {x::s<pre>, y::s<postg x> |- b<rf y> <: b<r x>}
       {xx::s<pre>, w::s<postg xx> |- s<postf w> <: s<post xx>}
       {ww::s<pre> |- s<postg ww> <: s<pref>}
       (ST <pre, postg, rg> s a)
    -> (a<pref0> -> ST <pref, postf, rf> s b)
    -> (ST <pre, post, r> s b) ;
    >>  :: forall s a b  < pref :: s -> Prop, postf :: s -> s -> Prop
              , pre  :: s -> Prop, postg :: s -> s -> Prop
              , post :: s -> s -> Prop
              , rg   :: s -> a -> Prop
              , rf   :: s -> b -> Prop
              , r    :: s -> b -> Prop
              >. 
       {x::s<pre>, y::s<postg x> |- b<rf y> <: b<r x>}
       {xx::s<pre>, w::s<postg xx> |- s<postf w> <: s<post xx>}
       {ww::s<pre> |- s<postg ww> <: s<pref>}
       (ST <pre, postg, rg> s a)
    -> (ST <pref, postf, rf> s b)
    -> (ST <pre, post, r> s b)
    @-}
  return x     = ST $ \s -> (x, s)
  (ST g) >>= f = ST (\x -> case g x of {(y, s) -> (runState (f y)) s})
  (ST g) >>  f = ST (\x -> case g x of {(y, s) -> (runState f) s})
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liquidhaskell-0.6.0.0/tests/neg/StateConstraints0.hs
Monad instance: 


instance Monad (ST s) where
  {-@ instance Monad ST s where
    return :: forall s a <p :: s -> Prop >. x:a -> ST <p, {\s v -> v == s}, {\s v -> x == v}> s a;
    >>= :: forall s a b  < pref :: s -> Prop, postf :: s -> s -> Prop
              , pre  :: s -> Prop, postg :: s -> s -> Prop
              , post :: s -> s -> Prop
              , rg   :: s -> a -> Prop
              , rf   :: s -> b -> Prop
              , r    :: s -> b -> Prop
              , pref0 :: a -> Prop 
              >. 
       {x::s<pre> |- a<rg x> <: a<pref0>}      
       {x::s<pre>, y::s<postg x> |- b<rf y> <: b<r x>}
       {xx::s<pre>, w::s<postg xx> |- s<postf w> <: s<post xx>}
       {ww::s<pre> |- s<postg ww> <: s<pref>}
       (ST <pre, postg, rg> s a)
    -> (a<pref0> -> ST <pref, postf, rf> s b)
    -> (ST <pre, post, r> s b) ;
    >>  :: forall s a b  < pref :: s -> Prop, postf :: s -> s -> Prop
              , pre  :: s -> Prop, postg :: s -> s -> Prop
              , post :: s -> s -> Prop
              , rg   :: s -> a -> Prop
              , rf   :: s -> b -> Prop
              , r    :: s -> b -> Prop
              >. 
       {x::s<pre>, y::s<postg x> |- b<rf y> <: b<r x>}
       {xx::s<pre>, w::s<postg xx> |- s<postf w> <: s<post xx>}
       {ww::s<pre> |- s<postg ww> <: s<pref>}
       (ST <pre, postg, rg> s a)
    -> (ST <pref, postf, rf> s b)
    -> (ST <pre, post, r> s b)

    @-}
  return x     = ST $ \s -> (x, s)
  (ST g) >>= f = ST (\x -> case g x of {(y, s) -> (runState (f y)) s})
  (ST g) >>  f = ST (\x -> case g x of {(y, s) -> (runState f) s})
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liquidhaskell-0.6.0.0/src/Language/Haskell/Liquid/Transforms/CoreToLogic.hs
Monad instance: 



instance Monad LogicM where
  return = LM . const . Left
  (LM m) >>= f
    = LM $ \s -> case m s of
                (Left x) -> (runM (f x)) s
                (Right x) -> Right x
Applicative instance: 


instance Applicative LogicM where
  pure = LM . const . Left
  (LM f) <*> (LM m)
    = LM $ \s -> case (f s, m s) of
                  (Left f , Left x ) -> Left $ f x
                  (Right f, Left _ ) -> Right f
                  (Left _ , Right x) -> Right x
                  (Right _, Right x) -> Right x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liquidhaskell-0.6.0.0/src/Language/Haskell/Liquid/Desugar710/Coverage.hs
Applicative instance: 


instance Applicative TM where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad TM where
  return a = TM $ \ _env st -> (a,noFVs,st)
  (TM m) >>= k = TM $ \ env st ->
                                case m env st of
                                  (r1,fv1,st1) ->
                                     case unTM (k r1) env st1 of
                                       (r2,fv2,st2) ->
                                          (r2, fv1 `plusOccEnv` fv2, st2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/clash-ghc-0.6.9/src-bin/GhciMonad.hs
Applicative instance: 


instance Applicative GHCi where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad GHCi where
  (GHCi m) >>= k  =  GHCi $ \s -> m s >>= \a -> unGHCi (k a) s
  return a  = GHCi $ \_ -> return a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rose-trees-0.0.4.3/src/Data/Tree/Knuth/Forest.hs
Applicative instance: 


-- | Zippy
instance Applicative KnuthForest where
  pure x = Fork x Nil Nil
  Nil <*> _ = Nil
  _ <*> Nil = Nil
  (Fork f fc fs) <*> (Fork x xc xs) =
    Fork (f x) (fc <*> xc) (fs <*> xs)
Monad instance: 


-- | Breadth-first
instance Monad KnuthForest where
  return = pure
  Nil            >>= _ = Nil
  (Fork x xc xs) >>= f = f x `union` (xs >>= f) `union` (xc >>= f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rose-trees-0.0.4.3/src/Data/Tree/Knuth.hs
Applicative instance: 



instance Applicative KnuthTree where
  pure x = KnuthTree (x,KF.Nil)
  (KnuthTree (f,fs)) <*> (KnuthTree (x,xs)) = KnuthTree (f x,fs <*> xs)
Monad instance: 


instance Monad KnuthTree where
  return x = KnuthTree (x,KF.Nil)
  (KnuthTree (x,xs)) >>= f =
    let (KnuthTree (y,_)) = f x
    in KnuthTree (y,xs >>= (snd . unKnuthTree . f))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hakyll-4.8.3.2/src/Hakyll/Core/Compiler/Internal.hs
Monad instance: 



--------------------------------------------------------------------------------
instance Monad Compiler where
    return x = Compiler $ \_ -> return $ CompilerDone x mempty
    {-# INLINE return #-}

    Compiler c >>= f = Compiler $ \r -> do
        res <- c r
        case res of
            CompilerDone x w    -> do
                res' <- unCompiler (f x) r
                return $ case res' of
                    CompilerDone y w'     -> CompilerDone y (w `mappend` w')
                    CompilerSnapshot s c' -> CompilerSnapshot s $ do
                        compilerTell w  -- Save dependencies!
                        c'
                    CompilerError e       -> CompilerError e
                    CompilerRequire i c'  -> CompilerRequire i $ do
                        compilerTell w  -- Save dependencies!
                        c'

            CompilerSnapshot s c' -> return $ CompilerSnapshot s (c' >>= f)
            CompilerError e       -> return $ CompilerError e
            CompilerRequire i c'  -> return $ CompilerRequire i (c' >>= f)
    {-# INLINE (>>=) #-}

    fail = compilerThrow . return
    {-# INLINE fail #-}
Applicative instance: 



--------------------------------------------------------------------------------
instance Applicative Compiler where
    pure x = return x
    {-# INLINE pure #-}

    f <*> x = f >>= \f' -> fmap f' x
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/transactional-events-0.1.0.0/Control/Concurrent/CHS.hs
Monad instance: 
 -- blocks until var is written

instance Monad CHS where
    return = CHS . return
    fail _ = CHS (prompt Fail)
    m >>= f = CHS $ runCHS m >>= runCHS . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/djinn-2014.9.7/src/LJT.hs
Applicative instance: 


instance Applicative P where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad P where
    return x = P $ \ s -> [(s, x)]
    P m >>= f = P $ \ s ->
        [ y | (s',x) <- m s, y <- unP (f x) s' ]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/list-tries-0.6.3/Data/ListTrie/Base/Classes.hs
Applicative instance: 


instance Applicative Identity where
   pure = Id
   Id f <*> Id a = Id (f a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Coadjute-0.1.1/Coadjute/Rule.hs
Monad instance: 


instance Monad Coadjute where
   return        = Co . return
   (Co rs) >>= f = Co (rs >>= unCo.f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/smartcheck-0.2.2/src/Test/SmartCheck/Types.hs
Monad instance: 


instance Monad Result where
  return a            = Result a
  BaseType      >>= _ = BaseType
  FailedPreCond >>= _ = FailedPreCond
  FailedProp    >>= _ = FailedProp
  Result a      >>= f = f a
Applicative instance: 


instance Applicative Result where
 pure  = return
 (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/demarcate-0.1.0/src/Control/Monad/Trans/Demarcate/Internal.hs
Monad instance: 


instance Monad (Demarcate t m) where
    return  = Demarcate . return
    m >>= f = Demarcate $ unDemarcate m >>= unDemarcate . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/action-permutations-0.0.0.1/Control/Applicative/Permutation.hs
Applicative instance: 


-- These instances actually only need Applicative p, but we specify
-- Alternative for uniformity and to preserve the abstraction.

instance Alternative p => Applicative (Perms p) where
    pure v = Choice (Just v) []
    t1@(Choice d1 bs1) <*> t2@(Choice d2 bs2) =
        Choice (d1 <*> d2) (map ins2 bs1 ++ map ins1 bs2)
          where
            ins1 (Branch perm p) = Branch ((.) <$> t1 <*> perm) p
            ins2 (Branch perm p) = Branch (flip <$> perm <*> t2) p
Applicative instance: 


instance Alternative p => Applicative (Branch p) where
    pure v = branch (pure v)
    Branch perm1 p1 <*> Branch perm2 p2 =
        Branch (lift_id <$> perm1 <*> perm2) ((,) <$> p1 <*> p2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/maude-0.6.1/src/Language/Maude/Exec/XML.hs
Monad instance: 


instance Monad Parser where
    return = Ok
    ParseError e s >>= _ = ParseError e s
    Ok r >>= k = k r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aeson-applicative-0.1.0.0/Data/Aeson/JsonInfo.hs
Applicative instance: 


instance Applicative (JsonFieldInfo t) where
  pure = Pure
  (<*>) = App
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/parsimony-1.3/src/Parsimony/Prim.hs
Monad instance: 


instance Monad (Parser t) where
  return a  = pure a
  p >>= f   = P $ \s ->
    case unP p s of
      R True r  -> R True $ case r of
                              Error e -> Error e
                              Ok a s1 ->
                                case unP (f a) s1 of
                                  R _ r1 -> r1
      R False r -> case r of
                     Error e  -> R False $ Error e
                     Ok a s1  -> unP (f a) s1

  fail m  = parseError (newErrorMessage (Message m))
Applicative instance: 


instance Applicative (Parser t) where
  pure a  = P $ \s -> R False $ Ok a s
  (<*>)   = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/csound-expression-dynamic-0.1.6/src/Csound/Dynamic/Types/Dep.hs
Applicative instance: 


instance Monad m => Applicative (DepT m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad m => Monad (DepT m) where
    return = DepT . return
    ma >>= mf = DepT $ unDepT ma >>= unDepT . mf
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/IOR-0.1/src/System/IOR/Internal.hs
Monad instance: 


instance Monad (IOR r rs) where
    return  = IOR . const . return
    m >>  n = IOR $ liftA2 (>>)  (unIOR m) (unIOR n)
    m >>= f = IOR $ liftA2 (>>=) (unIOR m) (flip $ unIOR . f)

    {-# INLINE return #-}
    {-# INLINE (>>)   #-}
    {-# INLINE (>>=)  #-}
Applicative instance: 


instance Applicative (IOR r rs) where
    pure  = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/vimus-0.2.1/src/Vimus/Command/Parser.hs
Applicative instance: 


instance Applicative Parser where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad Parser where
  fail      = parserFail . ParseError
  return a  = Parser $ \input -> Right (a, input)
  p1 >>= p2 = Parser $ \input -> runParser p1 input >>= uncurry (runParser . p2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-unlift-ref-0.2.0/Control/Monad/Trans/State/Ref.hs
Applicative instance: 


instance Applicative m => Applicative (StateRefT ref s m) where
    pure = StateRefT . const . pure
    {-# INLINE pure #-}
    StateRefT f <*> StateRefT g = StateRefT $ \x -> f x <*> g x
    {-# INLINE (<*>) #-}
Monad instance: 

instance Monad m => Monad (StateRefT ref s m) where
    return = StateRefT . const . return
    {-# INLINE return #-}
    StateRefT f >>= g = StateRefT $ \x -> do
        a <- f x
        unStateRefT (g a) x
    {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-unlift-ref-0.2.0/Control/Monad/Trans/RWS/Ref.hs
Applicative instance: 


instance Applicative m => Applicative (RWSRefT refw refs r w s m) where
    pure m = RWSRefT $ \_ _ _ -> pure m
    {-# INLINE pure #-}
    RWSRefT f <*> RWSRefT g = RWSRefT $ \x y z -> f x y z <*> g x y z
    {-# INLINE (<*>) #-}
Monad instance: 

instance Monad m => Monad (RWSRefT refw refs r w s m) where
    return m = RWSRefT $ \_ _ _ -> return m
    {-# INLINE return #-}
    RWSRefT f >>= g = RWSRefT $ \x y z -> do
        a <- f x y z
        unRWSRefT (g a) x y z
    {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-unlift-ref-0.2.0/Control/Monad/Trans/Writer/Ref.hs
Applicative instance: 


instance Applicative m => Applicative (WriterRefT ref w m) where
    pure = WriterRefT . const . pure
    {-# INLINE pure #-}
    WriterRefT f <*> WriterRefT g = WriterRefT $ \x -> f x <*> g x
    {-# INLINE (<*>) #-}
Monad instance: 

instance Monad m => Monad (WriterRefT ref w m) where
    return = WriterRefT . const . return
    {-# INLINE return #-}
    WriterRefT f >>= g = WriterRefT $ \x -> do
        a <- f x
        unWriterRefT (g a) x
    {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bspack-0.0.4/Data/ByteString/Pack/Internal.hs
Applicative instance: 


instance Applicative Packer where
    pure = returnPacker
    (<*>) = appendPacker
Monad instance: 


instance Monad Packer where
    return = returnPacker
    (>>=) = bindPacker
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Monatron-0.3.1/Control/Monatron/AutoInstances.hs
Monad instance: 


------------------------------------------------------------------
instance (Monad m, MonadT t) => Monad (t m) where
    return = treturn
    fail   = lift . fail
    (>>=)  = tbind
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Monatron-0.3.1/Control/Monatron/Monad.hs
Monad instance: 


instance Monad Id where
    return  = Id
    fail    = error
    m >>= f = f (runId m)
Monad instance: 


instance Monad Lift where
  return x  = L x
  fail x    = error x
  L x >>= k = k x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lattices-1.5.0/Algebra/Lattice/Op.hs
Applicative instance: 


instance Applicative Op where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Op where
  return      = Op
  Op x >>= f  = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lattices-1.5.0/Algebra/Lattice/Levitated.hs
Applicative instance: 


instance Applicative Levitated where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Levitated where
  return            = Levitate
  Top >>= _         = Top
  Bottom >>= _      = Bottom
  Levitate x >>= f  = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lattices-1.5.0/Algebra/Lattice/Dropped.hs
Applicative instance: 


instance Applicative Dropped where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Dropped where
  return        = Drop
  Top >>= _     = Top
  Drop x >>= f  = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lattices-1.5.0/Algebra/Lattice/Lexicographic.hs
Applicative instance: 


instance BoundedJoinSemiLattice k => Applicative (Lexicographic k) where
  pure = return
  (<*>) = ap
Monad instance: 


-- Essentially the Writer monad.
instance BoundedJoinSemiLattice k => Monad (Lexicographic k) where
  return                   =  Lexicographic bottom
  Lexicographic k v >>= f  =
    case f v of
      Lexicographic k' v' -> Lexicographic (k \/ k') v'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lattices-1.5.0/Algebra/Lattice/Lifted.hs
Applicative instance: 


instance Applicative Lifted where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Lifted where
  return        = Lift
  Bottom >>= _  = Bottom
  Lift x >>= f  = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lattices-1.5.0/Algebra/Lattice/Ordered.hs
Applicative instance: 


instance Applicative Ordered where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Ordered where
  return           = Ordered
  Ordered x >>= f  = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HaskellNet-0.5.1/src/Text/Packrat/Parse.hs
Applicative instance: 


instance Derivs d => Applicative (Parser d) where
    pure x = Parser (\dvs -> Parsed x dvs (nullError dvs))
    (<*>) = ap
Monad instance: 


instance Derivs d => Monad (Parser d) where
    (Parser p1) >>= f = Parser parse
        where parse dvs = first (p1 dvs)
              first (Parsed val rem err) =
                  let Parser p2 = f val
                  in second err (p2 rem)
              first (NoParse err) = NoParse err
              second err1 (Parsed val rem err) =
                  Parsed val rem (joinErrors err1 err)
              second err1 (NoParse err) =
                  NoParse (joinErrors err1 err)
    return = pure
    fail msg = Parser (\dvs -> NoParse (msgError (dvPos dvs) msg))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cpsa-3.3.2/src/CPSA/Lib/Utilities.hs
Applicative instance: 


instance Applicative (ReturnFail) where
    pure          = Return
    Fail e <*> _ = Fail e
    Return f <*> r = fmap f r
Monad instance: 


instance Monad ReturnFail where
    return = Return
    Fail l >>= _ = Fail l
    Return r >>= k = k r
    fail s = Fail s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cpsa-3.3.2/src/CPSA/Annotations/Formulas.hs
Applicative instance: 


instance Applicative (EitherS) where
    pure          = RightS
    LeftS e <*> _ = LeftS e
    RightS f <*> r = fmap f r
Monad instance: 


instance Monad EitherS where
    return = RightS
    LeftS l >>= _ = LeftS l
    RightS r >>= k = k r
    fail s = LeftS s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Alternative/Free.hs
Applicative instance: 


instance Functor f => Applicative (AltF f) where
  pure = Pure
  {-# INLINE pure #-}
  (Pure f)   <*> y         = fmap f y      -- fmap
  y          <*> (Pure a)  = fmap ($ a) y  -- interchange
  (Ap a f)   <*> b         = a `Ap` (flip <$> f <*> (Alt [b]))
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Functor f => Applicative (Alt f) where
  pure a = Alt [pure a]
  {-# INLINE pure #-}

  (Alt xs) <*> ys = Alt (xs >>= alternatives . (`ap'` ys))
    where
      ap' :: (Functor f) => AltF f (a -> b) -> Alt f a -> Alt f b

      Pure f `ap'` u      = fmap f u
      (u `Ap` f) `ap'` v  = Alt [u `Ap` (flip <$> f) <*> v]
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Comonad/Cofree.hs
Monad instance: 


instance Alternative f => Monad (Cofree f) where
  return x = x :< empty
  {-# INLINE return #-}
  (a :< m) >>= k = case k a of
                     b :< n -> b :< (n <|> fmap (>>= k) m)
Applicative instance: 


instance Alternative f => Applicative (Cofree f) where
  pure = return
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Comonad/Trans/Cofree.hs
Monad instance: 


instance (Alternative f, Monad w) => Monad (CofreeT f w) where
  return = CofreeT . return . (:< empty)
  {-# INLINE return #-}
  CofreeT cx >>= f = CofreeT $ do
    a :< m <- cx
    b :< n <- runCofreeT $ f a
    return $ b :< (n <|> fmap (>>= f) m)
Applicative instance: 



instance (Alternative f, Applicative w) => Applicative (CofreeT f w) where
  pure = CofreeT . pure . (:< empty)
  {-# INLINE pure #-}
  wf <*> wa = CofreeT $ go <$> runCofreeT wf <*> runCofreeT wa where
    go (f :< t) a = case bimap f (fmap f) a of
      b :< n -> b :< (n <|> fmap (<*> wa) t)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Applicative/Trans/Free.hs
Applicative instance: 


instance Applicative g => Applicative (ApF f g) where
  pure = Pure
  {-# INLINE pure #-}
  Pure f   <*> y       = fmap f y      -- fmap
  y        <*> Pure a  = fmap ($ a) y  -- interchange
  Ap a f   <*> b       = a `Ap` (flip <$> f <*> ApT (pure b))
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative g => Applicative (ApT f g) where
  pure = ApT . pure . pure
  {-# INLINE pure #-}
  ApT xs <*> ApT ys = ApT ((<*>) <$> xs <*> ys)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Applicative/Free.hs
Applicative instance: 


instance Applicative (Ap f) where
  pure = Pure
  Pure f <*> y = fmap f y
  Ap x y <*> z = Ap x (flip <$> y <*> z)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Monad/Free/Church.hs
Applicative instance: 


instance Applicative (F f) where
  pure a = F (\kp _ -> kp a)
  F f <*> F g = F (\kp kf -> f (\a -> g (kp . a) kf) kf)
Monad instance: 


instance Monad (F f) where
  return a = F (\kp _ -> kp a)
  F m >>= f = F (\kp kf -> m (\a -> runF (f a) kp kf) kf)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Monad/Trans/Free/Church.hs
Applicative instance: 


instance Applicative (FT f m) where
  pure a = FT $ \k _ -> k a
  FT fk <*> FT ak = FT $ \b fr -> ak (\d -> fk (\e -> b (e d)) fr) fr
Monad instance: 


instance Monad (FT f m) where
  return = pure
  FT fk >>= f = FT $ \b fr -> fk (\d -> runFT (f d) b fr) fr
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Monad/Trans/Free.hs
Applicative instance: 


instance (Functor f, Monad m) => Applicative (FreeT f m) where
  pure a = FreeT (return (Pure a))
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}
Monad instance: 


instance (Functor f, Monad m) => Monad (FreeT f m) where
  return a = FreeT (return (Pure a))
  {-# INLINE return #-}
  FreeT m >>= f = FreeT $ m >>= \v -> case v of
    Pure a -> runFreeT (f a)
    Free w -> return (Free (fmap (>>= f) w))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Monad/Trans/Iter.hs
Applicative instance: 


instance Monad m => Applicative (IterT m) where
  pure = IterT . return . Left
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad m => Monad (IterT m) where
  return = IterT . return . Left
  {-# INLINE return #-}
  IterT m >>= k = IterT $ m >>= either (runIterT . k) (return . Right . (>>= k))
  {-# INLINE (>>=) #-}
  fail = IterT . fail
  {-# INLINE fail #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Monad/Free.hs
Applicative instance: 


instance Functor f => Applicative (Free f) where
  pure = Pure
  {-# INLINE pure #-}
  Pure a <*> Pure b = Pure $ a b
  Pure a <*> Free mb = Free $ fmap a <$> mb
  Free ma <*> b = Free $ (<*> b) <$> ma
Monad instance: 


instance Functor f => Monad (Free f) where
  return = Pure
  {-# INLINE return #-}
  Pure a >>= f = f a
  Free m >>= f = Free ((>>= f) <$> m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lojbanParser-0.1.9.2/src/Parse.hs
Monad instance: 
           -- unconditional error labeling

-- Standard monadic combinators
instance Derivs d => Monad (Parser d) where

        -- Sequencing combinator
        (Parser p1) >>= f = Parser parse

                where parse dvs = first (p1 dvs)

                      first (Parsed val rem err) =
                        let Parser p2 = f val
                        in second err (p2 rem)
                      first (NoParse err) = NoParse err

                      second err1 (Parsed val rem err) =
                        Parsed val rem (joinErrors err1 err)
                      second err1 (NoParse err) =
                        NoParse (joinErrors err1 err)

        -- Result-producing combinator
        return x = Parser (\dvs -> Parsed x dvs (nullError dvs))

        -- Failure combinator
        fail [] = Parser (\dvs -> NoParse (nullError dvs))
        fail msg = Parser (\dvs -> NoParse (msgError (dvPos dvs) msg))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HaTeX-3.9.1.0/Text/LaTeX/Packages/TikZ/PathBuilder.hs
Applicative instance: 


instance Applicative PathBuilder where
 pure = PB . pure
 (PB f) <*> (PB x) = PB $ f <*> x
Monad instance: 


instance Monad PathBuilder where
 return = pure
 (PB x) >>= f = PB $ x >>= pathBuilder . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HaTeX-3.9.1.0/Text/LaTeX/Base/Writer.hs
Applicative instance: 


instance Applicative f => Applicative (LaTeXT f) where
 pure = LaTeXT . pure . pairNoth
 (LaTeXT f) <*> (LaTeXT x) = LaTeXT $ fmap (first . fst) f <*> x
Monad instance: 


instance Monad m => Monad (LaTeXT m) where
 return = LaTeXT . return . pairNoth
 (LaTeXT c) >>= f = LaTeXT $ do
  (a,_) <- c
  let LaTeXT c' = f a
  c'
 fail = throwError
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/syb-0.6/tests/Perm.hs
Applicative instance: 


instance Applicative ReadT where
  pure  = return
  (<*>) = ap
Monad instance: 


-- ReadT is a monad!
instance Monad ReadT where
  return x = ReadT (\y -> Just (y,x))
  c >>= f  = ReadT (\x -> case unReadT c x of
                            Nothing -> Nothing
                            Just (x', a) -> unReadT (f a) x'
                   )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/syb-0.6/tests/XML.hs
Applicative instance: 


instance Applicative ReadX where
  pure  = return
  (<*>) = ap
Monad instance: 


-- ReadX is a monad!
instance Monad ReadX where
  return x = ReadX (\y -> Just (y,x))
  c >>= f  = ReadX (\x -> case unReadX c x of
                            Nothing -> Nothing
                            Just (x', a) -> unReadX (f a) x'
                   )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/syb-0.6/tests/Bits.hs
Applicative instance: 


instance Applicative ReadB where
  pure  = return
  (<*>) = ap
Monad instance: 


-- It's a monad.
instance Monad ReadB where
  return a = ReadB (\bs -> (Just a, bs))
  (ReadB c) >>= f = ReadB (\bs -> case c bs of
                             (Just a, bs')  -> unReadB (f a) bs'
                             (Nothing, bs') -> (Nothing, bs')
                          )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/syb-0.6/tests/GRead2.hs
Applicative instance: 


instance Applicative DecM where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad DecM where
    return a = D (\s -> Just (s,a))
    (D m) >>= k = D (\s ->
      case m s of
        Nothing -> Nothing
        Just (s1,a) -> let D n = k a
                        in n s1)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/syb-0.6/tests/Encode.hs
Applicative instance: 

instance Applicative EncM where
  pure  = return
  (<*>) = ap
Monad instance: 

instance Monad EncM
 where
  return  = undefined
  c >>= f = undefined
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/control-monad-omega-0.3.1/Control/Monad/Omega.hs
Monad instance: 


instance Monad Omega where
    return x = Omega [x]
    Omega m >>= f = Omega $ diagonal $ map (runOmega . f) m
    fail _ = Omega []
Applicative instance: 


instance Applicative.Applicative Omega where
    pure = return
    (<*>) = Monad.ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ddc-core-0.4.3.1/DDC/Core/Fragment/Compliance.hs
Applicative instance: 



instance Applicative (CheckM s err) where
 (<*>)  = ap
 pure   = return
Monad instance: 



instance Monad (CheckM a n) where
 return x   = CheckM (Right x)
 (>>=) m f
  = case m of
          CheckM (Left err)     -> CheckM (Left err)
          CheckM (Right x)      -> f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uniform-pair-0.1.9/src/Data/UniformPair.hs
Applicative instance: 
  -- exchange

instance Applicative Pair where
  pure a = a :# a
  (f :# g) <*> (a :# b) = f a :# g b
Monad instance: 


instance Monad Pair where
  return = pure
  m >>= f = joinP (f <$> m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ixmonad-0.57/examples/WriterM.hs
Monad instance: 


instance Monoid w => Monad (Writer w) where
   return a = Writer (a, mempty)
   (Writer (a, w)) >>= k = let (b, w') = runWriter (k a)
                           in Writer (b, w `mappend` w')
Monad instance: 


instance Monad (Writer (Maybe a)) where
   return a = Writer (a, Nothing)
   (Writer (a, w)) >>= k = let (b, w') = runWriter (k a)
                           in case w' of
                                Nothing -> Writer (b, w)
                                Just w' -> Writer (b, Just w')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/effect-monad-0.6.1/examples/WriterM.hs
Monad instance: 


instance Monoid w => Monad (Writer w) where
   return a = Writer (a, mempty)
   (Writer (a, w)) >>= k = let (b, w') = runWriter (k a)
                           in Writer (b, w `mappend` w')
Monad instance: 


instance Monad (Writer (Maybe a)) where
   return a = Writer (a, Nothing)
   (Writer (a, w)) >>= k = let (b, w') = runWriter (k a)
                           in case w' of
                                Nothing -> Writer (b, w)
                                Just w' -> Writer (b, Just w')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Annotations-0.2.1/Annotations/Except.hs
Applicative instance: 


instance Monoid e => Applicative (Except e) where
  pure = OK
  OK f <*> OK x = OK (f x)
  OK _ <*> Failed e = Failed e
  Failed e <*> OK _ = Failed e
  Failed e1 <*> Failed e2 = Failed (e1 `mappend` e2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reflection-2.1.2/fast/Data/Reflection.hs
Applicative instance: 


instance Reifies s (ReifiedApplicative f) => Applicative (ReflectedApplicative f s) where
  pure a = reflectResult1 (\m -> ReflectedApplicative (reifiedPure m a))
  ReflectedApplicative x <*> ReflectedApplicative y = reflectResult1 (\m -> ReflectedApplicative (reifiedAp m x y))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hoauth-0.3.5/src/main/haskell/Network/OAuth/Consumer.hs
Monad instance: 


instance (Monad m) => Monad (OAuthMonadT m) where
  return a = OAuthMonadT $ \t -> return $ Right (t,a)
  fail err = OAuthMonadT $ \_ -> return $ Left err

  (OAuthMonadT ma) >>= f = OAuthMonadT $ \t0 -> ma t0 >>= either left right
    where left = return . Left
          right (t1,a) = let OAuthMonadT mb = f a
                         in mb t1
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dbus-core-0.9.3/hs/DBus/Connection/Authentication.hs
Monad instance: 


instance Monad Auth where
        return a = Auth (\_ -> return a)
        m >>= k = Auth $ \s -> do
                x <- unAuth m s
                unAuth (k x) s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dbus-core-0.9.3/hs/DBus/Introspection.hs
Monad instance: 


instance Monad XmlWriter where
        return a = XmlWriter $ Just (a, Data.Text.empty)
        m >>= f = XmlWriter $ do
                (a, w) <- runXmlWriter m
                (b, w') <- runXmlWriter (f a)
                return (b, Data.Text.append w w')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dbus-core-0.9.3/hs/DBus/Wire/Internal.hs
Monad instance: 


instance Monad (Wire s) where
        {-# INLINE return #-}
        return a = Wire (\_ s -> WireRR a s)

        {-# INLINE (>>=) #-}
        m >>= k = Wire $ \e s -> case unWire m e s of
                WireRL err -> WireRL err
                WireRR a s' -> unWire (k a) e s'

        {-# INLINE (>>) #-}
        m >> k = Wire $ \e s -> case unWire m e s of
                WireRL err -> WireRL err
                WireRR _ s' -> unWire k e s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dbus-core-0.9.3/hs/DBus/Util/MonadError.hs
Monad instance: 


instance Monad (ErrorM e) where
        return = ErrorM . Right
        (>>=) m k = case runErrorM m of
                Left err -> ErrorM $ Left err
                Right x -> k x
Monad instance: 


instance Monad m => Monad (ErrorT e m) where
        return = ErrorT . return . Right
        (>>=) m k = ErrorT $ do
                x <- runErrorT m
                case x of
                        Left l -> return $ Left l
                        Right r -> runErrorT $ k r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/exceptional-0.3.0.0/Control/Exceptional.hs
Applicative instance: 


instance Applicative Exceptional where
  pure = Success
  Success f <*> Success x = Success (f x)
  Failure s <*> _ = Failure s
  _ <*> Failure s = Failure s
Monad instance: 


-- |This is 'fail'-safe, so to speak. That is,
-- 
-- > fail = Failure
instance Monad Exceptional where
  (>>=) (Success x) f = f x
  (>>=) (Failure s) _ = Failure s
  fail = Failure
  return = pure
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/seclib-1.1.0.2/SecLib/TCB/Sec.hs
Monad instance: 


instance Monad (Sec l) where
  return a = MkSec a

  MkSec a >>= k =
    MkSec (let MkSec b = k a in b)
Applicative instance: 


instance Applicative (Sec l) where
    pure  = return
    -- | @(<*>)@ cannot be used since @Sec l@ is not a functor
    (<*>) = undefined
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/seclib-1.1.0.2/SecLib/TCB/SecIO.hs
Monad instance: 


instance Monad (SecIO l) where
  return a =
    MkSecIO (return (return a))

  MkSecIO m >>= k =
    MkSecIO (do sec_a <- m
                let MkSecIO m' = k (unsec sec_a)
                m')
Applicative instance: 


{- |
   For the same reason as above, '(<*>)' is undefined.
-}
instance Applicative (SecIO l) where
    pure  = return
    (<*>) = undefined
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rangemin-2.2.2/Data/RangeMin/LCA/IndexM.hs
Monad instance: 


instance Monad IndexM where
        return a = IndexM (IP a)
        m >>= k = IndexM $ \ i -> case runIndexM m i of
                IP x i' -> runIndexM (k x) i'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/V3.hs
Applicative instance: 


instance Applicative V3 where
  pure a = V3 a a a
  {-# INLINE pure #-}
  V3 a b c <*> V3 d e f = V3 (a d) (b e) (c f)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad V3 where
  return a = V3 a a a
  {-# INLINE return #-}
  V3 a b c >>= f = V3 a' b' c' where
    V3 a' _ _ = f a
    V3 _ b' _ = f b
    V3 _ _ c' = f c
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/Instances.hs
Applicative instance: 


instance Applicative Complex where
  pure a = a :+ a
  (a :+ b) <*> (c :+ d) = a c :+ b d
Monad instance: 


instance Monad Complex where
  return a = a :+ a
  {-# INLINE return #-}

  (a :+ b) >>= f = a' :+ b' where
    a' :+ _  = f a
    _  :+ b' = f b
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/V2.hs
Applicative instance: 

  {-@ INLINE (<.>) #-}

instance Applicative V2 where
  pure a = V2 a a
  {-# INLINE pure #-}
  V2 a b <*> V2 d e = V2 (a d) (b e)
Monad instance: 


instance Monad V2 where
  return a = V2 a a
  {-# INLINE return #-}
  V2 a b >>= f = V2 a' b' where
    V2 a' _ = f a
    V2 _ b' = f b
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/Plucker.hs
Applicative instance: 


instance Applicative Plucker where
  pure a = Plucker a a a a a a
  {-# INLINE pure #-}
  Plucker a b c d e f <*> Plucker g h i j k l =
    Plucker (a g) (b h) (c i) (d j) (e k) (f l)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Plucker where
  return a = Plucker a a a a a a
  {-# INLINE return #-}
  Plucker a b c d e f >>= g = Plucker a' b' c' d' e' f' where
    Plucker a' _ _ _ _ _ = g a
    Plucker _ b' _ _ _ _ = g b
    Plucker _ _ c' _ _ _ = g c
    Plucker _ _ _ d' _ _ = g d
    Plucker _ _ _ _ e' _ = g e
    Plucker _ _ _ _ _ f' = g f
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/V4.hs
Applicative instance: 


instance Applicative V4 where
  pure a = V4 a a a a
  {-# INLINE pure #-}
  V4 a b c d <*> V4 e f g h = V4 (a e) (b f) (c g) (d h)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad V4 where
  return a = V4 a a a a
  {-# INLINE return #-}
  V4 a b c d >>= f = V4 a' b' c' d' where
    V4 a' _ _ _ = f a
    V4 _ b' _ _ = f b
    V4 _ _ c' _ = f c
    V4 _ _ _ d' = f d
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/V1.hs
Applicative instance: 

  {-@ INLINE (<.>) #-}

instance Applicative V1 where
  pure = V1
  {-# INLINE pure #-}
  V1 f <*> V1 x = V1 (f x)
Monad instance: 


instance Monad V1 where
  return = V1
  {-# INLINE return #-}
  V1 a >>= f = f a
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/V.hs
Applicative instance: 


instance Dim n => Applicative (V n) where
  pure = V . V.replicate (reflectDim (Proxy :: Proxy n))
  {-# INLINE pure #-}

  V as <*> V bs = V (V.zipWith id as bs)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Dim n => Monad (V n) where
  return = V . V.replicate (reflectDim (Proxy :: Proxy n))
  {-# INLINE return #-}
  V as >>= f = V $ generate (reflectDim (Proxy :: Proxy n)) $ \i ->
    toVector (f (as `unsafeIndex` i)) `unsafeIndex` i
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/V0.hs
Applicative instance: 

  {-@ INLINE (<.>) #-}

instance Applicative V0 where
  pure _ = V0
  {-# INLINE pure #-}
  V0 <*> V0 = V0
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad V0 where
  return _ = V0
  {-# INLINE return #-}
  V0 >>= _ = V0
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/Covector.hs
Applicative instance: 


instance Applicative (Covector r) where
  pure a = Covector $ \k -> k a
  Covector mf <*> Covector ma = Covector $ \k -> mf $ \f -> ma $ k . f
Monad instance: 


instance Monad (Covector r) where
  return a = Covector $ \k -> k a
  Covector m >>= f = Covector $ \k -> m $ \a -> runCovector (f a) k
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/Vector.hs
Applicative instance: 

instance Applicative SetOne where
  pure a = SetOne a []
  SetOne f fs <*> SetOne a as = SetOne (f a) (Prelude.foldr ((:) . ($ a)) (Prelude.map f as) fs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/Quaternion.hs
Applicative instance: 


instance Applicative Quaternion where
  pure a = Quaternion a (pure a)
  {-# INLINE pure #-}
  Quaternion f fv <*> Quaternion a v = Quaternion (f a) (fv <*> v)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Quaternion where
  return = pure
  {-# INLINE return #-}
  -- the diagonal of a sedenion is super useful!
  Quaternion a (V3 b c d) >>= f = Quaternion a' (V3 b' c' d') where
    Quaternion a' _          = f a
    Quaternion _ (V3 b' _ _) = f b
    Quaternion _ (V3 _ c' _) = f c
    Quaternion _ (V3 _ _ d') = f d
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/clash-prelude-0.9.3/src/CLaSH/Signal/Internal.hs
Applicative instance: 


instance Applicative (Signal' clk) where
  pure  = signal#
  (<*>) = appSignal#
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/clash-prelude-0.9.3/src/CLaSH/Sized/Vector.hs
Applicative instance: 


instance KnownNat n => Applicative (Vec n) where
  pure      = repeat
  fs <*> xs = zipWith ($) fs xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/NestedFunctor-0.2.0.2/Data/Functor/Nested.hs
Applicative instance: 


instance (Applicative f) => Applicative (Nested (Flat f)) where
   pure              = Flat . pure
   Flat f <*> Flat x = Flat (f <*> x)
Applicative instance: 


instance (Applicative f, Applicative (Nested fs)) => Applicative (Nested (Nest fs f)) where
   pure              = Nest . pure . pure
   Nest f <*> Nest x = Nest ((<*>) <$> f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/nonempty-alternative-0.4.0/src/Data/NonEmpty.hs
Applicative instance: 


----------------------------------------------------------------------

instance Alternative f => Applicative (NonEmptyL f) where
  pure x = x :<: empty

  (f :<: fs) <*> (x :<: xs) = (f x) :<: (   (pure f <*> xs    )
                                     <|> (fs     <*> (pure x <|> xs)))
Applicative instance: 


instance Alternative f => Applicative (NonEmptyR f) where
  pure x = empty :>: x

  (fs :>: f) <*> (xs :>: x) = (   (fs     <*> (xs <|> pure x) )
                            <|> (pure f <*> xs    ) ) :>: (f x)
Monad instance: 


----------------------------------------------------------------------

instance (Alternative f, Monad f) => Monad (NonEmptyL f) where
  (x :<: xs) >>= f = y :<: (ys <|> zs)
                  where (y :<: ys) = f x
                        zs = xs >>= flattenL . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/compressed-3.10/src/Data/Compressed/RunLengthEncoding.hs
Applicative instance: 


instance Applicative Run where
  pure = Run 1
  Run n f <*> Run m a = Run (n * m) (f a)
  Run n _  *> Run m a = Run (n * m) a
  Run n a <*  Run m _ = Run (n * m) a
Monad instance: 


instance Monad Run where
  return = Run 1
  Run n _ >> Run m b = Run (n * m) b
  Run n a >>= f = case f a of
    Run m b -> Run (n * m) b
Applicative instance: 


instance Applicative RLE where
  pure = RLE . F.singleton . pure
  RLE fs <*> RLE as = RLE $ F.fromList $ do
    Run n f <- toList fs
    Run m a <- toList as
    return $ Run (n * m) (f a)
  RLE as <* RLE bs = RLE $ F.fmap' (\(Run n a) -> Run (n * m) a) as where
    m = reduceWith getCount bs
  RLE as *> RLE bs = RLE $ mconcat $ replicate (reduceWith getCount as) bs
Monad instance: 


instance Monad RLE where
  return = RLE . F.singleton . pure
  (>>) = (*>)
  RLE xs >>= f = RLE $ mconcat [ mconcat $ replicate n (getRLE (f a)) | Run n a <- toList xs ]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/compressed-3.10/src/Data/Compressed/Internal/LZ78.hs
Applicative instance: 


instance Applicative LZ78 where
  pure a = Cons (Token 0 a) Nil
  fs <*> as = fmap extract $ encode $ do
    Entry i f <- decode (entries fs)
    Entry j a <- decode (entries as)
    return $ Entry (i,j) (f a)
  as *> bs = fmap extract $ encode $ Prelude.concat $ replicate (reduceWith getCount as)  $  decode (entries bs)
  as <* bs = fmap extract $ encode $ Prelude.concat $ replicate (reduceWith getCount bs) <$> decode (entries as)
Monad instance: 


instance Monad LZ78 where
  return a = Cons (Token 0 a) Nil
  (>>) = (*>)
  as >>= k = fmap extract $ encode $ do
    Entry i a <- decode (entries as)
    Entry j b <- decode (entries (k a))
    return $ Entry (i,j) b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/frpnow-0.18/Control/FRPNow/BehaviorEnd.hs
Monad instance: 


instance Monad (BehaviorEnd x) where
  return x = pure (error "ended!") `Until` pure x
  (b `Until` e) >>= f  =
     let v = f <$> e
         b' = b `switch` (behavior <$> v)
         e' = v >>= end
     in b' `Until` e'
Applicative instance: 

instance Applicative (BehaviorEnd x) where pure = return ; (<*>) = ap
Monad instance: 


instance Swap f g => Monad (f :. g) where
  -- see (Composing Monads, Jones and Duponcheel) for proof
  return  = Close . return . return
  m >>= f = joinComp (fmap2m f m)
Applicative instance: 

-- this works as follows, we have 
-- b . e . b . e      flip middle two
-- b . b . e . e      join left and right
-- b . e 


instance (Applicative b, Applicative e) => Applicative (b :. e) where
   pure = Close . pure . pure
   x <*> y = Close $ (<*>) <$> open x <*> open y
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/frpnow-0.18/Control/FRPNow/Core.hs
Monad instance: 



instance Monad Event where
  return = Occ
  Never >>= _ = Never
  (Occ x) >>= f = f x
  (E m)   >>= f = memoE $ bindInternal m f
Monad instance: 



{-
whenJustSample' :: Behavior (Maybe (Behavior a)) -> Behavior (Event a)
whenJustSample' (Const Nothing)  = pure never
whenJustSample' (Const (Just x)) = B $ do v <- fst <$> runB x; return (pure v, never)
whenJustSample' (B bm) = B $
  do (h, t) <- bm
     case h of
      Just x -> do v <- fst <$> runB x; return (pure v, whenJustSample' <$> t)
      Nothing -> do en <- planM (runB . whenJustSample' <$> t)
                    return (en >>= fst, never)
-}
instance Monad Behavior where
  return x = B $ return (x, never)
  m >>= f = m `bindB` f
Applicative instance: 


instance Applicative Behavior where
  pure = return
  (<*>) = ap
Applicative instance: 


instance Applicative Event where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/WebCont-0.0.1/WebCont.hs
Monad instance: 


instance Monad (WebCont r) where
    return = WebCont . const . Done
    w >>= f = WebCont $ \e -> case (runWeb w e) of
        Done a -> runWeb (f a) e
        Via r w' -> Via r (w' >>= f)
Applicative instance: 

instance Applicative Identity where pure = return; (<*>) = ap;
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/helix-0.9.5/src/Util/Free.hs
Applicative instance: 

instance Functor f => Applicative (F f) where
  pure a = F (\kp _ -> kp a)
  F f <*> F g = F (\kp kf -> f (\a -> g (kp . a) kf) kf)
Monad instance: 

instance Functor f => Monad (F f) where
  return a = F (\kp _ -> kp a)
  F m >>= f = F (\kp kf -> m (\a -> runF (f a) kp kf) kf)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CC-delcont-cxe-0.1.0.2/Generator2.hs
Monad instance: 


instance Monad Identity where
    return = Identity
    m >>= f = f $ runIdentity m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CC-delcont-cxe-0.1.0.2/Bench_nondet.hs
Monad instance: 


instance Monad CPS where
    return x = CPS $ \k -> k x
    m >>= f  = CPS $ \k -> unCPS m (\a -> unCPS (f a) k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CC-delcont-cxe-0.1.0.2/Control/Monad/CC/CCCxe.hs
Monad instance: 



-- --------------------------------------------------------------------
-- | CC monad: general monadic operations

instance Monad m => Monad (CC p m) where
    return x = CC $ \ki kd -> ki x

    m >>= f = CC $ \ki kd -> unCC m
                              (\a -> unCC (f a) ki kd)
                              (\ctx -> kd (\x -> ctx x >>= f))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/compression-0.1/Codec/Compression/LazyStateT.hs
Monad instance: 


instance Monad m => Monad (LazyStateT s m) where
 -- (>>=)  :: LazyStateT s m a -> (a -> LazyStateT s m b) -> LazyStateT s m b
    LazyStateT v >>= f = LazyStateT $ \s -> do ~(x, s') <- v s
                                               let LazyStateT y = f x
                                               y s'
 -- return :: a -> LazyStateT s m a
    return x = LazyStateT $ \s -> return (x, s)
 -- fail :: String -> LazyStateT s m a
    fail str = LazyStateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/graph-serialize-0.2/Data/Serialize/References.hs
Monad instance: 


instance Monad BuildM where
  return a = BuildM $ \s nr nl k -> k s nr nl a
  BuildM f >>= kont = BuildM $ \s nr nl k ->
    f s nr nl (\s' nr' nl' a -> unBuildM (kont a) s' nr' nl' k)
Applicative instance: 

instance Applicative BuildM where pure = return; (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hadoop-rpc-1.1.0.0/src/Network/Hadoop/Hdfs.hs
Applicative instance: 


instance Applicative Hdfs where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad Hdfs where
    return  = Hdfs . const . return
    m >>= k = Hdfs $ \c -> unHdfs m c >>= \x -> unHdfs (k x) c
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/open-signals-0.1.0.3/src/Control/Monad/Signal.hs
Applicative instance: 


instance Applicative (Signal sigs) where
    pure = Value
    Signal u <*> _        = Signal u
    Value f  <*> Value x  = Value (f x)
    Value _  <*> Signal u = Signal u
Monad instance: 


instance Monad (Signal sigs) where
    return = pure
    Signal u >>= _ = Signal u
    Value a  >>= f = f a
Applicative instance: 


instance Applicative m => Applicative (SignalT sigs m) where
    pure x = SignalT (pure (Value x))
    SignalT mcab <*> SignalT mca = SignalT mcb
        where mcacb = fmap (<*>) mcab
              mcb = mcacb <*> mca
Monad instance: 


instance Monad m => Monad (SignalT sigs m) where
    return = pure
    SignalT mca >>= f = SignalT $ mca >>= \case
        Value a  -> runSignalT (f a)
        Signal u -> return (Signal u)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tip-lib-0.2.2/src/Tip/Parser/ErrM.hs
Monad instance: 


instance Monad Err where
  return      = Ok
  fail        = Bad
  Ok a  >>= f = f a
  Bad s >>= _ = Bad s
Applicative instance: 


instance Applicative Err where
  pure = Ok
  (Bad s) <*> _ = Bad s
  (Ok f) <*> o  = liftM f o
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tip-lib-0.2.2/src/Tip/Writer.hs
Applicative instance: 


instance (Monoid w, Monad m) => Applicative (WriterT w m) where
  {-# INLINE pure #-}
  pure = return
  {-# INLINE (<*>) #-}
  (<*>) = liftM2 ($)
Monad instance: 


instance (Monoid w, Monad m) => Monad (WriterT w m) where
  {-# INLINE return #-}
  return x = WriterT (\k -> k mempty x)

  {-# INLINE (>>=) #-}
  WriterT m >>= f =
    WriterT $ \k ->
      m (\w x -> unWriterT (f x) (\w' y -> k (w `mappend` w') y))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/llvm-pretty-bc-parser-0.2.1.0/src/Data/LLVM/BitCode/GetBits.hs
Applicative instance: 


instance Applicative GetBits where
  {-# INLINE pure #-}
  pure x = GetBits (\ off -> return (x,off))

  {-# INLINE (<*>) #-}
  f <*> x = GetBits $ \ off0 -> do
    (g,off1) <- unGetBits f off0
    (y,off2) <- unGetBits x off1
    return (g y,off2)
Monad instance: 


instance Monad GetBits where
  {-# INLINE return #-}
  return = pure

  {-# INLINE (>>=) #-}
  m >>= f = GetBits $ \ off0 -> do
    (x,off1) <- unGetBits m off0
    unGetBits (f x) off1

  {-# INLINE fail #-}
  fail str = GetBits (\ _ -> fail str)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/llvm-pretty-bc-parser-0.2.1.0/src/Data/LLVM/BitCode/Parse.hs
Monad instance: 


instance Monad Parse where
  {-# INLINE return #-}
  return  = Parse . return

  {-# INLINE (>>=) #-}
  Parse m >>= f = Parse (m >>= unParse . f)

  {-# INLINE fail #-}
  fail = failWithContext
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/scion-0.1.0.2/lib/Scion/Types.hs
Monad instance: 


instance Monad ScionM where
  return x = ScionM $ \_ -> return x
  (ScionM ma) >>= fb =
      ScionM $ \s -> do
        a <- ma s
        unScionM (fb a) s
  fail msg = dieHard msg
Applicative instance: 


instance Applicative ScionM where
  pure a = ScionM $ \_ -> return a
  ScionM mf <*> ScionM ma =
      ScionM $ \s -> do f <- mf s; a <- ma s; return (f a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/scion-0.1.0.2/server/Scion/Server/Commands.hs
Monad instance: 

instance Monad Pa where
  return x = Pa $ \_ -> Right x
  m >>= k = Pa $ \req ->
            case unPa m req of
              Left err -> Left err
              Right a -> unPa (k a) req
  fail msg = Pa $ \_ -> Left msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hakaru-0.1.4/Language/Hakaru/Metropolis.hs
Monad instance: 


instance Monad Measure where
  return = return_
  (>>=)  = bind
Applicative instance: 


instance Applicative Measure where
  pure = return_
  (<*>) = app
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hakaru-0.1.4/Language/Hakaru/ImportanceSampler.hs
Monad instance: 


instance Monad Measure where
  return x = Measure (\conds -> deterministic (point (x,conds) 1))
  (>>=)    = bind
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ObjectIO-1.0.1.1/Graphics/UI/ObjectIO/OS/Picture.hs
Monad instance: 


instance Monad Draw where
   return x = Draw (\pict -> return (x, pict))
   (Draw f) >>= g = Draw (\pict -> do
        (x, pict) <- f pict
        let (Draw f2) = g x
        f2 pict)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-concurrent-0.1.0.1/src/Control/Concurrent/Free.hs
Applicative instance: 


instance Applicative (F f) where
  pure = Pure
  Pure f <*> y = fmap f y
  x <*> y = Ap y x
Monad instance: 


instance Monad (F f) where
  return = pure
  Pure x >>= f = f x
  x >>= f = Join (fmap f x)
  x >> y = x *> y
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/colour-2.3.3/Data/Colour/RGB.hs
Applicative instance: 


instance Applicative RGB where
 pure c = RGB c c c
 (RGB fr fg fb) <*> (RGB r g b) = RGB (fr r) (fg g) (fb b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/llvm-general-quote-0.2.0.0/src/LLVM/General/Quote/Parser/Monad.hs
Applicative instance: 


instance Applicative P where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad P where
    m >>= k = P $ \s ->
        case runP m s of
          Left e         -> Left e
          Right (a, s')  -> runP (k a) s'

    m1 >> m2 = P $ \s ->
        case runP m1 s of
          Left e         -> Left e
          Right (_, s')  -> runP m2 s'

    return a = P $ \s -> Right (a, s)

    fail msg = do
        inp <- getInput
        throw $ ParserException (Loc (alexPos inp) (alexPos inp))
                                (ppr (alexPos inp) <> colon <+> text msg)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/UMM-0.3.1/UMMData.hs
Monad instance: 


-- Note that because we use append (++) for lists here, this is fairly
-- low-performance: it's entirely ok for this application, where we
-- toss around a few to a few thousand list entries, but for longer
-- lists it might not be suitable. <shrug>

instance Monad (Ledger e i) where
  return a = Ledger (a, [], [])
  (>>=) m k =
    let (a,li1,le1) = runLedger m
        n = k a
        (b,li2,le2) = runLedger n
    in Ledger (b, li1 ++ li2, le1 ++ le2)
  (>>) a f = a >>= const f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/orc-1.2.1.4/src/Control/Concurrent/Hierarchical.hs
Monad instance: 


instance Monad HIO where
  return x = HIO $ \_ -> return x
  m >>= k  = HIO $ \w -> do
                 x <- m `inGroup` w
                 k x `inGroup` w
Applicative instance: 



instance Applicative HIO where
  pure  = return
  f <*> x = ap f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/orc-1.2.1.4/src/Orc/Monad.hs
Monad instance: 


instance Monad Orc where
  return x = Orc $ \k -> k x
  p >>= h  = Orc $ \k -> p # (\x -> h x # k)
  fail _   = stop
Applicative instance: 


instance Applicative Orc where
  pure    = return
  f <*> x = ap f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sample-frame-0.0.3/src/Sound/Frame/Stereo/Record.hs
Applicative instance: 


-- useful for defining Additive instance
instance Applicative T where
   {-# INLINE pure #-}
   pure a = Cons a a
   {-# INLINE (<*>) #-}
   Cons fl fr <*> Cons l r = Cons (fl l) (fr r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sample-frame-0.0.3/src/Sound/Frame/Stereo/Traversable.hs
Applicative instance: 


-- useful for defining Additive instance
instance Applicative T where
   {-# INLINE pure #-}
   pure a = Cons a a
   {-# INLINE (<*>) #-}
   ~(Cons fl fr) <*> ~(Cons l r) = Cons (fl l) (fr r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sample-frame-0.0.3/src/Sound/Frame/Stereo.hs
Applicative instance: 


-- useful for defining Additive instance
instance Applicative T where
   {-# INLINE pure #-}
   pure a = Cons a a
   {-# INLINE (<*>) #-}
   Cons fl fr <*> Cons l r = Cons (fl l) (fr r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/piet-0.1/sources/Language/Piet/PietMonad.hs
Monad instance: 


instance Monad PietMonad where
        return x = PietMonad (\status _ _ -> return (return (x, status)))

        (PietMonad m01) >>= f = PietMonad (\status0 requestChan inputChan -> do
                        either1 <- m01 status0 requestChan inputChan
                        case either1 of
                                Left msg                -> return (fail msg)
                                Right (x1, status1)     -> do
                                        let (PietMonad m12) = f x1
                                        m12 status1 requestChan inputChan
                )

        fail msg = do
                logMessage Fatal msg
                PietMonad (\_ _ _ -> return (fail msg))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bytestringparser-temporary-0.4.1/src/Data/ParserCombinators/Attoparsec/Internal.hs
Monad instance: 


instance Monad Parser where
    return a = Parser $ \s -> Right (a, s)
    m >>= f = Parser $ \s ->
              case unParser m s of
                Right (a, s') -> unParser (f a) s'
                Left (s', msgs) -> Left (s', msgs)
    fail err = Parser $ \(S sb lb _) -> Left (sb +: lb, [err])
Applicative instance: 


instance Applicative Parser where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mrm-0.1.0.0/src/Data/Match/Effects.hs
Monad instance: 


instance (fs <: fs) => Monad (Free fs) where
    return         = Free . inn . Pure
    (Free p) >>= f = fold ((\(Pure x) -> f x) :::
                           transFree) p
Applicative instance: 

instance (Monad (Free fs), Functor (Free fs)) => Applicative (Free fs) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/comfort-graph-0.0.1/src/Data/Graph/Comfort/TotalMap.hs
Applicative instance: 


instance (Ord k) => Applicative (TotalMap k) where
   pure a = TotalMap a Map.empty
   TotalMap fd fm <*> TotalMap ad am =
      TotalMap (fd ad) $
         fmap ($ad) (Map.difference fm am) <>
         fmap (fd$) (Map.difference am fm) <>
         Map.intersectionWith ($) fm am
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gsasl-0.3.6/lib/Network/Protocol/SASL/GNU.hs
Applicative instance: 


instance Applicative SASL where
        pure = SASL . pure
        (<*>) = ap
Monad instance: 


instance Monad SASL where
        return = SASL . return
        (>>=) sasl f = SASL $ unSASL sasl >>= unSASL . f
Applicative instance: 


instance Applicative Session where
        pure = Session . pure
        (<*>) = ap
Monad instance: 


instance Monad Session where
        return = Session . return
        (>>=) m f = Session $ unSession m >>= unSession . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pdfinfo-1.5.4/src/Text/PDF/Info.hs
Applicative instance: 

instance Applicative ParsePDFInfo where (<*>) = ap; pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fay-0.9.2.0/tests/Monad2.hs
Monad instance: 

instance Monad (State a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/biohazard-0.6.6.1/tools/bam-fixpair.hs
Applicative instance: 


instance Applicative (Mating r m) where
    pure a = Mating $ \k -> k a
    u <*> v = Mating $ \k -> runMating u (\a -> runMating v (k . a))
Monad instance: 


instance Monad (Mating r m) where
    return a = Mating $ \k -> k a
    m >>=  k = Mating $ \k2 -> runMating m (\a -> runMating (k a) k2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/biohazard-0.6.6.1/src/Bio/Bam/Pileup.hs
Applicative instance: 


instance Applicative (PileM m) where
    {-# INLINE pure #-}
    pure a = PileM $ \k -> k a
    {-# INLINE (<*>) #-}
    u <*> v = PileM $ \k -> runPileM u (\a -> runPileM v (k . a))
Monad instance: 


instance Monad (PileM m) where
    {-# INLINE return #-}
    return a = PileM $ \k -> k a
    {-# INLINE (>>=) #-}
    m >>=  k = PileM $ \k' -> runPileM m (\a -> runPileM (k a) k')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/biohazard-0.6.6.1/src/Data/Avro.hs
Applicative instance: 

instance Applicative MkSchema where pure a = MkSchema (\k -> k a)
                                    u <*> v = MkSchema (\k -> mkSchema u (\a -> mkSchema v (k . a)))
Monad instance: 

instance Monad MkSchema where return a = MkSchema (\k -> k a)
                              a >>= m = MkSchema (\k -> mkSchema a (\a' -> mkSchema (m a') k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sifflet-lib-2.2.1/Language/Sifflet/Util.hs
Monad instance: 


instance Monad SuccFail where
  Succ val >>= f = f val
  Fail err >>= _f = Fail err
  return = Succ
  fail = Fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sifflet-lib-2.2.1/Language/Sifflet/Expr.hs
Monad instance: 


instance Monad EvalRes where
  EvalOk value >>= f = f value
  EvalError e >>= _f = EvalError e
  EvalUntried >>= _f = EvalUntried
  return = EvalOk
  fail = EvalError
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uni-util-2.3.0.1/Util/BinaryUtils.hs
Applicative instance: 


instance Applicative m => Applicative (ArgMonad arg m) where
   pure v = ArgMonad (const (pure v))
   ArgMonad fn1 <*> ArgMonad fn2 =
      let
         fn arg = fn1 arg <*> fn2 arg
      in
         ArgMonad fn
Monad instance: 


instance Monad m => Monad (ArgMonad arg m) where
   (>>=) (ArgMonad fn1) getArgMonad =
      let
         fn arg =
            do
               v1 <- fn1 arg
               let
                  (ArgMonad fn2) = getArgMonad v1
               fn2 arg
      in
         ArgMonad fn

   return v = ArgMonad (const (return v))

   fail s = ArgMonad (const (fail s))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uni-util-2.3.0.1/Util/Computation.hs
Applicative instance: 


instance Applicative WithError where
   pure = return
   (<*>) = ap
Monad instance: 


instance Monad WithError where
   return v = hasValue v
   (>>=) aWE toBWe =
      mapWithError' toBWe aWE
   fail s = hasError s
Applicative instance: 


instance Monad m => Applicative (MonadWithError m) where
   pure = return
   (<*>) = ap
Monad instance: 


instance Monad m => Monad (MonadWithError m) where
   return v = MonadWithError (return (Value v))
   (>>=) (MonadWithError act1) getAct2 =
      MonadWithError (
         do
            valWithError <- act1
            case valWithError of
               Value v ->
                  let
                     (MonadWithError act2) = getAct2 v
                  in
                     act2
               Error s -> return (Error s)
         )
   fail s = MonadWithError (return (Error s))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uni-util-2.3.0.1/Util/Sources.hs
Applicative instance: 


instance Applicative SimpleSource where
   pure = return
   (<*>) = ap
Monad instance: 


instance Monad SimpleSource where
   return x = SimpleSource (staticSource x)
   (>>=) (SimpleSource source1) getSimpleSource2 =
      let
         getSource2 x =
            let
               (SimpleSource source2) = getSimpleSource2 x
            in
               source2
      in
         SimpleSource (seqSource source1 getSource2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/comonad-random-0.1.2/Control/Comonad/Random.hs
Applicative instance: 


instance Applicative Three where
    pure x = Three (x, x, x)
    Three ~(f, g, h) <*> Three ~(x, y, z) = Three (f x, g y, h z)
Applicative instance: 


instance Applicative Rand where
    pure x = let tree = cofree x $ Three (tree, tree, tree)
             in Rand tree
    Rand a <*> Rand b = let ~(f, fs) = runCofree a
                            ~(x, xs) = runCofree b
                        in Rand . cofree (f x) . fmap unRand .
                           liftA2 (<*>) (fmap Rand fs) . fmap Rand $ xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HoleyMonoid-0.1.1/Data/HoleyMonoid.hs
Applicative instance: 


instance Applicative (HoleyMonoid m r) where
  pure x = HoleyMonoid (pure x)
  HoleyMonoid f <*> HoleyMonoid g = HoleyMonoid (f <*> g)
Monad instance: 


instance Monad (HoleyMonoid m r) where
  return x = HoleyMonoid (return x)
  HoleyMonoid f >>= g = HoleyMonoid (f >>= \x -> runHM (g x))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Frames-0.1.6/src/Frames/Frame.hs
Applicative instance: 


instance Applicative Frame where
  -- | A frame of 'maxBound' rows, each of which is the given value.
  pure x = Frame maxBound (const x)
  -- | Zips two 'Frame's together, applying the rows of the first to
  -- those of the second. The result has as many rows as the smaller
  -- of the two argument 'Frame's.
  Frame l1 f1 <*> Frame l2 f2 = Frame (min l1 l2) $ ($) <$> f1 <*> f2
Monad instance: 


instance Monad Frame where
  -- | A frame of 'maxBound' rows, each of which is the given value.
  return = pure
  -- | Like 'concatMap' for lists.
  Frame l f >>= fb = foldMap (fb . f) [0 .. l - 1]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghc-exactprint-0.5.2.1/tests/examples/ghc8/T5908.hs
Monad instance: 


instance (Category w, Prelude.Monad m) => Monad (WriterT w m) where
  return a = WriterT $ return (a, id)
    where
      return = Prelude.return
  m >>= k = WriterT $ do
    ~(a, w) <- runWriterT m
    ~(b, w') <- runWriterT (k a)
    return (b, w >>> w')
    where
      (>>=) = (Prelude.>>=)
      return = Prelude.return
  fail msg = WriterT $ fail msg
    where
      fail = Prelude.fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghc-exactprint-0.5.2.1/tests/examples/ghc8/T10753.hs
Monad instance: 

instance (Monad m) => Monad (StateT s m) where
Applicative instance: 

instance (Functor m, Monad m) => Applicative (StateT s m) where
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghc-exactprint-0.5.2.1/tests/examples/ghc8/T11128.hs
Applicative instance: 


instance A.Applicative T0 where
    pure   = T0
    (<*>)  = M.ap
Monad instance: 


instance M.Monad T0 where
    (>>=)  = undefined
Applicative instance: 


instance A.Applicative T1 where
    pure   = return
    (<*>)  = M.ap
    (*>)   = (M.>>)
Monad instance: 


instance M.Monad T1 where
    (>>=)  = undefined
    return = T1
    (>>)   = undefined
Applicative instance: 


instance Applicative T2 where
    pure   = T2
    (<*>)  = ap
    (*>)   = undefined
Monad instance: 


instance M.Monad T2 where
    (>>=)  = undefined
    return = pure
    (>>)   = (*>)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghc-exactprint-0.5.2.1/tests/examples/ghc8/MonadFailWarningsDisabled.hs
Applicative instance: 

instance Applicative Maybe' where pure = undefined; (<*>) = undefined
Monad instance: 

instance Monad Maybe' where (>>=) = undefined
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghc-exactprint-0.5.2.1/tests/examples/ghc8/MonadFailWarnings.hs
Applicative instance: 

instance Applicative Maybe' where pure = undefined; (<*>) = undefined
Monad instance: 

instance Monad Maybe' where (>>=) = undefined
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghc-exactprint-0.5.2.1/tests/examples/ghc710/Undefined4.hs
Applicative instance: 


instance Applicative (StateL s) where
    pure x = StateL (\ s -> (s, x))
    StateL kf <*> StateL kv = StateL $ \ s ->
        let (s', f) = kf s
            (s'', v) = kv s'
        in (s'', f v)
Applicative instance: 


instance Applicative (StateR s) where
    pure x = StateR (\ s -> (s, x))
    StateR kf <*> StateR kv = StateR $ \ s ->
        let (s', v) = kv s
            (s'', f) = kf s'
        in (s'', f v)
Applicative instance: 


instance Applicative Id where
    pure = Id
    Id f <*> Id x = Id (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghc-exactprint-0.5.2.1/tests/examples/ghc710/Expr.hs
Monad instance: 

instance Monad (CharParser a) where
Applicative instance: 

instance Applicative (CharParser a) where
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ampersand-3.1.0/src/Database/Design/Ampersand/ADL1/Disambiguate.hs
Applicative instance: 

instance Applicative Change where
 (<*>) (Change f b) (Change a b2) = Change (f a) (b && b2)
 pure a = Change a True
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ampersand-3.1.0/src/Database/Design/Ampersand/Input/ADL1/LexerMonad.hs
Monad instance: 


instance Monad LexerMonad where
    (>>=) = bindLM
    return = returnLM
Applicative instance: 


instance Applicative LexerMonad where
    pure = returnLM
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ampersand-3.1.0/src/Database/Design/Ampersand/Input/ADL1/CtxError.hs
Applicative instance: 


instance Applicative Guarded where
 pure = Checked
 (<*>) (Checked f) (Checked a) = Checked (f a)
 (<*>) (Errors  a) (Checked _) = Errors a
 (<*>) (Checked _) (Errors  b) = Errors b
 (<*>) (Errors  a) (Errors  b) = Errors (a ++ b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/supplemented-0.5.1/library/Supplemented.hs
Applicative instance: 


instance Monad m => Applicative (Supplemented m) where
  {-# INLINE pure #-}
  pure a =
    Supplemented (Left (a, pure ()))
  {-# INLINABLE [2] (<*>) #-}
  (<*>) (Supplemented either1) (Supplemented either2) =
    {-# SCC "(<*>)" #-}
    Supplemented either3
    where
      either3 =
        case either1 of
          Left (result1, supplement1) ->
            case either2 of
              Left (result2, supplement2) ->
                Left (result1 result2, supplement1 *> supplement2)
              Right m2 ->
                Right $
                liftM (\(result2, supplement2) -> (result1 result2, supplement2)) $
                supplement1 *> m2
          Right m1 ->
            case either2 of
              Left (result2, supplement2) ->
                Right $
                liftM (\(result1, supplement1) -> (result1 result2, supplement1 *> supplement2)) $
                m1
              Right m2 ->
                Right $
                do
                  (result1, supplement1) <- m1
                  supplement1
                  (result2, supplement2) <- m2
                  return (result1 result2, supplement2)
Monad instance: 


instance Monad m => Monad (Supplemented m) where
  {-# INLINE return #-}
  return =
    pure
  {-# INLINABLE (>>=) #-}
  (>>=) (Supplemented either1) k2 =
    {-# SCC "(>>=)" #-}
    Supplemented either3
    where
      either3 =
        case either1 of
          Left (result1, supplement1) ->
            case k2 result1 of
              Supplemented either2 ->
                case either2 of
                  Left (result2, supplement2) ->
                    Left (result2, supplement1 *> supplement2)
                  Right m2 ->
                    Right (supplement1 *> m2)
          Right m1 ->
            Right $
            do
              (result1, supplement1) <- m1
              case k2 result1 of
                Supplemented either2 ->
                  case either2 of
                    Left (result2, supplement2) ->
                      return (result2, supplement1 *> supplement2)
                    Right m2 ->
                      do
                        supplement1
                        m2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/nanoparsec-0.1.1/Data/Nanoparsec/Internal.hs
Applicative instance: 


instance Monoid δ ⇒ Applicative (Parser δ) where
    pure = return
    {-# INLINE pure #-}
    {-# SPECIALIZE pure ∷ a → Parser B.ByteString a #-}
    {-# SPECIALIZE pure ∷ a → Parser LB.ByteString a #-}
    (<*>) = ap
    {-# INLINE (<*>) #-}
    {-# SPECIALIZE (<*>) ∷ Parser B.ByteString (a → b) → Parser B.ByteString a → Parser B.ByteString b #-}
    {-# SPECIALIZE (<*>) ∷ Parser LB.ByteString (a → b) → Parser LB.ByteString a → Parser LB.ByteString b #-}
    (*>) = (>>)
    {-# INLINE (*>) #-}
    {-# SPECIALIZE (*>) ∷ Parser B.ByteString a → Parser B.ByteString b → Parser B.ByteString b #-}
    {-# SPECIALIZE (*>) ∷ Parser LB.ByteString a → Parser LB.ByteString b → Parser LB.ByteString b #-}
    x <* y = x >>= \a → y >> return a
    {-# INLINE (<*) #-}
    {-# SPECIALIZE (<*) ∷ Parser B.ByteString a → Parser B.ByteString b → Parser B.ByteString a #-}
    {-# SPECIALIZE (<*) ∷ Parser LB.ByteString a → Parser LB.ByteString b → Parser LB.ByteString a #-}
Monad instance: 


instance Monoid δ ⇒ Monad (Parser δ) where
    return x = Parser $ \s _ su → su x s
    {-# INLINE return #-}
    {-# SPECIALIZE return ∷ a → Parser B.ByteString a #-}
    {-# SPECIALIZE return ∷ a → Parser LB.ByteString a #-}
    Parser p >>= g
        = Parser $ \s fa su → p s fa (\a s' → runParser (g a) s' fa su)
    {-# INLINE (>>=) #-}
    {-# SPECIALIZE (>>=) ∷ Parser B.ByteString a → (a → Parser B.ByteString b) → Parser B.ByteString b #-}
    {-# SPECIALIZE (>>=) ∷ Parser LB.ByteString a → (a → Parser LB.ByteString b) → Parser LB.ByteString b #-}
    Parser p >> Parser r
        = Parser $ \s fa su → p s fa (\_ s' → r s' fa su)
    {-# INLINE (>>) #-}
    {-# SPECIALIZE (>>) ∷ Parser B.ByteString a → Parser B.ByteString b → Parser B.ByteString b #-}
    {-# SPECIALIZE (>>) ∷ Parser LB.ByteString a → Parser LB.ByteString b → Parser LB.ByteString b #-}
    fail err = Parser (\s fa _ → fa s [] ("Failed reading: " ++ err))
    {-# INLINE fail #-}
    {-# SPECIALIZE fail ∷ String → Parser B.ByteString a #-}
    {-# SPECIALIZE fail ∷ String → Parser LB.ByteString a #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/MonadPrompt-1.0.0.5/Control/Monad/Prompt.hs
Monad instance: 


instance Monad (Prompt p) where
    return a = Prompt $ \done _   -> done a
    f >>= g  = Prompt $ \done prm -> runP f (\x -> runP (g x) done prm) prm
Applicative instance: 


instance Applicative (Prompt p) where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad (RecPrompt p) where
    return  = RecPrompt . return
    m >>= f = RecPrompt $ unRecPrompt m >>= (unRecPrompt . f)
Applicative instance: 


instance Applicative (RecPrompt p) where
    pure    = return
    (<*>)   = ap
Monad instance: 


instance Monad (PromptT p m) where
   return  = PromptT . return
   m >>= f = PromptT $ unPromptT m >>= (unPromptT . f)
Applicative instance: 


instance Applicative (PromptT p m) where
   pure    = return
   (<*>)   = ap
Monad instance: 


instance Monad (RecPromptT p m) where
   return  = RecPromptT . return
   m >>= f = RecPromptT $ unRecPromptT m >>= (unRecPromptT . f)
Applicative instance: 


instance Applicative (RecPromptT p m) where
   pure    = return
   (<*>)   = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/diagrams-rubiks-cube-0.2.0.0/src/Diagrams/RubiksCube/Model.hs
Applicative instance: 


instance Applicative Vec3 where
  pure v = Vec3 v v v
  Vec3 f1 f2 f3 <*> Vec3 v1 v2 v3 =
    Vec3 (f1 v1) (f2 v2) (f3 v3)
Applicative instance: 


instance Applicative Vec4 where
  pure v = Vec4 v v v v
  Vec4 f1 f2 f3 f4 <*> Vec4 v1 v2 v3 v4 =
    Vec4 (f1 v1) (f2 v2) (f3 v3) (f4 v4)
Applicative instance: 


instance  Applicative Side where
  pure v = Side v v v v v v v v v
  Side f1 f2 f3 f4 f5 f6 f7 f8 f9 <*> Side v1 v2 v3 v4 v5 v6 v7 v8 v9 =
    Side (f1 v1) (f2 v2) (f3 v3) (f4 v4) (f5 v5) (f6 v6) (f7 v7) (f8 v8) (f9 v9)
Applicative instance: 


instance Applicative Cube where
  pure v = Cube v v v v v v
  Cube ff fb fl fr fu fd <*> Cube vf vb vl vr vu vd =
    Cube (ff vf) (fb vb) (fl vl) (fr vr) (fu vu) (fd vd)
Applicative instance: 


instance Applicative RubiksCube where
  pure = RubiksCube . pure . pure
  RubiksCube f <*> RubiksCube v = RubiksCube ((<*>) <$> f <*> v)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bearriver-0.10.4/src/FRP/BearRiver.hs
Applicative instance: 


instance Applicative Event where
  pure = Event

  Event f <*> Event x = Event (f x)
  _       <*> _       = NoEvent
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sylvia-0.2.2/Sylvia/Model.hs
Applicative instance: 


instance Applicative Inc where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad Inc where
    return = S
    val >>= f = joinI (mapI f val)
Applicative instance: 


instance Applicative Exp where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad Exp where
    return = Ref
    e >>= f = joinE (mapE f e)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sylvia-0.2.2/Sylvia/Render/Pair.hs
Applicative instance: 


instance Applicative P where
    pure x = x :| x
    f :| g <*> x :| y = f x :| g y
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SimpleGL-0.9.3/src/SimpleH/GL/Base.hs
Applicative instance: 

instance Applicative V2 where
  V2 fx fy <*> V2 x y = V2 (fx x) (fy y)
Applicative instance: 

instance Applicative V3 where
  V3 fx fy fz <*> V3 x y z = V3 (fx x) (fy y) (fz z)
Applicative instance: 

instance Applicative V4 where
  V4 fx fy fz fw <*> V4 x y z w = V4 (fx x) (fy y) (fz z) (fw w)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SimpleGL-0.9.3/src/SimpleH/GL.hs
Applicative instance: 

instance Applicative Vector3 where
  Vector3 fx fy fz <*> Vector3 x y z = Vector3 (fx x) (fy y) (fz z)
Applicative instance: 

instance Applicative Vertex3 where
  Vertex3 fx fy fz <*> Vertex3 x y z = Vertex3 (fx x) (fy y) (fz z)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/future-resource-0.4.0.0/Control/Future.hs
Applicative instance: 


instance Monoid a => Applicative (Future a) where
        pure = Future . return . Finished
        Future fs <*> Future as =
                Future $ do
                        fs' <- fs
                        as' <- as
                        return $ case (fs', as') of
                                (Finished f, Finished a) -> Finished $ f a
                                (Fixme f, Finished _) -> Fixme f
                                (Finished _, Fixme a) -> Fixme a
                                (Fixme f, Fixme a) -> Fixme (f `mappend` a)
                                _ -> Making
Monad instance: 


instance Monoid a => Monad (Future a) where
        return = pure
        Future m >>= f =
                Future $ do
                        m' <- m
                        case m' of
                                Finished x -> runFuture (f x)
                                Fixme l -> return (Fixme l)
                                Making -> return Making
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/stochastic-0.1.1.1/src/Data/Stochastic/Types.hs
Monad instance: 


-- | Monad instance for Sample.
instance (RandomGen g, Sampleable d) => Monad (Sample g d) where
    return x = Sample $ do
                modify (snd . next)
                return $ certainDist x

    (>>=) ma f = Sample $ do
                     modify (snd . next)
                     dist <- runSample ma
                     g <- get
                     let a = fst $ sampleFrom dist g
                     runSample (f a)
Applicative instance: 


-- | Trivial 'Applicative' instance for 'Sample' 'StdGen' 'Distribution'.
instance (RandomGen g, Sampleable s) => Applicative (Sample g s) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lens-4.9.1/src/Control/Lens/Reified.hs
Applicative instance: 


instance Applicative (ReifiedGetter s) where
  pure a = Getter $ to $ \_ -> a
  {-# INLINE pure #-}
  Getter mf <*> Getter ma = Getter $ to $ \s -> view mf s (view ma s)
  {-# INLINE (<*>) #-}
  m <* _ = m
  {-# INLINE (<*) #-}
  _ *> m = m
  {-# INLINE (*>) #-}
Monad instance: 


instance Monad (ReifiedGetter s) where
  return a = Getter $ to $ \_ -> a
  {-# INLINE return #-}
  Getter ma >>= f = Getter $ to $ \s -> view (runGetter (f (view ma s))) s
  {-# INLINE (>>=) #-}
Applicative instance: 


instance Applicative (ReifiedFold s) where
  pure a = Fold $ folding $ \_ -> [a]
  {-# INLINE pure #-}
  Fold mf <*> Fold ma = Fold $ folding $ \s -> toListOf mf s <*> toListOf ma s
  {-# INLINE (<*>) #-}
  Fold mf <* Fold ma = Fold $ folding $ \s -> toListOf mf s <* toListOf ma s
  {-# INLINE (<*) #-}
  Fold mf *> Fold ma = Fold $ folding $ \s -> toListOf mf s *> toListOf ma s
  {-# INLINE (*>) #-}
Monad instance: 


instance Monad (ReifiedFold s) where
  return a = Fold $ folding $ \_ -> [a]
  {-# INLINE return #-}
  Fold ma >>= f = Fold $ folding $ \s -> toListOf ma s >>= \a -> toListOf (runFold (f a)) s
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lens-4.9.1/src/Control/Lens/Internal/Level.hs
Applicative instance: 


-- | This is an illegal 'Applicative'.
instance Applicative (Flows i b) where
  pure a = Flows (const a)
  {-# INLINE pure #-}
  Flows mf <*> Flows ma = Flows $ \ xss -> case xss of
    []             -> mf [] (ma [])
    (_:xs)         -> mf (triml <$> xs) $ ma (trimr <$> xs)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lens-4.9.1/src/Control/Lens/Internal/Magma.hs
Applicative instance: 


instance Applicative (Molten i a b) where
  pure  = Molten #. MagmaPure
  {-# INLINE pure #-}
  Molten xs <*> Molten ys = Molten (MagmaAp xs ys)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative (Mafic a b) where
  pure a = Mafic 0 $ \_ -> MagmaPure a
  {-# INLINE pure #-}
  Mafic wf mf <*> ~(Mafic wa ma) = Mafic (wf + wa) $ \o -> MagmaAp (mf o) (ma (o + wf))
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative (TakingWhile p f a b) where
  pure a = TakingWhile True a $ \_ -> MagmaPure a
  {-# INLINE pure #-}
  TakingWhile wf tf mf <*> ~(TakingWhile wa ta ma) = TakingWhile (wf && wa) (tf ta) $ \o ->
    if o then MagmaAp (mf True) (ma wf) else MagmaPure (tf ta)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lens-4.9.1/src/Control/Lens/Internal/Deque.hs
Applicative instance: 


instance Applicative Deque where
  pure a = BD 1 [a] 0 []
  {-# INLINE pure #-}
  fs <*> as = fromList (toList fs <*> toList as)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Deque where
  return a = BD 1 [a] 0 []
  {-# INLINE return #-}
  ma >>= k = fromList (toList ma >>= toList . k)
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lens-4.9.1/src/Control/Lens/Internal/Zoom.hs
Applicative instance: 


instance (Monad m, Monoid s) => Applicative (Focusing m s) where
  pure a = Focusing (return (mempty, a))
  {-# INLINE pure #-}
  Focusing mf <*> Focusing ma = Focusing $ do
    (s, f) <- mf
    (s', a) <- ma
    return (mappend s s', f a)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance (Monad m, Monoid s, Monoid w) => Applicative (FocusingWith w m s) where
  pure a = FocusingWith (return (mempty, a, mempty))
  {-# INLINE pure #-}
  FocusingWith mf <*> FocusingWith ma = FocusingWith $ do
    (s, f, w) <- mf
    (s', a, w') <- ma
    return (mappend s s', f a, mappend w w')
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative (k (s, w)) => Applicative (FocusingPlus w k s) where
  pure = FocusingPlus . pure
  {-# INLINE pure #-}
  FocusingPlus kf <*> FocusingPlus ka = FocusingPlus (kf <*> ka)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative (k (f s)) => Applicative (FocusingOn f k s) where
  pure = FocusingOn . pure
  {-# INLINE pure #-}
  FocusingOn kf <*> FocusingOn ka = FocusingOn (kf <*> ka)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative (k (May s)) => Applicative (FocusingMay k s) where
  pure = FocusingMay . pure
  {-# INLINE pure #-}
  FocusingMay kf <*> FocusingMay ka = FocusingMay (kf <*> ka)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative (k (Err e s)) => Applicative (FocusingErr e k s) where
  pure = FocusingErr . pure
  {-# INLINE pure #-}
  FocusingErr kf <*> FocusingErr ka = FocusingErr (kf <*> ka)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance (Monad m, Monoid r) => Applicative (Effect m r) where
  pure _ = Effect (return mempty)
  {-# INLINE pure #-}
  Effect ma <*> Effect mb = Effect (liftM2 mappend ma mb)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance (Monoid s, Monoid w, Monad m) => Applicative (EffectRWS w st m s) where
  pure _ = EffectRWS $ \st -> return (mempty, st, mempty)
  {-# INLINE pure #-}
  EffectRWS m <*> EffectRWS n = EffectRWS $ \st -> m st >>= \ (s,t,w) -> n t >>= \ (s',u,w') -> return (mappend s s', u, mappend w w')
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lens-4.9.1/src/Control/Lens/Internal/Bazaar.hs
Applicative instance: 


instance Applicative (Bazaar p a b) where
  pure a = Bazaar $ \_ -> pure a
  {-# INLINE pure #-}
  Bazaar mf <*> Bazaar ma = Bazaar $ \ pafb -> mf pafb <*> ma pafb
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative (BazaarT p g a b) where
  pure a = BazaarT $ tabulate $ \_ -> pure (pure a)
  {-# INLINE pure #-}
  BazaarT mf <*> BazaarT ma = BazaarT $ \ pafb -> mf pafb <*> ma pafb
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lens-4.9.1/src/Control/Lens/Internal/Indexed.hs
Applicative instance: 


instance Applicative (Indexed i a) where
  pure b = Indexed $ \_ _ -> b
  {-# INLINE pure #-}
  Indexed f <*> Indexed g = Indexed $ \i a -> f i a (g i a)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad (Indexed i a) where
  return b = Indexed $ \_ _ -> b
  {-# INLINE return #-}
  Indexed f >>= k = Indexed $ \i a -> runIndexed (k (f i a)) i a
  {-# INLINE (>>=) #-}
Applicative instance: 


instance Applicative f => Applicative (Indexing f) where
  pure x = Indexing $ \i -> (i, pure x)
  {-# INLINE pure #-}
  Indexing mf <*> Indexing ma = Indexing $ \i -> case mf i of
    (j, ff) -> case ma j of
       ~(k, fa) -> (k, ff <*> fa)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative f => Applicative (Indexing64 f) where
  pure x = Indexing64 $ \i -> (i, pure x)
  {-# INLINE pure #-}
  Indexing64 mf <*> Indexing64 ma = Indexing64 $ \i -> case mf i of
    (j, ff) -> case ma j of
       ~(k, fa) -> (k, ff <*> fa)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lambdabot-core-5.1/src/Lambdabot/Command.hs
Applicative instance: 

instance Applicative f => Applicative (Cmd f) where
    pure = Cmd . pure
    Cmd f <*> Cmd x = Cmd (f <*> x)
Monad instance: 

instance Monad m => Monad (Cmd m) where
    return = Cmd . return
    Cmd x >>= f = Cmd (x >>= (unCmd . f))
    fail = lift . fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/blaze-builder-0.4.0.2/benchmarks/UnboxedAppend.hs
Monad instance: 


instance Monad Put where
  return x = Put $ \k -> k x
  {-# INLINE return #-}
  m >>= f  = Put $ \k -> unPut m (\x -> unPut (f x) k)
  {-# INLINE (>>=) #-}
  m >>  n  = Put $ \k -> unPut m (\_ -> unPut n k)
  {-# INLINE (>>) #-}
Monad instance: 


instance Monad LBSM where
    return x                       = LBSM (x, id)
    (LBSM (x,k)) >>= f             = let LBSM (x',k') = f x in LBSM (x', k . k')
    (LBSM (_,k)) >> (LBSM (x',k')) = LBSM (x', k . k')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/blaze-builder-0.4.0.2/benchmarks/Throughput/BlazePutMonad.hs
Applicative instance: 


instance Applicative PutM where
        pure    = return
        m <*> k = Put $
            let PairS f w  = unPut m
                PairS x w' = unPut k
            in PairS (f x) (w `mappend` w')
Monad instance: 


-- Standard Writer monad, with aggressive inlining
instance Monad PutM where
    return a = Put $ PairS a mempty
    {-# INLINE return #-}

    m >>= k  = Put $
        let PairS a w  = unPut m
            PairS b w' = unPut (k a)
        in PairS b (w `mappend` w')
    {-# INLINE (>>=) #-}

    m >> k  = Put $
        let PairS _ w  = unPut m
            PairS b w' = unPut k
        in PairS b (w `mappend` w')
    {-# INLINE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/blaze-builder-0.4.0.2/benchmarks/FastPut.hs
Monad instance: 


instance Monad Put where
  return x = Put $ \k -> k x
  {-# INLINE return #-}
  m >>= f  = Put $ \k -> unPut m (\x -> unPut (f x) k)
  {-# INLINE (>>=) #-}
  m >>  n  = Put $ \k -> unPut m (\_ -> unPut n k)
  {-# INLINE (>>) #-}
Monad instance: 


instance Monad LBSM where
    return x                       = LBSM (x, id)
    (LBSM (x,k)) >>= f             = let LBSM (x',k') = f x in LBSM (x', k . k')
    (LBSM (_,k)) >> (LBSM (x',k')) = LBSM (x', k . k')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/grapefruit-frp-0.1.0.5/src/Internal/Signal/Discrete/Capsule.hs
Applicative instance: 


    instance Applicative Capsule where

        pure = Capsule

        Capsule fun <*> Capsule arg = Capsule (fun arg)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/midi-0.2.2.1/src/Sound/MIDI/Parser/File.hs
Applicative instance: 


instance Applicative T where
   pure = return
   (<*>) = ap
Monad instance: 


instance Monad T where
   return = Cons . return
   x >>= y = Cons $ decons . y =<< decons x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/midi-0.2.2.1/src/Sound/MIDI/Parser/Restricted.hs
Applicative instance: 


instance (Applicative parser, Monad parser) => Applicative (T parser) where
   pure = Cons . pure
   Cons f <*> Cons a = Cons $ f <*> a
Monad instance: 


instance Monad parser => Monad (T parser) where
   return = Cons . return
   x >>= y = Cons $ decons . y =<< decons x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/midi-0.2.2.1/src/Sound/MIDI/Parser/ByteString.hs
Applicative instance: 


instance Applicative T where
   pure = return
   (<*>) = ap
Monad instance: 


instance Monad T where
   return = Cons . return
   x >>= y = Cons $ decons . y =<< decons x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/midi-0.2.2.1/parser/Sound/MIDI/Parser/Stream.hs
Applicative instance: 


instance Applicative (T str) where
   pure = return
   (<*>) = ap
Monad instance: 


instance Monad (T str) where
   return = Cons . return
   x >>= y = Cons $ decons . y =<< decons x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bits-0.5/src/Data/Bits/Coding.hs
Applicative instance: 


instance Monad m => Applicative (Coding m) where
  pure a = Coding $ \k -> k a
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad m => Monad (Coding m) where
  return = pure
  {-# INLINE return #-}
  Coding m >>= f = Coding $ \ k -> m $ \a -> runCoding (f a) k
  {-# INLINE (>>=) #-}
  fail e = Coding $ \_ _ _ -> fail e
  {-# INLINE fail #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uhc-util-0.1.6.6/src/UHC/Util/CompileRun.hs
Applicative instance: 


instance CompileRunner state n pos loc u i e m => Applicative (CompilePhaseT n u i e m) where
    pure  = return
    (<*>) = ap
Monad instance: 


-- instance CompileRunner state n pos loc u i e m where

instance CompileRunner state n pos loc u i e m => Monad (CompilePhaseT n u i e m) where
  return x = CompilePhaseT $ return x -- \cr -> return (x, cr)
  cp >>= f = CompilePhaseT $ do -- \cr1 -> do
        x <- cpHandleErr' $ runCompilePhaseT cp -- (x,cr2) <- runCompilePhaseT cp cr1
{-        
        let modf f = do {modify f ; return x}
        cr <- get
        case crState cr of
          CRSFailErrL about es mbLim
            -> do { let (showErrs,omitErrs) = maybe (es,[]) (flip splitAt es) mbLim
                  ; liftIO (unless (null about) (hPutPPLn stderr (pp about)))
                  ; liftIO $ unless (null showErrs) $ 
                           do { hPutPPLn stderr (crePPErrL showErrs)
                              ; unless (null omitErrs) $ hPutStrLn stderr "... and more errors"
                              ; hFlush stderr
                              }
                  ; if creAreFatal es then liftIO exitFailure else modf crSetOk
                  }
          CRSErrInfoL about doPrint is
            -> do { if null is
                    then return x
                    else liftIO (do { hFlush stdout
                                    ; hPutPPLn stderr (about >#< "found errors" >-< e)
                                    ; return x
                                    })
                  ; if not (null is) then liftIO exitFailure else return x
                  }
            where e = empty -- if doPrint then crePPErrL is else empty
          CRSFailMsg msg
            -> do { liftIO $ hPutStrLn stderr msg
                  ; liftIO exitFailure
                  }
          CRSFail
            -> do { liftIO exitFailure
                  }
          CRSStop
            -> do { liftIO $ exitWith ExitSuccess
                  }
          _ -> return x
-}
        cr <- get
        case crState cr of
          CRSOk         -> runCompilePhaseT (f x)
          CRSStopSeq    -> do { modify crSetOk ; ME.throwError CRSStopSeq }
          CRSStopAllSeq -> do { modify crSetStopAllSeq ; ME.throwError CRSStopAllSeq }
          crs           -> ME.throwError crs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uhc-util-0.1.6.6/src/UHC/Util/CompileRun3.hs
Applicative instance: 


instance CompileRunner state n pos loc u i e m => Applicative (CompilePhaseT n u i e m) where
    pure  = return
    (<*>) = ap
Monad instance: 


-- instance CompileRunner state n pos loc u i e m where

instance CompileRunner state n pos loc u i e m => Monad (CompilePhaseT n u i e m) where
  return x = CompilePhaseT $ return x -- \cr -> return (x, cr)
  cp >>= f = CompilePhaseT $ do -- \cr1 -> do
        x <- {- cpHandleErr' $ -} runCompilePhaseT cp -- (x,cr2) <- runCompilePhaseT cp cr1
        let modf f = do {modify f ; return x}
        cr <- get
        case _crState cr of
          CRSFailErrL about es mbLim
            -> do { let (showErrs,omitErrs) = maybe (es,[]) (flip splitAt es) mbLim
                  ; liftIO (unless (null about) (hPutPPLn stderr (pp about)))
                  ; liftIO $ unless (null showErrs) $
                           do { hPutPPLn stderr (crePPErrL showErrs)
                              ; unless (null omitErrs) $ hPutStrLn stderr "... and more errors"
                              ; hFlush stderr
                              }
                  ; if creAreFatal es then liftIO exitFailure else modf crSetOk
                  }
          CRSErrInfoL about doPrint is
            -> do { if null is
                    then return x
                    else liftIO (do { hFlush stdout
                                    ; hPutPPLn stderr (about >#< "found errors" >-< e)
                                    ; return x
                                    })
                  ; if not (null is) then liftIO exitFailure else return x
                  }
            where e = empty -- if doPrint then crePPErrL is else empty
          CRSFailMsg msg
            -> do { liftIO $ hPutStrLn stderr msg
                  ; liftIO exitFailure
                  }
          CRSFail
            -> do { liftIO exitFailure
                  }
          CRSStop
            -> do { liftIO $ exitWith ExitSuccess
                  }
          _ -> return x
        cr <- get
        case _crState cr of
          CRSOk         -> runCompilePhaseT (f x)
          CRSStopSeq    -> do { modf crSetOk ; return $ panic "Monad.CompilePhaseT.CRSStopSeq" }
          CRSStopAllSeq -> do { modf crSetStopAllSeq ; return $ panic "Monad.CompilePhaseT.CRSStopAllSeq" }
          crs           -> return $ panic "Monad.CompilePhaseT._"
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uhc-util-0.1.6.6/src/UHC/Util/CompileRun2.hs
Applicative instance: 


instance CompileRunner state n pos loc u i e m => Applicative (CompilePhaseT n u i e m) where
    pure  = return
    (<*>) = ap
Monad instance: 


-- instance CompileRunner state n pos loc u i e m where

instance CompileRunner state n pos loc u i e m => Monad (CompilePhaseT n u i e m) where
  return x = CompilePhaseT $ return x -- \cr -> return (x, cr)
  cp >>= f = CompilePhaseT $ do -- \cr1 -> do
        x <- {- cpHandleErr' $ -} runCompilePhaseT cp -- (x,cr2) <- runCompilePhaseT cp cr1
        let modf f = do {modify f ; return x}
        cr <- get
        case _crState cr of
          CRSFailErrL about es mbLim
            -> do { let (showErrs,omitErrs) = maybe (es,[]) (flip splitAt es) mbLim
                  ; liftIO (unless (null about) (hPutPPLn stderr (pp about)))
                  ; liftIO $ unless (null showErrs) $
                           do { hPutPPLn stderr (crePPErrL showErrs)
                              ; unless (null omitErrs) $ hPutStrLn stderr "... and more errors"
                              ; hFlush stderr
                              }
                  ; if creAreFatal es then liftIO exitFailure else modf crSetOk
                  }
          CRSErrInfoL about doPrint is
            -> do { if null is
                    then return x
                    else liftIO (do { hFlush stdout
                                    ; hPutPPLn stderr (about >#< "found errors" >-< e)
                                    ; return x
                                    })
                  ; if not (null is) then liftIO exitFailure else return x
                  }
            where e = empty -- if doPrint then crePPErrL is else empty
          CRSFailMsg msg
            -> do { liftIO $ hPutStrLn stderr msg
                  ; liftIO exitFailure
                  }
          CRSFail
            -> do { liftIO exitFailure
                  }
          CRSStop
            -> do { liftIO $ exitWith ExitSuccess
                  }
          _ -> return x
        cr <- get
        case _crState cr of
          CRSOk         -> runCompilePhaseT (f x)
          CRSStopSeq    -> do { modf crSetOk ; return $ panic "Monad.CompilePhaseT.CRSStopSeq" }
          CRSStopAllSeq -> do { modf crSetStopAllSeq ; return $ panic "Monad.CompilePhaseT.CRSStopAllSeq" }
          crs           -> return $ panic "Monad.CompilePhaseT._"
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/casui-0.3/Casui/Menu.hs
Monad instance: 


instance Monad GenMenu where
    return = GenMenu []
    GenMenu l a >>= f = case f a of GenMenu k b -> GenMenu (l++k) b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/casui-0.3/Casui/Draw.hs
Monad instance: 


instance Monad (Draw t) where
    return a = Draw $ \_ _ _ -> return (Nothing, a)
    d >>= f = Draw $ \s c m -> do (d, a) <- drawF d s c m
                                  (e, a') <- drawF (f a) s c m
                                  return (case (d, e) of
                                            (Just x, Just y) -> Just $ m x y
                                            (Just x, _) -> Just x
                                            (_, Just y) -> Just y
                                            _ -> Nothing
                                         , a')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/casui-0.3/Casui/Casui.hs
Monad instance: 


instance Monad (Casui l) where
  (Casui f) >>= g = Casui $ \s c e -> do
    (a, e) <- f s c e
    let Casui h = g a
    h s c e
  return a = Casui $ \s c e -> return (a, e)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/parsec-permutation-0.1.2.0/Text/Parsec/Permutation.hs
Applicative instance: 


instance Stream s m t => Applicative (PermParser s u m) where
  parser1 <*> parser2 =
      PermParser (permValue parser1 <*> permValue parser2)
                 (attemptParser1 <|> attemptParser2)
    where attemptParser1 = do parser1 <- permParser parser1
                              return $ parser1 <*> parser2
          attemptParser2 = do parser2 <- permParser parser2
                              return $ parser1 <*> parser2

  pure value = PermParser (Just value) parserZero
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/active-0.2.0.9/src/Data/Active.hs
Applicative instance: 


instance Applicative Duration where
  pure = Duration
  Duration f <*> Duration x = Duration (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/IOSpec-0.3/src/Test/IOSpec/VirtualMachine.hs
Applicative instance: 


instance Applicative Effect where
  pure = Done
  (<*>) = ap
Monad instance: 


instance Monad Effect where
  return = Done
  (Done x) >>= f = f x
  (ReadChar t) >>= f = ReadChar (\c -> t c >>= f)
  (Print c t) >>= f = Print c (t >>= f)
  (Fail msg) >>= _ = Fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/IOSpec-0.3/src/Test/IOSpec/Types.hs
Applicative instance: 


instance (Functor f) => Applicative (IOSpec f) where
  pure             = Pure
  (<*>)            = ap
Monad instance: 


instance (Functor f) => Monad (IOSpec f) where
  return           = Pure
  (Pure x) >>= f   = f x
  (Impure t) >>= f = Impure (fmap (>>= f) t)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/IOSpec-0.3/src/Test/IOSpec/STM.hs
Applicative instance: 


instance Applicative STM where
  pure  = STMReturn
  (<*>) = ap
Monad instance: 


instance Monad STM where
  return                = STMReturn
  STMReturn a >>= f     = f a
  NewTVar d g >>= f     = NewTVar d (\l -> g l >>= f)
  ReadTVar l g >>= f    = ReadTVar l (\d -> g d >>= f)
  WriteTVar l d p >>= f = WriteTVar l d (p >>= f)
  Retry >>= _           = Retry
  OrElse p q >>= f      = OrElse (p >>= f) (q >>= f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hood-0.3/Debug/Hood/Observe.hs
Applicative instance: 


instance Applicative ObserverM where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad ObserverM where
        return a = ObserverM (\ c i -> (a,i))
        fn >>= k = ObserverM (\ c i ->
                case runMO fn c i of
                  (r,i2) -> runMO (k r) c i2
                )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/xmonad-0.9.2/XMonad/Core.hs
Applicative instance: 

#endif

instance Applicative X where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hspread-0.3.3/Spread/Client/Message.hs
Monad instance: 


instance (Functor m, Monad m) => Monad (Ask p m) where
    return = Result
    Ask i m >>= f = Ask i (fmap (>>= f) m)
    Result a >>= f = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sized-types-0.5.1/Data/Sized/Sparse/Matrix.hs
Applicative instance: 


instance (Bounded i, Ix i) => Applicative (SpMatrix i) where
    pure a =  SpMatrix a (Map.empty)
    sm1@(SpMatrix d1 m1) <*> sm2@(SpMatrix d2 m2)
            = SpMatrix (d1 d2) (Map.fromList [ (k, (getElem sm1  k) (getElem sm2 k)) | k <- Set.toList keys ])
        where keys = Map.keysSet m1 `Set.union` Map.keysSet m2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sized-types-0.5.1/Data/Sized/Matrix.hs
Applicative instance: 


instance (Bounded i, Ix i) => Applicative (Matrix i) where
    pure a = fmap (const a) coord   -- possible because we are a fixed size
                                    -- Also why use use newtype here.
    a <*> b = forAll $ \ i -> (a ! i) (b ! i)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/set-cover-0.0.8/src/Math/SetCover/Cuboid.hs
Applicative instance: 


instance Applicative Coords where
   pure x = Coords x x x
   Coords fx fy fz <*> Coords x y z = Coords (fx x) (fy y) (fz z)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/keys-3.11/src/Data/Key.hs
Applicative instance: 


instance Applicative (StateL s) where
  pure x = StateL (\ s -> (s, x))
  StateL kf <*> StateL kv = StateL $ \ s ->
    let (s', f) = kf s
        (s'', v) = kv s'
    in  (s'', f v)
Applicative instance: 


instance Applicative (StateR s) where
  pure x = StateR (\ s -> (s, x))
  StateR kf <*> StateR kv = StateR $ \ s ->
    let (s', v) = kv s
        (s'', f) = kf s'
    in (s'', f v)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/jmacro-rpc-0.3.2/Network/JMacroRPC/Panels.hs
Applicative instance: 


instance Applicative (Signal Hask) where
    pure x = PureSig x
    (PureSig f) <*> x = fmap f x
    f <*> (PureSig y) = fmap ($ y) f
    f <*> x = MultiSig f x (uncurry ($))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Cabal-ide-backend-1.23.0.0/Distribution/Compat/ReadP.hs
Applicative instance: 


instance Applicative (P s) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad (P s) where
  return x = Result x Fail

  (Get f)      >>= k = Get (\c -> f c >>= k)
  (Look f)     >>= k = Look (\s -> f s >>= k)
  Fail         >>= _ = Fail
  (Result x p) >>= k = k x `mplus` (p >>= k)
  (Final r)    >>= k = final [ys' | (x,s) <- r, ys' <- run (k x) s]

  fail _ = Fail
Applicative instance: 


instance Applicative (Parser r s) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad (Parser r s) where
  return x  = R (\k -> k x)
  fail _    = R (\_ -> Fail)
  R m >>= f = R (\k -> m (\a -> let R m' = f a in m' k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Cabal-ide-backend-1.23.0.0/Distribution/Simple/BuildTarget.hs
Applicative instance: 


instance Applicative Match where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Match where
  return a                = ExactMatch 0 [a]
  NoMatch      d ms >>= _ = NoMatch d ms
  ExactMatch   d xs >>= f = addDepth d
                          $ foldr matchPlus matchZero (map f xs)
  InexactMatch d xs >>= f = addDepth d .  forceInexact
                          $ foldr matchPlus matchZero (map f xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Cabal-ide-backend-1.23.0.0/Distribution/PackageDescription/Parse.hs
Applicative instance: 


#if __GLASGOW_HASKELL__ >= 710
instance (Monad m) => Applicative (StT s m) where
#else
instance (Monad m, Functor m) => Applicative (StT s m) where
#endif
    pure = return
    (<*>) = ap
Monad instance: 



instance Monad m => Monad (StT s m) where
    return a = StT (\s -> return (a,s))
    StT f >>= g = StT $ \s -> do
                        (a,s') <- f s
                        runStT (g a) s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Cabal-ide-backend-1.23.0.0/Distribution/ParseUtils.hs
Applicative instance: 


instance Applicative ParseResult where
        pure = return
        (<*>) = ap
Monad instance: 



instance Monad ParseResult where
        return = ParseOk []
        ParseFailed err >>= _ = ParseFailed err
        ParseOk ws x >>= f = case f x of
                               ParseFailed err -> ParseFailed err
                               ParseOk ws' x' -> ParseOk (ws'++ws) x'
        fail s = ParseFailed (FromString s Nothing)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HaskellForMaths-0.4.8/Math/Algebras/VectorSpace.hs
Applicative instance: 

-- Note that if f is not order-preserving, then we need to call "nf" afterwards

-- From GHC 7.10, Monad has Applicative as a superclass, so we must define an instance.
-- It doesn't particularly make sense for Vect k.
-- (Although given Vect k b, we could represent the dual space as Vect k (b -> ()),
-- and then have a use for <*>.)
instance Num k => Applicative (Vect k) where
    pure = return
    -- pure b = V [(b,1)]
    (<*>) = ap
Monad instance: 

    -- V fs <*> V xs = V [(f x, a*b) | (f,a) <- fs, (x,b) <- xs]

-- |Given a field k, the type constructor (Vect k) is a monad, the \"free k-vector space monad\".
--
-- In order to understand this, it is probably easiest to think of a free k-vector space as a kind of container,
-- a bit like a list, except that order doesn't matter, and you're allowed arbitrary (even negative or fractional)
-- quantities of the basis elements in the container.
--
-- According to this way of thinking, return is the function that puts a basis element into the vector space (container).
--
-- Given a function f from the basis of one vector space to another vector space (a -> Vect k b),
-- bind (>>=) lifts it to a function (>>= f) from the first vector space to the second (Vect k a -> Vect k b).
--
-- Note that in general (>>= f) applied to a vector will not return a result in normal form,
-- so it is usually preferable to use (linear f) instead.
instance Num k => Monad (Vect k) where
    return a = V [(a,1)]
    V ts >>= f = V $ concat [ [(b,y*x) | let V us = f a, (b,y) <- us] | (a,x) <- ts]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/interleave-1.0/Control/Alternative/Interleave.hs
Applicative instance: 


instance Alternative f => Applicative (InterleaveT f) where
  pure = NoMore
  (<*>) a b = uncurry ($) <$> (a `alongside` b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/marxup-3.0.0.1/MarXup/Text.hs
Monad instance: 


instance Monad Text where
  (>>=) = (:>>=)
  return = Return
Applicative instance: 


instance Applicative Text where
  (<*>) = ap
  pure = Return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/marxup-3.0.0.1/MarXup/Verbatim.hs
Monad instance: 


instance Monad Verbatim where
    return x = Verbatim "" x
    (Verbatim s0 x) >>= f =
        Verbatim (s0 ++ s1) y
        where Verbatim s1 y = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/shortcut-links-0.4.2.0/src/ShortcutLinks/All.hs
Applicative instance: 


instance Applicative Result where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Result where
  fail = Failure
  return = Success
  Failure x    >>= _ = Failure x
  Warning wa a >>= f = case f a of
    Success    b -> Warning wa b
    Warning wb b -> Warning (wa ++ wb) b
    Failure x    -> Failure x
  Success    a >>= f = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ginsu-0.8.2.2/CacheIO.hs
Applicative instance: 


instance Applicative CacheIO where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad CacheIO where
    {-# INLINE (>>=) #-}
    {-# INLINE return #-}
    CacheIO a >>= b = CacheIO $ a >>= \(x,cv) -> unCacheIO (b x) >>= \(y,cv') -> return  (y,cv ++ cv')
    return a = CacheIO (return (a, []))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ginsu-0.8.2.2/Boolean/Boolean.hs
Applicative instance: 


instance Applicative Boolean where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad Boolean where
    --a >> b = a && b
    a >>= f = dropBoolean (fmap f a)
    return x = BoolJust x
    fail _ = false
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ginsu-0.8.2.2/Text/ParserCombinators/ReadP/ByteString.hs
Applicative instance: 


-- Applicative

instance Applicative P where
  pure = return
  (<*>) = ap
Monad instance: 


-- Monad, MonadPlus

instance Monad (P) where
  return x = Result x Fail

  (Skip n f)   >>= k = Skip n (f >>= k)
  (Look f)     >>= k = Look (\s -> f s >>= k)
  Fail         >>= _ = Fail
  (Result x p) >>= k = k x `mplus` (p >>= k)
  (Final r)    >>= k = final [ys' | (x,s) <- r, ys' <- run (k x) s]

  fail _ = Fail
Applicative instance: 


instance Applicative (ReadP) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad (ReadP) where
  return x  = R (\k -> k x)
  fail _    = R (const Fail)
  R m >>= f = R (\k -> m (\a -> let R m' = f a in m' k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ginsu-0.8.2.2/SimpleParser.hs
Monad instance: 




instance Monad (GenParser c) where
    return a = MkP (\s -> (Just (a,s)))
    (MkP p) >>= q = MkP $ \s ->  (maybe Nothing (\(v,s') -> app (q v) s') (p s))
    fail _ = MkP $ \_ ->  Nothing
Applicative instance: 


instance Applicative (GenParser c) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/web-routes-0.27.9/Web/Routes/RouteT.hs
Applicative instance: 


instance (Applicative m) => Applicative (RouteT url m) where
  pure = liftRouteT . pure
  f <*> v = RouteT $ \ url -> unRouteT f url <*> unRouteT v url
Monad instance: 


instance (Monad m) => Monad (RouteT url m) where
    return   = liftRouteT . return
    m >>= k  = RouteT $ \ url -> do
        a <- unRouteT m url
        unRouteT (k a) url
    fail msg = liftRouteT (fail msg)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/weighted-search-0.1.0.1/Control/Monad/WeightedSearch.hs
Monad instance: 


instance (Weight w) => Monad (T w) where
    return x = Yield x Fail
    Fail >>= _ = Fail
    Yield x m >>= f = f x `mplus` (m >>= f)
    Weight w m >>= f = Weight w (m >>= f)
Applicative instance: 


instance (Weight w) => Applicative (T w) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/multifocal-0.0.1/dist/build/Language/TLT/TltParser.hs
Monad instance: 


instance Monad HappyIdentity where
    return = HappyIdentity
    (HappyIdentity p) >>= q = q p
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/primula-bot-0.0.2/ApplicativeParsec.hs
Applicative instance: 


-- The Applicative instance for every Monad looks like this.
instance Applicative (GenParser s a) where
    pure  = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rand-vars-0.1/Control/Monad/Random.hs
Monad instance: 


instance Monad Rand where
    return x = Rand (\ g -> (x, g))
    r >>= f = Rand (\ g -> let (x, g') = r `runRand` g in f x `runRand` g')
Applicative instance: 


instance Applicative Rand where
    pure = return
    f <*> x = do
        h <- f
        a <- x
        return (h a)
Applicative instance: 


instance Applicative m => Applicative (RandT m) where
    pure x = RandT (\ g -> pure (x, g))
    f <*> x = RandT (\ g -> let (g', g'') = split g in
        fmap (\ (h, g3') x -> (h x, g3')) (f `runRandT` g') <*>
        fmap fst (x `runRandT` g''))
Monad instance: 


instance Monad m => Monad (RandT m) where
    return x = RandT (\ g -> return (x, g))
    r >>= f = RandT (runRandT r >=> (\ ( x, g) -> f x `runRandT` g))
    fail err = RandT (\ _ -> fail err)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/AC-MiniTest-1.1.1/Test/AC/Private.hs
Monad instance: 


instance Monad LogM where
  return x = LogM $ \ _ -> return x

  (LogM f1) >>= fn = LogM $ \ st -> do
    x <- f1 st
    let LogM f2 = fn x
    f2 st
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/AC-MiniTest-1.1.1/Test/AC/Label.hs
Monad instance: 


instance Monad c => Monad (Label1 c) where
  return x = Label1 {label1 = "return", value1 = return x}

  lc >>= f = lc {value1 = value1 lc >>= \ x -> let lc' = f x in value1 lc'}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/AC-MiniTest-1.1.1/Test/AC/Test.hs
Monad instance: 


instance Monad TestM where
  return = TestM . return

  (TestM m1) >>= f = TestM $ m1 >>= \ x -> let TestM m2 = f x in m2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ctpl-0.1.0.4/Text/CTPL0.hs
Monad instance: 


instance Monad Exec where
  return = Succ
  (Succ a) >>= f = f a
  Expired >>= f = Expired
  ConfViol >>= f = ConfViol
  SynViol >>= f = SynViol
Applicative instance: 


instance Applicative Exec where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad CTPL0 where
  return a = CTPL0 $ \i k -> Succ (a, k, i)
  m >>= f = CTPL0 $ \i k ->
    case runCTPL0 m i k of
      Succ (a, k', i') -> runCTPL0 (f a) i' k'
      Expired -> Expired
      ConfViol -> ConfViol
      SynViol -> SynViol
Applicative instance: 


instance Applicative CTPL0 where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ctpl-0.1.0.4/Text/CTPL0n.hs
Monad instance: 
 -- ^ Nope. See 'Fail' type.

instance Monad Exec where
  return = Succ
  fail = Fail . Dead
  (Succ a) >>= f = f a
  (Fail e) >>= f = Fail e
Applicative instance: 


instance Applicative Exec where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad (CTPL0 s) where
  return a = CTPL0 $ \i ref cfg -> return $ Succ (a,i)
  m >>= f = CTPL0 $ \i ref cfg -> do
    r <- runCTPL0 m i ref cfg
    case r of
      Succ (a, i') -> runCTPL0 (f a) i' ref cfg
      Fail f -> return $ Fail f
Applicative instance: 


instance Applicative (CTPL0 s) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ctpl-0.1.0.4/Text/CTPL.hs
Monad instance: 


instance Monad Exec where
  return a = Succ a
  (Succ a) >>= f = f a
  (NoSuchProc s) >>= f = NoSuchProc s
  SyntaxFault >>= f = SyntaxFault
Applicative instance: 


instance Applicative Exec where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad CTPL where
  return a = CTPL $ \s cfg -> return (a, s, id)
  m >>= f = CTPL $ \s cfg -> do
                           (a', s', f') <- runCTPL m s cfg
                           (a'', s'', f'') <- runCTPL (f a') s' cfg
                           return (a'', s'', f' . f'')
Applicative instance: 


instance Applicative CTPL where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/deiko-config-0.5.0.0/Data/Config/Internal/DkM.hs
Applicative instance: 


--------------------------------------------------------------------------------
instance Applicative (DkM e s) where
    pure  = return
    (<*>) = ap
Monad instance: 


--------------------------------------------------------------------------------
instance Monad (DkM e s) where
    return a = DkM $ \_ s -> return (a, s)

    DkM k >>= f
        = DkM $ \e s -> do
            (a, !s') <- k e s
            runDkM (f a) e s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/helium-1.8.1/src/Helium/Parser/LexerMonad.hs
Monad instance: 


instance Monad LexerMonad where
    (>>=) = bindLM
    return = returnLM
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/freer-0.2.3.0/src/Control/Monad/Freer/Internal.hs
Applicative instance: 


instance Applicative (Eff r) where
  {-# INLINE pure #-}
  {-# INLINE (<*>) #-}
  pure = Val
  Val f <*> Val x = Val $ f x
  Val f <*> E u q = E u (q |> (Val . f))
  E u q <*> Val x = E u (q |> (Val . ($ x)))
  E u q <*> m     = E u (q |> (`fmap` m))
Monad instance: 


instance Monad (Eff r) where
  {-# INLINE return #-}
  {-# INLINE (>>=) #-}
  return = Val
  Val x >>= k = k x
  E u q >>= k = E u (q |> k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chell-0.4.0.1/lib/Test/Chell.hs
Applicative instance: 


instance Control.Applicative.Applicative Assertions where
        pure = return
        (<*>) = ap
Monad instance: 


instance Monad Assertions where
        return x = Assertions (\s -> return (Just x, s))
        m >>= f = Assertions (\s -> do
                (maybe_a, s') <- unAssertions m s
                case maybe_a of
                        Nothing -> return (Nothing, s')
                        Just a -> unAssertions (f a) s')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/testing-feat-0.4.0.3/Test/Feat/Enumerate.hs
Applicative instance: 


-- | Pure is 'singleton' and '<*>' corresponds to cartesian product (as with lists)
instance Applicative Enumerate where
  pure     = singleton
  f <*> a  = fmap (uncurry ($)) (cartesian f a)
Applicative instance: 


instance Applicative Finite where
  pure = finPure
  a <*> b = fmap (uncurry ($)) (finCart a b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/LTree-0.1/Control/Trees/LTreeT.hs
Monad instance: 


instance Monad m => Monad (TreeT m) where
    return c =  TreeT $ return $ Leaf c
    tmb_v >>= f = TreeT $ runTreeT tmb_v >>= onone f
               where onone f (Node b_ets) = do
                       ets_ <- mapM (onone f) b_ets
                       return $ Node ets_
                     onone f (Leaf x) = runTreeT $ f x
Applicative instance: 


instance Applicative m => Applicative (TreeT m)where
   pure = treeT0 . pure . pure
   (<*>) = treeT2 . liftA2 . liftA2 $ id
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/LTree-0.1/Data/Trees/LTree.hs
Applicative instance: 


instance Applicative Tree where
    pure c = Leaf c
    Node l <*> t = Node (map (<*> t) l)
    Leaf c <*> Node l = Node (map (c <$>) l)
    Leaf c <*> Leaf c' = Leaf (c c')
Monad instance: 


instance Monad Tree where
    return x = Leaf x
    Node l >>= f = Node (map (>>= f) l)
    Leaf c >>= f = f c
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hs-watchman-0.0.0.3/src/System/Directory/Watchman/BSER/Parser.hs
Monad instance: 


instance Monad Parser where
    m >>= g = Parser $ \kf ks -> let ks' a = runParser (g a) kf ks
                                 in runParser m kf ks'
    {-# INLINE (>>=) #-}
    return a = Parser $ \_kf ks -> ks a
    {-# INLINE return #-}
    fail msg = Parser $ \kf _ks -> kf msg
    {-# INLINE fail #-}
Applicative instance: 


instance Applicative Parser where
    pure  = return
    {-# INLINE pure #-}
    (<*>) = apP
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SG-1.0/Data/SG/Vector/Basic.hs
Applicative instance: 


instance Applicative Pair where
  pure a = Pair (a, a)
  (<*>) (Pair (fa, fb)) (Pair (a, b)) = Pair (fa a, fb b)
Applicative instance: 


instance Applicative Triple where
  pure a = Triple (a, a, a)
  (<*>) (Triple (fa, fb, fc)) (Triple (a, b, c)) = Triple (fa a, fb b, fc c)
Applicative instance: 


instance Applicative Quad where
  pure a = Quad (a, a, a, a)
  (<*>) (Quad (fa, fb, fc, fd)) (Quad (a, b, c, d))
    = Quad (fa a, fb b, fc c, fd d)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SG-1.0/Data/SG/Geometry/ThreeDim.hs
Applicative instance: 


instance Applicative Point3' where
  pure a = Point3 (a, a, a)
  (<*>) (Point3 (fa, fb, fc)) (Point3 (a, b, c)) = Point3 (fa a, fb b, fc c)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SG-1.0/Data/SG/Geometry/TwoDim.hs
Applicative instance: 


instance Applicative Point2' where
  pure a = Point2 (a, a)
  (<*>) (Point2 (fa, fb)) (Point2 (a, b)) = Point2 (fa a, fb b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SG-1.0/Data/SG/Matrix.hs
Applicative instance: 


instance Applicative c => Applicative (SquareMatrix c) where
  pure = SquareMatrix . pure . pure
  (SquareMatrix f) <*> (SquareMatrix m) = SquareMatrix $ (fmap (<*>) f) <*> m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/inc-ref-0.3.0.0/src/Control/Concurrent/IncRef.hs
Applicative instance: 


instance Applicative IncRef where
  pure x = IncRef retry (return x) (return (pure x))
  f <*> x
     =  IncRef
     (cache f <*> cache x)
     (do
          e <- (Left . F <$> stream f) <|> (Right . X <$> stream x)
          case e of
            Left  (F f') -> f'     <$> cache x
            Right (X x') -> ($ x') <$> cache f
      )
    $ (do
         f' <- dup f
         x' <- dup x
         return $ f' <*> x'
      )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chalkboard-1.9.0.16/Graphics/ChalkBoard/OpenGL/Monad.hs
Monad instance: 



instance Monad CBM where
    return n = CBM $ \_ -> return n
    m >>= k = CBM $ \env -> do
        a <- runCBM m env
        a' <- runCBM (k a) env
        return a'
    fail msg = CBM $ \_ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/scat-1.1.0.2/src/Scat/Builder.hs
Applicative instance: 


instance Applicative Builder where
    pure x = Builder (\ n -> (n, x))
    f <*> x = Builder $ \ n ->
        let (n', g) = runBuilder f n
        in g <$> runBuilder x n'
Monad instance: 


instance Monad Builder where
    return = pure
    x >>= f = Builder $ \ n ->
        let (n', v) = runBuilder x n
        in runBuilder (f v) n'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monadacme-0.0.2/src/Control/Monad/Acme.hs
Applicative instance: 


instance Applicative Acme where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Acme where
  return = Acme
  Acme x >>= f = f x
  fail = return . unsafeCoerce
Applicative instance: 


instance (Applicative m) => Applicative (AcmeT m) where
  pure = AcmeT . pure
  a <*> b = AcmeT $ runAcmeT a <*> runAcmeT b
Monad instance: 


instance (Monad m) => Monad (AcmeT m) where
  return = AcmeT . return
  AcmeT m >>= f = AcmeT $ m >>= runAcmeT . f
  fail = return . unsafeCoerce
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/manifolds-0.2.2.0/Data/Manifold/TreeCover.hs
Applicative instance: 

instance Hask.Applicative Hourglass where
  pure x = Hourglass x x
  Hourglass f g <*> Hourglass x y = Hourglass (f x) (g y)
Applicative instance: 

instance (Hask.Applicative f) => Hask.Applicative (OuterMaybeT f) where
  pure = OuterJust . pure
  OuterJust fs <*> OuterJust xs = OuterJust $ fs <*> xs
  _ <*> _ = OuterNothing
Applicative instance: 


instance (AdditiveGroup x) => Hask.Applicative (WithAny x) where
  pure x = WithAny x zeroV
  WithAny f x <*> WithAny t ξ = WithAny (f t) (x^+^ξ)
Monad instance: 


instance (AdditiveGroup x) => Hask.Monad (WithAny x) where
  return x = WithAny x zeroV
  WithAny y x >>= f = WithAny r $ x^+^q
   where WithAny r q = f y
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/manifolds-0.2.2.0/Data/CoNat.hs
Applicative instance: 


instance (KnownNat n) => Hask.Applicative (FreeVect n) where
  pure = replicVector
  (<*>) = perfectZipWith ($)
Applicative instance: 

instance (Monoidal f (->) (->)) => Hask.Applicative (AsHaskFunctor f) where
  pure x = fmap (const x) . AsHaskFunctor $ pureUnit ()
  AsHaskFunctor fs <*> AsHaskFunctor xs = AsHaskFunctor . fmap (uncurry ($)) $ fzip (fs, xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/manifolds-0.2.2.0/Data/SimplicialComplex.hs
Applicative instance: 

instance (Hask.Functor m, Monad m (->))
             => Hask.Applicative (TriangT t n x m) where
  pure x = TriangT $ pure . (x,)
  TriangT fs <*> TriangT xs = TriangT $
      fs >=> \(f, t') -> fmap (first f) $ xs t'
Monad instance: 

instance (Hask.Functor m, Monad m (->)) => Hask.Monad (TriangT t n x m) where
  return x = TriangT $ pure . (x,)
  TriangT xs >>= f = TriangT $
      \t -> xs t >>= \(y,t') -> let (TriangT zs) = f y in zs t'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Tensor-1.1.0.1/src/Data/Tensor.hs
Applicative instance: 


instance Applicative Vertex1 where
   pure a = Vertex1 a
   Vertex1 f <*> Vertex1 x = Vertex1 (f x)
Applicative instance: 


instance Applicative Vertex2 where
   pure a = Vertex2 a a
   Vertex2 f g <*> Vertex2 x y = Vertex2 (f x) (g y)
Applicative instance: 


instance Applicative Vertex3 where
   pure a = Vertex3 a a a
   Vertex3 f g h <*> Vertex3 x y z = Vertex3 (f x) (g y) (h z)
Applicative instance: 


instance Applicative Vertex4 where
   pure a = Vertex4 a a a a
   Vertex4 f g h i <*> Vertex4 x y z w = Vertex4 (f x) (g y) (h z) (i w)
Applicative instance: 


instance Applicative Vector1 where
   pure a = Vector1 a
   Vector1 f <*> Vector1 x = Vector1 (f x)
Applicative instance: 


instance Applicative Vector2 where
   pure a = Vector2 a a
   Vector2 f g <*> Vector2 x y = Vector2 (f x) (g y)
Applicative instance: 


instance Applicative Vector3 where
   pure a = Vector3 a a a
   Vector3 f g h <*> Vector3 x y z = Vector3 (f x) (g y) (h z)
Applicative instance: 


instance Applicative Vector4 where
   pure a = Vector4 a a a a
   Vector4 f g h i <*> Vector4 x y z w = Vector4 (f x) (g y) (h z) (i w)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/DrIFT-cabalized-2.3.0/src/ParseLib2.hs
Monad instance: 


instance Monad Parser where
   -- return      :: a -> Parser a
   return v        = P (\pos inp -> [(v,inp)])

   -- >>=         :: Parser a -> (a -> Parser b) -> Parser b
   (P p) >>= f     = P (\pos inp -> concat [papply (f v) pos out
                                                | (v,out) <- p pos inp])
   fail s          = P (\pos inp -> [])
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskell-neo4j-client-0.3.2.2/src/Database/Neo4j/Types.hs
Monad instance: 


instance Monad Neo4j where
    return x = Neo4j (const (return x))
    (Neo4j cmd) >>= f = Neo4j $ \con -> do
                            a <- cmd con
                            runNeo4j (f a) con
Applicative instance: 


instance Applicative Neo4j where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-functors-0.6.5/src/Data/Functor/Cofree.hs
Applicative instance: 


instance (ForallF c Identity, ForallF c (Cofree c), ForallF c (Compose (Cofree c) (Cofree c)))
  => Applicative (Cofree c) where
  pure = leftAdjunctF runIdentity . Identity
  (<*>) = ap
Monad instance: 


instance (ForallF c Identity, ForallF c (Cofree c), ForallF c (Compose (Cofree c) (Cofree c)))
  => Monad (Cofree c) where
  return = pure
  m >>= g = leftAdjunctF (extract . extract . getCompose) (Compose $ fmap g m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-functors-0.6.5/src/Data/Functor/HFree.hs
Applicative instance: 


instance Applicative (HFree Monad f) where
  pure = return
  (<*>) = ap
Monad instance: 


-- | The free monad of a functor.
instance Monad (HFree Monad f) where
  return a = HFree $ const (return a)
  HFree f >>= g = HFree $ \k -> f k >>= (rightAdjunct k . g)
Applicative instance: 

-- HFree Monad is only a monad transformer if rightAdjunct is called with monad morphisms.
-- F.e. lift . return == return fails if the results are inspected with rightAdjunct (const Nothing).
-- instance MonadTrans (HFree Monad) where
--   lift = liftFree

instance Applicative (HFree Applicative f) where
  pure a = HFree $ const (pure a)
  HFree f <*> HFree g = HFree $ \k -> f k <*> g k
Applicative instance: 


instance Applicative (HFree Alternative f) where
  pure a = HFree $ const (pure a)
  HFree f <*> HFree g = HFree $ \k -> f k <*> g k
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-functors-0.6.5/src/Data/Functor/Free.hs
Applicative instance: 


instance Applicative (Free c) where
  pure = unit
  fs <*> as = transform (\k f -> rightAdjunct (k . f) as) fs
Monad instance: 


instance Monad (Free c) where
  return = unit
  as >>= f = transform (\k -> rightAdjunct k . f) as
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lol-0.5.0.2/Crypto/Lol/Types/IZipVector.hs
Applicative instance: 


-- Zip-py 'Applicative' instance.
instance (Fact m) => Applicative (IZipVector m) where
  pure = repl
  (IZipVector f) <*> (IZipVector a) = IZipVector $ V.zipWith ($) f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lol-0.5.0.2/Crypto/Lol/Cyclotomic/Tensor/CTensor.hs
Applicative instance: 


instance Fact m => Applicative (CT m) where
  pure = ZV . pure

  (ZV f) <*> (ZV a) = ZV (f <*> a)
  f@(ZV _) <*> v@(CT _) = f <*> toZV v
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lol-0.5.0.2/Crypto/Lol/Cyclotomic/Tensor/RepaTensor.hs
Applicative instance: 


instance Fact m => Applicative (RT m) where
  pure = ZV . pure

  -- RT can never hold an a -> b
  (ZV f) <*> (ZV a) = ZV (f <*> a)
  f@(ZV _) <*> v@(RT _) = f <*> toZV v
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lol-0.5.0.2/Crypto/Lol/Cyclotomic/UCyc.hs
Applicative instance: 


-- CJP: no Functor instance for C, because CRTrans for a doesn't imply
-- it for b.

instance (Tensor t, Fact m) => Applicative (UCyc t m P) where
  pure = Pow . pure \\ proxy entailIndexT (Proxy::Proxy (t m r))
  (Pow f) <*> (Pow v) = Pow $ f <*> v \\ witness entailIndexT v

  {-# INLINABLE pure #-}
  {-# INLINABLE (<*>) #-}
Applicative instance: 


instance (Tensor t, Fact m) => Applicative (UCyc t m D) where
  pure = Dec . pure \\ proxy entailIndexT (Proxy::Proxy (t m r))
  (Dec f) <*> (Dec v) = Dec $ f <*> v \\ witness entailIndexT v

  {-# INLINABLE pure #-}
  {-# INLINABLE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tfp-1.0.0.2/src/Type/Base/Proxy.hs
Applicative instance: 


instance Applicative Proxy where
   pure _ = Proxy
   Proxy <*> Proxy = Proxy
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/timeout-with-results-0.2/src/System/Timeout/Returning/Writer.hs
Applicative instance: 

instance Applicative (TimeoutWriter w) where
    pure  = return
    (<*>) = ap
Monad instance: 

instance Monad (TimeoutWriter w) where
    return = TimeoutWriter . return
    (TimeoutWriter v) >>= f = TimeoutWriter (v >>= (getTimeoutWriter . f))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/timeout-with-results-0.2/src/System/Timeout/Returning.hs
Applicative instance: 

instance Applicative (Timeout w) where
    pure  = return
    (<*>) = ap
Monad instance: 

instance Monad (Timeout w) where
    return = Timeout . return
    (Timeout v) >>= f = Timeout (v >>= (getTimeout . f))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gore-and-ash-1.2.1.0/src/Control/Wire/Session.hs
Applicative instance: 


instance (Applicative m) => Applicative (Session m) where
    pure x = let s = Session (pure (x, s)) in s

    Session ff <*> Session fx =
        Session $ liftA2 (\(f, sf) (x, sx) -> (f x, sf <*> sx)) ff fx
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gore-and-ash-1.2.1.0/src/Game/GoreAndAsh/Core/Monad.hs
Applicative instance: 


-- | Monad is needed as StateT Applicative instance requires it
instance Monad m => Applicative (GameMonadT m) where
  pure a = GameMonadT $ pure a
  (GameMonadT f) <*> (GameMonadT m) = GameMonadT $ f <*> m
Monad instance: 


instance Monad m => Monad (GameMonadT m) where
  return = pure
  (GameMonadT ma) >>= f = GameMonadT $ do
    a <- ma
    runGameMonadT $ f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/simple-pipe-0.0.0.9/src/Data/Pipe.hs
Monad instance: 


instance Monad m => Monad (Pipe i o m) where
        Ready f o p >>= k = Ready f o $ p >>= k
        Need f n >>= k = Need f $ n >=> k
--	Done f r >>= k = Make (return ()) $ f >> return (k r)
        Done _ r >>= k = k r
        Make f m >>= k = Make f $ (>>= k) `liftM` m
        return = Done (return ())
Applicative instance: 


instance Monad m => Applicative (Pipe i o m) where
        pure = return
        (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-0.32.0.8/lib/Penny/Lincoln/Serial.hs
Applicative instance: 


instance Applicative GenSerial where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad GenSerial where
  return a = GenSerial $ \s -> (a, s)
  (GenSerial k) >>= f = GenSerial $ \s ->
    let (a, s') = k s
        GenSerial g = f a
    in g s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-0.32.0.8/lib/Penny/Cabin/Posts/Allocated.hs
Applicative instance: 


instance Applicative Fields where
  pure a = Fields a a
  ff <*> fa = Fields {
    payee = payee ff (payee fa)
    , account = account ff (account fa) }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-0.32.0.8/lib/Penny/Cabin/Posts/Fields.hs
Applicative instance: 


instance Applicative Fields where
  pure a = Fields {
    globalTransaction = a
    , revGlobalTransaction = a
    , globalPosting = a
    , revGlobalPosting = a
    , fileTransaction = a
    , revFileTransaction = a
    , filePosting = a
    , revFilePosting = a
    , filtered = a
    , revFiltered = a
    , sorted = a
    , revSorted = a
    , visible = a
    , revVisible = a
    , lineNum = a
    , date = a
    , flag = a
    , number = a
    , payee = a
    , account = a
    , postingDrCr = a
    , postingCmdty = a
    , postingQty = a
    , totalDrCr = a
    , totalCmdty = a
    , totalQty = a
    , tags = a
    , memo = a
    , filename = a }

  ff <*> fa = Fields {
    globalTransaction = globalTransaction ff (globalTransaction fa)
    , revGlobalTransaction = revGlobalTransaction ff
                             (revGlobalTransaction fa)
    , globalPosting = globalPosting ff (globalPosting fa)
    , revGlobalPosting = revGlobalPosting ff (revGlobalPosting fa)
    , fileTransaction = fileTransaction ff (fileTransaction fa)
    , revFileTransaction = revFileTransaction ff (revFileTransaction fa)
    , filePosting = filePosting ff (filePosting fa)
    , revFilePosting = revFilePosting ff (revFilePosting fa)
    , filtered = filtered ff (filtered fa)
    , revFiltered = revFiltered ff (revFiltered fa)
    , sorted = sorted ff (sorted fa)
    , revSorted = revSorted ff (revSorted fa)
    , visible = visible ff (visible fa)
    , revVisible = revVisible ff (revVisible fa)
    , lineNum = lineNum ff (lineNum fa)
    , date = date ff (date fa)
    , flag = flag ff (flag fa)
    , number = number ff (number fa)
    , payee = payee ff (payee fa)
    , account = account ff (account fa)
    , postingDrCr = postingDrCr ff (postingDrCr fa)
    , postingCmdty = postingCmdty ff (postingCmdty fa)
    , postingQty = postingQty ff (postingQty fa)
    , totalDrCr = totalDrCr ff (totalDrCr fa)
    , totalCmdty = totalCmdty ff (totalCmdty fa)
    , totalQty = totalQty ff (totalQty fa)
    , tags = tags ff (tags fa)
    , memo = memo ff (memo fa)
    , filename = filename ff (filename fa) }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-0.32.0.8/lib/Penny/Cabin/Posts/BottomRows.hs
Applicative instance: 


instance Applicative Fields where
  pure a = Fields a a a
  ff <*> fa = Fields {
    tags = (tags ff) (tags fa)
    , memo = (memo ff) (memo fa)
    , filename = (filename ff) (filename fa)
    }
Applicative instance: 


instance Applicative TopRowCells where
  pure a = TopRowCells
    { globalTransaction    = a
    , revGlobalTransaction = a
    , globalPosting        = a
    , revGlobalPosting     = a
    , fileTransaction      = a
    , revFileTransaction   = a
    , filePosting          = a
    , revFilePosting       = a
    , filtered             = a
    , revFiltered          = a
    , sorted               = a
    , revSorted            = a
    , visible              = a
    , revVisible           = a
    , lineNum              = a
    , date                 = a
    , flag                 = a
    , number               = a
    , payee                = a
    , account              = a
    , postingDrCr          = a
    , postingCmdty         = a
    , postingQty           = a
    , totalDrCr            = a
    , totalCmdty           = a
    , totalQty             = a }

  ff <*> fa = TopRowCells
    { globalTransaction    = globalTransaction    ff (globalTransaction    fa)
    , revGlobalTransaction = revGlobalTransaction ff (revGlobalTransaction fa)
    , globalPosting        = globalPosting        ff (globalPosting        fa)
    , revGlobalPosting     = revGlobalPosting     ff (revGlobalPosting     fa)
    , fileTransaction      = fileTransaction      ff (fileTransaction      fa)
    , revFileTransaction   = revFileTransaction   ff (revFileTransaction   fa)
    , filePosting          = filePosting          ff (filePosting          fa)
    , revFilePosting       = revFilePosting       ff (revFilePosting       fa)
    , filtered             = filtered             ff (filtered             fa)
    , revFiltered          = revFiltered          ff (revFiltered          fa)
    , sorted               = sorted               ff (sorted               fa)
    , revSorted            = revSorted            ff (revSorted            fa)
    , visible              = visible              ff (visible              fa)
    , revVisible           = revVisible           ff (revVisible           fa)
    , lineNum              = lineNum              ff (lineNum              fa)
    , date                 = date                 ff (date                 fa)
    , flag                 = flag                 ff (flag                 fa)
    , number               = number               ff (number               fa)
    , payee                = payee                ff (payee                fa)
    , account              = account              ff (account              fa)
    , postingDrCr          = postingDrCr          ff (postingDrCr          fa)
    , postingCmdty         = postingCmdty         ff (postingCmdty         fa)
    , postingQty           = postingQty           ff (postingQty           fa)
    , totalDrCr            = totalDrCr            ff (totalDrCr            fa)
    , totalCmdty           = totalCmdty           ff (totalCmdty           fa)
    , totalQty             = totalQty             ff (totalQty             fa) }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-0.32.0.8/lib/Penny/Cabin/Posts/Growers.hs
Applicative instance: 


instance Applicative Fields where
  pure a = Fields
    { globalTransaction     = a
    , revGlobalTransaction = a
    , globalPosting        = a
    , revGlobalPosting     = a
    , fileTransaction      = a
    , revFileTransaction   = a
    , filePosting          = a
    , revFilePosting       = a
    , filtered             = a
    , revFiltered          = a
    , sorted               = a
    , revSorted            = a
    , visible              = a
    , revVisible           = a
    , lineNum              = a
    , date                 = a
    , flag                 = a
    , number               = a
    , postingDrCr          = a
    , postingCmdty         = a
    , postingQty           = a
    , totalDrCr            = a
    , totalCmdty           = a
    , totalQty             = a }

  fl <*> fa = Fields
    { globalTransaction    = globalTransaction    fl (globalTransaction    fa)
    , revGlobalTransaction = revGlobalTransaction fl (revGlobalTransaction fa)
    , globalPosting        = globalPosting        fl (globalPosting        fa)
    , revGlobalPosting     = revGlobalPosting     fl (revGlobalPosting     fa)
    , fileTransaction      = fileTransaction      fl (fileTransaction      fa)
    , revFileTransaction   = revFileTransaction   fl (revFileTransaction   fa)
    , filePosting          = filePosting          fl (filePosting          fa)
    , revFilePosting       = revFilePosting       fl (revFilePosting       fa)
    , filtered             = filtered             fl (filtered             fa)
    , revFiltered          = revFiltered          fl (revFiltered          fa)
    , sorted               = sorted               fl (sorted               fa)
    , revSorted            = revSorted            fl (revSorted            fa)
    , visible              = visible              fl (visible              fa)
    , revVisible           = revVisible           fl (revVisible           fa)
    , lineNum              = lineNum              fl (lineNum              fa)
    , date                 = date                 fl (date                 fa)
    , flag                 = flag                 fl (flag                 fa)
    , number               = number               fl (number               fa)
    , postingDrCr          = postingDrCr          fl (postingDrCr          fa)
    , postingCmdty         = postingCmdty         fl (postingCmdty         fa)
    , postingQty           = postingQty           fl (postingQty           fa)
    , totalDrCr            = totalDrCr            fl (totalDrCr            fa)
    , totalCmdty           = totalCmdty           fl (totalCmdty           fa)
    , totalQty             = totalQty             fl (totalQty             fa) }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-0.32.0.8/lib/Penny/Cabin/Balance/MultiCommodity/Chunker.hs
Applicative instance: 


instance Applicative Columns where
  pure a = Columns a a a a
  fn <*> fa = Columns {
    acct = (acct fn) (acct fa)
    , drCr = (drCr fn) (drCr fa)
    , commodity = (commodity fn) (commodity fa)
    , quantity = (quantity fn) (quantity fa)
     }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-0.32.0.8/lib/Penny/Cabin/Balance/Convert/ChunkerPct.hs
Applicative instance: 


instance Applicative Columns where
  pure a = Columns a a a
  fn <*> fa = Columns {
    acct = (acct fn) (acct fa)
    , drCr = (drCr fn) (drCr fa)
    , quantity = (quantity fn) (quantity fa)
     }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-0.32.0.8/lib/Penny/Cabin/Balance/Convert/Chunker.hs
Applicative instance: 


instance Applicative Columns where
  pure a = Columns a a a
  fn <*> fa = Columns {
    acct = (acct fn) (acct fa)
    , drCr = (drCr fn) (drCr fa)
    , quantity = (quantity fn) (quantity fa)
     }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tinytemplate-0.1.2.0/src/Data/Text/Template.hs
Applicative instance: 


instance Applicative Id where
  pure = Id
  (<*>) f x = Id $ runId f (runId x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/persistable-record-0.4.0.2/src/Database/Record/FromSql.hs
Monad instance: 


-- | 'Monad' instance like parser 'Monad'.
instance Monad (RecordFromSql q) where
  return a = createRecordFromSql ((,) a)
  ma >>= fmb =
    createRecordFromSql
    (\vals -> let (a, vals') = runTakeRecord ma vals
              in  runTakeRecord (fmb a) vals')
Applicative instance: 


-- | Derived 'Applicative' instance from 'Monad' instance
instance Applicative (RecordFromSql q) where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dunai-0.1.0.0/src/Data/MonadicStreamFunction.hs
Applicative instance: 


instance Applicative m => Applicative (MStreamF m r) where
  -- pure a = constantly a
  pure a = MStreamF $ \_ -> pure (a, pure a)
  {-
  fs <*> as = proc _ -> do
      f <- fs -< ()
      a <- as -< ()
      returnA -< f a
  -}
  fs <*> as = MStreamF $ \r -> applyTuple <$> unMStreamF fs r <*> unMStreamF as r
    where
      applyTuple (f, fs') (a, as') = (f a, fs' <*> as')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskell-rules-0.1.0.1/src/Language/Rules/NDSM.hs
Monad instance: 


instance Monad (NDSM s) where
        return x = NDSM (\s -> [(s,x)])
        (NDSM f) >>= c = NDSM (\s -> let svl = f s
                                         ml = map (\(_,x)->(unNDSM $ c x)) svl
                                         sl = map fst svl
                                         aml = zipWith ($) ml sl
                                     in concat aml)
Applicative instance: 


instance Applicative (NDSM s) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/acme-iot-0.1.0.1/src/Control/Monad/Trans/IO.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (IOT m) where
    pure x = IOT# $ \s# -> return $ IORet# (# s#, x #)
    IOT# ff <*> IOT# fx = IOT# $ \s# -> do
        IORet# (# s#, f #) <- ff s#
        IORet# (# s#, x #) <- fx s#
        return $ IORet# (# s#, f x #)
Monad instance: 


instance Monad m => Monad (IOT m) where
    return x = IOT# $ \s# -> return $ IORet# (# s#, x #)
    IOT# fx >>= ff = IOT# $ \s# -> do
        IORet# (# s#, x #) <- fx s#
        getIOT# (ff x) s#
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/coordinate-0.1.2/src/Data/Geodetic/EllipsoidReaderT.hs
Applicative instance: 


instance Applicative f => Applicative (EllipsoidReaderT f) where
  pure =
    EllipsoidReaderT . pure . pure
  EllipsoidReaderT f <*> EllipsoidReaderT a =
      EllipsoidReaderT (liftA2 (<*>) f a)
Monad instance: 


instance Monad f => Monad (EllipsoidReaderT f) where
  return =
    EllipsoidReaderT . return . return
  EllipsoidReaderT k >>= f =
    EllipsoidReaderT (\e -> k e >>= \q -> e & f q ^. _Wrapped')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-mersenne-random-0.1/Control/Monad/Mersenne/Random.hs
Monad instance: 


instance Monad Rand where

    {-# INLINE return #-}
    return a = Rand $ \s -> R a s

    {-# INLINE (>>=) #-}
    m >>= k  = Rand $ \s -> case runRand m s of
                                R a s' -> runRand (k a) s'

    {-# INLINE (>>) #-}
    m >>  k  = Rand $ \s -> case runRand m s of
                                R _ s' -> runRand k s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reasonable-operational-0.1.0.1/src/Control/Monad/Operational.hs
Applicative instance: 


instance Functor f => Applicative (Free f) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Functor f => Monad (Free f) where
  return = Pure
  Free x >>= f = Free $ fmap (>>= f) x
  Pure x >>= f = f x
Applicative instance: 


instance Applicative (Program f) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad (Program f) where
  return = Program . return
  x >>= f = Program $ toFree x >>= toFree . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/threepenny-gui-0.6.0.6/src/Reactive/Threepenny.hs
Applicative instance: 


instance Applicative Behavior where
    pure a  = B (Prim.pureL a) never
    ~(B lf ef) <*> ~(B lx ex) =
        B (Prim.applyL lf lx) (unionWith const ef ex)
Applicative instance: 


-- | The applicative instance combines 'rumors'
-- and uses 'facts' when some of the 'rumors' are not available.
instance Applicative Tidings where
    pure x  = T (pure x) never
    f <*> x = uncurry ($) <$> pair f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/threepenny-gui-0.6.0.6/src/Graphics/UI/Threepenny/Internal.hs
Applicative instance: 


instance Applicative UI where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad UI where
    return  = UI . return
    m >>= k = UI $ unUI m >>= unUI . k
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hask-0/src/Hask/Tensor/Compose.hs
Monad instance: 

instance (Functor m, Dom m ~ Cod m, Monoid (Compose (Dom m) (Dom m) (Dom m)) m, Identified (Dom m), Composed (Dom m)) => Monad m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrows-0.4.4.1/Control/Arrow/Transformer/State.hs
Applicative instance: 


instance Arrow a => Applicative (StateArrow s a b) where
        pure x = arr (const x)
        f <*> g = f &&& g >>> arr (uncurry id)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrows-0.4.4.1/Control/Arrow/Transformer/Error.hs
Applicative instance: 


instance ArrowChoice a => Applicative (ErrorArrow ex a b) where
        pure x = arr (const x)
        f <*> g = f &&& g >>> arr (uncurry id)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrows-0.4.4.1/Control/Arrow/Transformer/Writer.hs
Applicative instance: 


instance (Arrow a, Monoid w) => Applicative (WriterArrow w a b) where
        pure x = arr (const x)
        f <*> g = f &&& g >>> arr (uncurry id)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrows-0.4.4.1/Control/Arrow/Transformer/Reader.hs
Applicative instance: 


instance Arrow a => Applicative (ReaderArrow r a b) where
        pure x = arr (const x)
        f <*> g = f &&& g >>> arr (uncurry id)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrows-0.4.4.1/Control/Arrow/Transformer/Automaton.hs
Applicative instance: 


instance Arrow a => Applicative (Automaton a b) where
        pure x = arr (const x)
        f <*> g = f &&& g >>> arr (uncurry id)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrows-0.4.4.1/Control/Arrow/Transformer/Stream.hs
Applicative instance: 


instance Arrow a => Applicative (StreamArrow a b) where
        pure x = arr (const x)
        f <*> g = f &&& g >>> arr (uncurry id)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrows-0.4.4.1/Control/Arrow/Transformer/CoState.hs
Applicative instance: 


instance Arrow a => Applicative (CoStateArrow s a b) where
        pure x = arr (const x)
        f <*> g = f &&& g >>> arr (uncurry id)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrows-0.4.4.1/Control/Arrow/Transformer/Static.hs
Applicative instance: 


instance (Arrow a, Applicative f) => Applicative (StaticArrow f a b) where
        pure x = arr (const x)
        f <*> g = f &&& g >>> arr (uncurry id)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-reactive-1.0/Data/TimeVal.hs
Applicative instance: 

instance Applicative TimeVal
Monad instance: 

instance Monad TimeVal where
  join (Since b) = b
  join Always = Always
  join Never = Never
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-reactive-1.0/Data/Reactive.hs
Applicative instance: 

instance Ord t => Applicative (Reactive t) where
  Reactive f fs <*> Reactive x xs = Reactive (f x) (cons (pure f) fs<*>cons (pure x) xs)
Applicative instance: 

instance Ord t => Applicative (Event t) where
  fe@(yb i'event -> ff:-:_) <*> xe@(yb i'event -> fx:-:_) =
    ste & traverse (by state) & yb state & map snd & \st ->
    br (ff^.l'time + fx^.l'time) (st (ff^.l'value,fx^.l'value))
    where ste = map (\f (_,x) -> ((f,x),f x)) fe
              + map (\x (f,_) -> ((f,x),f x)) xe
          br t (yb i'event -> e) = (map (l'time %- t) b ++ a)^.i'event
            where (b,a) = span (\f -> f^.l'time<t) e
Monad instance: 


instance Ord t => Monad (Event t) where
  join m = m & (i'event %%~ merge . trace "merge" . map2 (trace "map2" . yb i'event . trace "map"))
    where
      merge (xs:-:ys:-:t) = trace "xi" (xi ++ merge ((ys&l'value%~add xe) :-: t) & l'1.l'time %~ (+tx))
        where add = warp2 i'event (+)
              (tx,~(xi,xe)) = xs^..i'future & l'2%~(break (ltFut ys).trace "break")
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lowgl-0.3.1.1/Graphics/GL/Low/Cube.hs
Applicative instance: 


instance Applicative Cube where
  pure x = Cube x x x x x x
  (Cube f1 f2 f3 f4 f5 f6) <*> (Cube x1 x2 x3 x4 x5 x6) =
    Cube (f1 x1) (f2 x2) (f3 x3) (f4 x4) (f5 x5) (f6 x6)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/XSaiga-1.1.0.0/AGParser2.hs
Applicative instance: 


instance Applicative StateM where
    pure  = return
    (<*>) = ap
Monad instance: 
  -- defined in Control.Monad

instance Monad StateM where
  -- defines state propagation
  State m            >>= k
         = State (\s -> let (a,y) = m s in unState (k a) y)
  return k             =  State (\s -> (k,s))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Pugs-6.2.13.9/src/Pugs/AST/Eval.hs
Monad instance: 


instance Monad Eval where
    return a = EvalT $ return (RNormal a)
    m >>= k = EvalT $ do
        a <- runEvalT m
        case a of
            RNormal x   -> runEvalT (k x)
            RException x-> return (RException x)
    fail str = do
        pos <- asks envPos'
        EvalT $ return (RException (errStrPos (cast str) pos))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Pugs-6.2.13.9/src/Pugs/AST/SIO.hs
Monad instance: 


instance Monad SIO where
    return a = MkSIO a
    (MkIO io)   >>= k = MkIO $ do { a <- io; runIO (k a) }
    (MkSTM stm) >>= k = MkSTM $ do { a <- stm; runSTM (k a) }
    (MkSIO x)   >>= k = k x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Pugs-6.2.13.9/src/Pugs/Monads.hs
Monad instance: 


instance (Monad m) => Monad (MaybeT m) where
    (MaybeT mon) >>= f =
        MaybeT (mon >>= maybe (return Nothing) (runMaybeT . f))
    return              = MaybeT . return . Just
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/broccoli-0.4.1.0/Control/Broccoli.hs
Applicative instance: 


instance Applicative X where
  pure x = PureX x
  f <*> x = ApplX f x
Monad instance: 


instance Monad Setup where
  return x = Setup (\_ -> return x)
  (Setup r) >>= f = Setup r' where
    r' mv = do
      x <- r mv
      let Setup r'' = f x
      r'' mv
Applicative instance: 


instance Applicative Setup where
  pure = return
  (<*>) = ap
Applicative instance: 


instance Applicative Promise where
  pure x = Promise (return x)
  ff <*> xx = Promise $ do
    f <- force ff
    x <- force xx
    return (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/http-kinder-0.2.0.0/src/Network/HTTP/Kinder/MediaType.hs
Applicative instance: 


instance Applicative (Ver n) where
  pure = Ver
  Ver f <*> Ver a = Ver (f a)
Monad instance: 


instance Monad (Ver n) where
  return = pure
  Ver x >>= f = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/http-kinder-0.2.0.0/src/Network/HTTP/Kinder/Query.hs
Applicative instance: 


instance Applicative QueryKeyState where
  pure = QueryKeyValued
  (<*>) = ap
Monad instance: 


-- | Monad instance equivalent to @Either Bool@
instance Monad QueryKeyState where
  return = pure
  m >>= f =
    case m of
      QueryKeyValued a -> f a
      QueryKeyPresent -> QueryKeyPresent
      QueryKeyAbsent -> QueryKeyAbsent
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Distribution/Client/Tar.hs
Monad instance: 


instance Monad Partial where
    return        = Ok
    Error m >>= _ = Error m
    Ok    x >>= k = k x
    fail          = Error
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Distribution/Client/Dependency/Types.hs
Monad instance: 


instance Monad (Progress step fail) where
  return a = Done a
  p >>= f  = foldProgress Step Fail f p
Applicative instance: 


instance Applicative (Progress step fail) where
  pure a  = Done a
  p <*> x = foldProgress Step Fail (flip fmap x) p
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Applicative/Backwards.hs
Applicative instance: 


-- | Apply @f@-actions in the reverse order.
instance (Applicative f) => Applicative (Backwards f) where
    pure a = Backwards (pure a)
    Backwards f <*> Backwards a = Backwards (a <**> f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Applicative/Lift.hs
Applicative instance: 


-- | A combination is 'Pure' only if both parts are.
instance (Applicative f) => Applicative (Lift f) where
    pure = Pure
    Pure f <*> Pure x = Pure (f x)
    Pure f <*> Other y = Other (f <$> y)
    Other f <*> Pure x = Other (($ x) <$> f)
    Other f <*> Other y = Other (f <*> y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/Cont.hs
Applicative instance: 


instance Applicative (ContT r m) where
    pure a  = ContT ($ a)
    f <*> v = ContT $ \ k -> runContT f $ \ g -> runContT v (k . g)
Monad instance: 


instance Monad (ContT r m) where
    return a = ContT ($ a)
    m >>= k  = ContT $ \c -> runContT m (\a -> runContT (k a) c)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/Identity.hs
Applicative instance: 


instance (Applicative m) => Applicative (IdentityT m) where
    pure x = IdentityT (pure x)
    (<*>) = lift2IdentityT (<*>)
Monad instance: 


instance (Monad m) => Monad (IdentityT m) where
    return = IdentityT . return
    m >>= k = IdentityT $ runIdentityT . k =<< runIdentityT m
    fail msg = IdentityT $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/State/Strict.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (StateT s m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance (Monad m) => Monad (StateT s m) where
    return a = state $ \s -> (a, s)
    m >>= k  = StateT $ \s -> do
        (a, s') <- runStateT m s
        runStateT (k a) s'
    fail str = StateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/State/Lazy.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (StateT s m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance (Monad m) => Monad (StateT s m) where
    return a = state $ \s -> (a, s)
    m >>= k  = StateT $ \s -> do
        ~(a, s') <- runStateT m s
        runStateT (k a) s'
    fail str = StateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/RWS/Strict.hs
Applicative instance: 


instance (Monoid w, Functor m, Monad m) => Applicative (RWST r w s m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance (Monoid w, Monad m) => Monad (RWST r w s m) where
    return a = RWST $ \_ s -> return (a, s, mempty)
    m >>= k  = RWST $ \r s -> do
        (a, s', w)  <- runRWST m r s
        (b, s'',w') <- runRWST (k a) r s'
        return (b, s'', w `mappend` w')
    fail msg = RWST $ \_ _ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/RWS/Lazy.hs
Applicative instance: 


instance (Monoid w, Functor m, Monad m) => Applicative (RWST r w s m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance (Monoid w, Monad m) => Monad (RWST r w s m) where
    return a = RWST $ \_ s -> return (a, s, mempty)
    m >>= k  = RWST $ \r s -> do
        ~(a, s', w)  <- runRWST m r s
        ~(b, s'',w') <- runRWST (k a) r s'
        return (b, s'', w `mappend` w')
    fail msg = RWST $ \_ _ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/Reader.hs
Applicative instance: 


instance (Applicative m) => Applicative (ReaderT r m) where
    pure    = liftReaderT . pure
    f <*> v = ReaderT $ \ r -> runReaderT f r <*> runReaderT v r
Monad instance: 


instance (Monad m) => Monad (ReaderT r m) where
    return   = lift . return
    m >>= k  = ReaderT $ \ r -> do
        a <- runReaderT m r
        runReaderT (k a) r
    fail msg = lift (fail msg)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/List.hs
Applicative instance: 


instance (Applicative m) => Applicative (ListT m) where
    pure a  = ListT $ pure [a]
    f <*> v = ListT $ (<*>) <$> runListT f <*> runListT v
Monad instance: 


instance (Monad m) => Monad (ListT m) where
    return a = ListT $ return [a]
    m >>= k  = ListT $ do
        a <- runListT m
        b <- mapM (runListT . k) a
        return (concat b)
    fail _ = ListT $ return []
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/Maybe.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (MaybeT m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance (Monad m) => Monad (MaybeT m) where
    fail _ = MaybeT (return Nothing)
    return = lift . return
    x >>= f = MaybeT $ do
        v <- runMaybeT x
        case v of
            Nothing -> return Nothing
            Just y  -> runMaybeT (f y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/Writer/Strict.hs
Applicative instance: 


instance (Monoid w, Applicative m) => Applicative (WriterT w m) where
    pure a  = WriterT $ pure (a, mempty)
    f <*> v = WriterT $ liftA2 k (runWriterT f) (runWriterT v)
      where k (a, w) (b, w') = (a b, w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (WriterT w m) where
    return a = WriterT $ return (a, mempty)
    m >>= k  = WriterT $ do
        (a, w)  <- runWriterT m
        (b, w') <- runWriterT (k a)
        return (b, w `mappend` w')
    fail msg = WriterT $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/Writer/Lazy.hs
Applicative instance: 


instance (Monoid w, Applicative m) => Applicative (WriterT w m) where
    pure a  = WriterT $ pure (a, mempty)
    f <*> v = WriterT $ liftA2 k (runWriterT f) (runWriterT v)
      where k ~(a, w) ~(b, w') = (a b, w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (WriterT w m) where
    return a = writer (a, mempty)
    m >>= k  = WriterT $ do
        ~(a, w)  <- runWriterT m
        ~(b, w') <- runWriterT (k a)
        return (b, w `mappend` w')
    fail msg = WriterT $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Data/Functor/Reverse.hs
Applicative instance: 


-- | Derived instance.
instance (Applicative f) => Applicative (Reverse f) where
    pure a = Reverse (pure a)
    Reverse f <*> Reverse a = Reverse (f <*> a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Data/Functor/Identity.hs
Applicative instance: 


instance Applicative Identity where
    pure a = Identity a
    Identity f <*> Identity x = Identity (f x)
Monad instance: 


instance Monad Identity where
    return a = Identity a
    m >>= k  = k (runIdentity m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Data/Functor/Compose.hs
Applicative instance: 


instance (Applicative f, Applicative g) => Applicative (Compose f g) where
    pure x = Compose (pure (pure x))
    Compose f <*> Compose x = Compose ((<*>) <$> f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Data/Functor/Product.hs
Applicative instance: 


instance (Applicative f, Applicative g) => Applicative (Product f g) where
    pure x = Pair (pure x) (pure x)
    Pair f g <*> Pair x y = Pair (f <*> x) (g <*> y)
Monad instance: 


instance (Monad f, Monad g) => Monad (Product f g) where
    return x = Pair (return x) (return x)
    Pair m n >>= f = Pair (m >>= fstP . f) (n >>= sndP . f)
      where
        fstP (Pair a _) = a
        sndP (Pair _ b) = b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Data/Functor/Constant.hs
Applicative instance: 


instance (Monoid a) => Applicative (Constant a) where
    pure _ = Constant mempty
    Constant x <*> Constant y = Constant (x `mappend` y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/resource-simple-0.2/src/Control/Monad/Resource.hs
Applicative instance: 



------------------------------------------------------------------------------
instance Monad m => Applicative (ResourceT m) where
    pure = return
    (<*>) = ap
Monad instance: 



------------------------------------------------------------------------------
instance Monad m => Monad (ResourceT m) where
    return = ResourceT . const . return
    ResourceT m >>= f = ResourceT $ \r -> m r >>= \a ->
        let ResourceT m' = f a in m' r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sqlite-simple-0.4.9.0/Database/SQLite/Simple/Ok.hs
Applicative instance: 


instance Applicative Ok where
    pure = Ok

    Errors es <*> _ = Errors es
    _ <*> Errors es = Errors es
    Ok f <*> Ok a   = Ok (f a)
Monad instance: 


instance Monad Ok where
    return = Ok

    Errors es >>= _ = Errors es
    Ok a      >>= f = f a

    fail str = Errors [SomeException (ErrorCall str)]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/probability-0.2.5/src/Numeric/Probability/Distribution.hs
Monad instance: 


instance Num prob => Monad (T prob) where
  return   = certainly
  d >>= f  = Cons [(y,q*p) | (x,p) <- decons d, (y,q) <- decons (f x)]
  fail _   = Cons []
Applicative instance: 


instance Num prob => Applicative (T prob) where
  pure     = certainly
  fm <*> m = Cons [(f x,q*p) | (f,p) <- decons fm, (x,q) <- decons m]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/probability-0.2.5/src/Numeric/Probability/Either.hs
Applicative instance: 


instance Applicative m => Applicative (EitherT a m) where
   pure a = EitherT $ pure $ Right a
   EitherT af <*> EitherT am =
      EitherT $
      liftA2 (\ef em ->
         case ef of
            Left b -> Left b
            Right f ->
               case em of
                  Left b -> Left b
                  Right m -> Right $ f m) af am
Monad instance: 


instance Monad m => Monad (EitherT a m) where
   return a = EitherT $ return $ Right a
   EitherT m >>= f  =  EitherT $ do
      e <- m
      case e of
         Left b -> return $ Left b
         Right a ->
            case f a of
               EitherT n -> n
   fail s = EitherT $ fail s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/probability-0.2.5/src/Numeric/Probability/Random.hs
Monad instance: 


instance Monad T where
   return x = Cons (return x)
   Cons x >>= y =
      Cons (decons . y =<< x)
Applicative instance: 


instance Applicative T where
   pure x = Cons (pure x)
   fm <*> m = Cons (decons fm <*> decons m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/memory-0.9/Data/ByteArray/Pack/Internal.hs
Applicative instance: 


instance Applicative Packer where
    pure  = returnPacker
    (<*>) = appendPacker
Monad instance: 


instance Monad Packer where
    return = returnPacker
    (>>=)  = bindPacker
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/memory-0.9/Data/ByteArray/Parse.hs
Monad instance: 


instance Monad (Parser byteArray) where
    fail errorMsg = Parser $ \buf err _ -> err buf ("failed: " ++ errorMsg)
    return v = Parser $ \buf _ ok -> ok buf v
    m >>= k = Parser $ \buf err ok ->
         runParser m buf err (\buf' a -> runParser (k a) buf' err ok)
Applicative instance: 

instance Applicative (Parser byteArray) where
    pure      = return
    (<*>) d e = d >>= \b -> e >>= \a -> return (b a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hindley-milner-0.1.0.0/src/Language/HM/AlgorithmW.hs
Applicative instance: 


instance Applicative W where
    pure x = W $ \_ n -> return (x, n)

    (W m) <*> (W m') = W $ \ctx n -> do
        (f, n')  <- m ctx n
        (x, n'') <- m' ctx n'
        return (f x, n'')
Monad instance: 


instance Monad W where
    W m >>= f = W $ \ctx n -> do
        (r, n') <- m ctx n
        let W m' = f r in m' ctx n'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/nntp-0.0.4/src/Network/NNTP/Internal.hs
Applicative instance: 

instance (Functor m, Monad m) => Applicative (NntpT m) where
    pure = return
    (<*>) = ap
Monad instance: 

instance Monad m => Monad (NntpT m) where
    m >>= f  = NntpT $ \s -> do (s', v) <- runNntpT m s
                                case v of
                                  Left e -> return $! (s, Left e)
                                  Right a -> runNntpT (f a) s'
    return x = NntpT $ \s -> return $! (s, Right x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/packer-0.1.9/Data/Packer/Internal.hs
Monad instance: 


instance Monad Packing where
    return = returnPacking
    (>>=)  = bindPacking
Applicative instance: 


instance Applicative Packing where
    pure  = returnPacking
    (<*>) = apPacking
Monad instance: 


instance Monad Unpacking where
    return = returnUnpacking
    (>>=)  = bindUnpacking
Applicative instance: 


instance Applicative Unpacking where
    pure  = returnUnpacking
    (<*>) = apUnpacking
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/asn1-encoding-0.9.4/Data/ASN1/Get.hs
Applicative instance: 


instance Applicative Get where
    pure  = return
    (<*>) = ap
Monad instance: 


-- Definition directly from Control.Monad.State.Strict
instance Monad Get where
    return a = Get $ \ s0 b0 m0 p0 _ ks -> ks s0 b0 m0 p0 a

    m >>= g  = Get $ \s0 b0 m0 p0 kf ks ->
        let ks' s1 b1 m1 p1 a = unGet (g a) s1 b1 m1 p1 kf ks
         in unGet m s0 b0 m0 p0 kf ks'

    fail     = failDesc
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/polyseq-0.1.2.1/src/Language/Haskell/FreeTheorems/Variations/PolySeq/M.hs
Monad instance: 


instance Monad M where
    return a = M (\s -> [(a,s)])
    M m >>= k = M (\s -> concatMap (\(a,s') -> case k a of M l -> l s') (m s))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sneathlane-haste-2/SneathLane/Widget.hs
Applicative instance: 


instance (Functor f) => Applicative (Widget f) where
  pure = Finish

  (<*>) wf w = bindW (\fn -> bindW (Finish . fn) w) wf
Monad instance: 


instance (Functor f) => Monad (Widget f) where
  return = Finish

  (>>=) = flip bindW
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/generic-random-0.3.0.0/src/Generic/Random/Boltzmann.hs
Applicative instance: 


instance Num r => Applicative (ConstModule r) where
  pure _ = ConstModule 1
  ConstModule x <*> ConstModule y = ConstModule (x * y)
Applicative instance: 


instance MonadRandomLike m => Applicative (Weighted m) where
  pure a = Weighted [(1, pure a)]
  f' <*> a' = Weighted [(u * v, f <*> a)]
    where
      (u, f) = runWeighted f'
      (v, a) = runWeighted a'
Applicative instance: 


instance Module f => Applicative (Pointiful f) where
  pure a = Zero (pure a)
  Zero f <*> Zero x = Zero (f <*> x)
  Zero f <*> Pointiful xs = Pointiful (fmap (f <*>) xs)
  Pointiful fs <*> Zero x = Pointiful (fmap (<*> x) fs)
  Pointiful fs <*> Pointiful xs = Pointiful (convolute fs xs)
    where
      convolute fs xs = zipWith3 sumOfProducts [0 ..] (inits' fs) (inits' xs)
      inits' = tail . inits
      sumOfProducts k f x = asum (zipWith3 (times k) [0 ..] f (reverse x))
      times k k1 f x = fromInteger (binomial k k1) <.> f <*> x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/generic-random-0.3.0.0/src/Generic/Random/Internal/Types.hs
Applicative instance: 


instance Applicative (RejectT m) where
  pure a = RejectT $ \_maxSize size _retry cont ->
    cont size a
  RejectT f <*> RejectT x = RejectT $ \maxSize size retry cont ->
    f maxSize size retry $ \size f_ ->
      x maxSize size retry $ \size x_ ->
        cont size (f_ x_)
Monad instance: 


instance Monad (RejectT m) where
  RejectT x >>= f = RejectT $ \maxSize size retry cont ->
    x maxSize size retry $ \size x_ ->
      unRejectT (f x_) maxSize size retry cont
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/generic-random-0.3.0.0/src/Generic/Random/Internal/Generic.hs
Applicative instance: 


instance Applicative (Freq sized) where
  pure = Freq . pure . pure
  Freq f <*> Freq x = Freq (liftA2 (<*>) f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Adaptive-0.23/Control/Monad/Adaptive/OrderedList.hs
Monad instance: 


instance Ref m r => Monad (OrderedList m r a) where
  return a = inM (return a)
  (OL m) >>= f = OL $ \e -> m e >>= \a -> deOL (f a) e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Adaptive-0.23/Control/Monad/Adaptive.hs
Monad instance: 


instance Ref m r => Monad (Changeable m r) where
  return a   = Ch $ \k -> k a
  Ch m >>= f = Ch $ \k -> m $ \a -> deCh (f a) k
Monad instance: 


instance Ref m r => Monad (Adaptive m r) where
  return a   = Ad $ \e -> return a
  Ad m >>= f = Ad $ \e -> m e >>= \a -> deAd (f a) e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/Test/QuickCheck.hs
Applicative instance: 


instance Applicative QueryDenotation where
  pure    = QueryDenotation . pure . pure . pure
  f <*> x = QueryDenotation ((liftA2 . liftA2 . liftA2) ($)
                                (unQueryDenotation f) (unQueryDenotation x))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Constant.hs
Applicative instance: 


instance Applicative (Constant a) where
  pure = Constant . pure
  Constant f <*> Constant x = Constant (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/Distinct.hs
Applicative instance: 


instance Applicative (Distinctspec a) where
  pure = Distinctspec . pure
  Distinctspec f <*> Distinctspec x = Distinctspec (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/RunQuery.hs
Applicative instance: 


-- TODO: Seems like this one should be simpler!
instance Applicative (QueryRunner c) where
  pure = flip (QueryRunner (P.lmap (const ()) PP.empty)) (const False)
         . pure
         . pure
  QueryRunner uf rf bf <*> QueryRunner ux rx bx =
    QueryRunner (P.dimap (\x -> (x,x)) (const ()) (uf PP.***! ux)) ((<*>) <$> rf <*> rx) (liftA2 (||) bf bx)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/TableMaker.hs
Applicative instance: 


instance Applicative (ViewColumnMaker a) where
  pure = ViewColumnMaker . pure
  ViewColumnMaker f <*> ViewColumnMaker x = ViewColumnMaker (f <*> x)
Applicative instance: 


instance Applicative (ColumnMaker a) where
  pure = ColumnMaker . pure
  ColumnMaker f <*> ColumnMaker x = ColumnMaker (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/Values.hs
Applicative instance: 


instance Applicative (Valuesspec a) where
  pure = Valuesspec . pure
  Valuesspec f <*> Valuesspec x = Valuesspec (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/Aggregate.hs
Applicative instance: 


instance Applicative (Aggregator a) where
  pure = Aggregator . pure
  Aggregator f <*> Aggregator x = Aggregator (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/Unpackspec.hs
Applicative instance: 


instance Applicative (Unpackspec a) where
  pure = Unpackspec . pure
  Unpackspec f <*> Unpackspec x = Unpackspec (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/QueryArr.hs
Applicative instance: 


instance Applicative (QueryArr a) where
  pure = arr . const
  f <*> g = arr (uncurry ($)) <<< (f &&& g)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/PackMap.hs
Applicative instance: 


instance Applicative (PackMap a b s) where
  pure x = PackMap (pure (pure (pure x)))
  PackMap f <*> PackMap x = PackMap (liftA2 (liftA2 (<*>)) f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/Binary.hs
Applicative instance: 


instance Applicative (Binaryspec a) where
  pure = Binaryspec . pure
  Binaryspec f <*> Binaryspec x = Binaryspec (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/Table.hs
Applicative instance: 


instance Applicative (Writer a) where
  pure x = Writer (fmap (const ()) (pure x))
  Writer f <*> Writer x = Writer (liftA2 (\_ _ -> ()) f x)
Applicative instance: 


instance Applicative (TableProperties a) where
  pure x = TableProperties (pure x) (View x)
  TableProperties fw (View fv) <*> TableProperties xw (View xv) =
    TableProperties (fw <*> xw) (View (fv xv))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lazy-search-0.1.1.0/src/Control/Search.hs
Applicative instance: 


instance Applicative Minimal where
  pure a = Value (Unit a)
  sf <*> sa = fmap (uncurry ($)) (pair sf sa)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aeson-native-0.3.3.2/Data/Aeson/Types.hs
Monad instance: 


instance Monad Result where
    return = Success
    {-# INLINE return #-}
    Success a >>= k = k a
    Error err >>= _ = Error err
    {-# INLINE (>>=) #-}
Applicative instance: 


instance Applicative Result where
    pure  = return
    {-# INLINE pure #-}
    (<*>) = ap
    {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Parser where
    m >>= g = Parser $ \kf ks -> let ks' a = runParser (g a) kf ks
                                 in runParser m kf ks'
    {-# INLINE (>>=) #-}
    return a = Parser $ \_kf ks -> ks a
    {-# INLINE return #-}
    fail msg = Parser $ \kf _ks -> kf msg
    {-# INLINE fail #-}
Applicative instance: 


instance Applicative Parser where
    pure  = return
    {-# INLINE pure #-}
    (<*>) = apP
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/union-find-array-0.1.0.2/src/Control/Monad/Union.hs
Monad instance: 


instance Monad (UnionM l) where
    return x =  U (return x)
    f >>= b = U (runU f >>= runU . b)
Applicative instance: 


instance Applicative (UnionM l) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hxt-9.3.1.9/src/Text/XML/HXT/Arrow/Pickle/Xml.hs
Applicative instance: 


instance Applicative Unpickler where
    pure a      = UP $ \ st -> (Right a, st)
    uf <*> ua   = UP $ \ st ->
                  let (f, st') = runUP uf st in
                  case f of
                    Left err -> (Left err, st')
                    Right f' -> runUP (fmap f' ua) st'
Monad instance: 


instance Monad Unpickler where
    return      = pure
    u >>= f     = UP $ \ st ->
                  let (r, st') = runUP u st in
                  case r of
                    Left err -> (Left err, st')
                    Right v  -> runUP (f v) st'
    fail        = throwMsg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hermit-1.0.1/src/HERMIT/Plugin/Types.hs
Monad instance: 


instance Monad m => Monad (PluginT m) where
    return = PluginT . return
    PluginT m >>= k = PluginT (m >>= unPluginT . k)
    fail = Fail.fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hermit-1.0.1/src/HERMIT/Shell/Types.hs
Monad instance: 


-- TODO: type CLM = CLT IO

-- | Our own custom instance of Monad for CLT so we don't have to depend on
-- newtype deriving to do the right thing for fail.
instance Monad m => Monad (CLT m) where
    return = CLT . return
    (CLT m) >>= k = CLT (m >>= unCLT . k)
    fail = Fail.fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hermit-1.0.1/src/HERMIT/Monad.hs
Applicative instance: 


instance Applicative HermitM where
  pure :: a -> HermitM a
  pure = return

  (<*>) :: HermitM (a -> b) -> HermitM a -> HermitM b
  (<*>) = ap
Monad instance: 


instance Monad HermitM where
  return :: a -> HermitM a
  return a = HermitM $ \ env -> return (return (mkResult env a))

  (>>=) :: HermitM a -> (a -> HermitM b) -> HermitM b
  (HermitM gcm) >>= f =
        HermitM $ \ env -> gcm env >>= runKureM (\ (HermitMResult c ls a) ->
                                                        let env' = env { hEnvChanged = c, hEnvLemmas = ls }
                                                        in  runHermitM (f a) env')
                                                (return . fail)

  fail :: String -> HermitM a
  fail = Fail.fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/codec-0.1.1/Data/Codec/Codec.hs
Applicative instance: 


-- Build up a serializer in parallel to a deserializer.
instance (Applicative fw, Applicative fr) => Applicative (Codec' fr fw w) where
  pure x = Codec (pure x) (const $ pure ())
  Codec f fw <*> Codec x xw
    = Codec (f <*> x) (\w -> fw w *> xw w)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unagi-chan-0.4.0.0/src/Control/Concurrent/Chan/Unagi/NoBlocking/Types.hs
Applicative instance: 


instance  Applicative Element where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad Element where
    fail _ = Element (return Nothing)
    return = Element . return . return
    x >>= f = Element $ do
        v <- tryRead x
        case v of
            Nothing -> return Nothing
            Just y  -> tryRead (f y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Nomyx-Language-0.7.6/src/Language/Nomyx/Expression.hs
Monad instance: 


#else
instance Typeable1 (Exp NoEffect) where
    typeOf1 _ = mkTyConApp (mkTyCon3 "main" "Language.Nomyx.Expression" "Exp NoEffect") []

instance Typeable1 (Exp Effect) where
    typeOf1 _ = mkTyConApp (mkTyCon3 "main" "Language.Nomyx.Expression" "Exp Effect") []

instance Typeable a => Show (Exp NoEffect a) where
   show e = "<" ++ (show $ typeOf e) ++ ">"

instance Typeable a => Show (Exp Effect a) where
   show e = "<" ++ (show $ typeOf e) ++ ">"
#endif

instance Monad (Exp a) where
   return = Return
   (>>=) = Bind
Applicative instance: 


instance Applicative (Exp a) where
   pure = Return
   f <*> a = do
      f' <- f
      a' <- a
      return $ f' a'
Applicative instance: 


instance Applicative Event where
   pure = PureEvent
   (<*>) = AppEvent
Monad instance: 


instance Monad Event where
   (>>=) = BindEvent
   return = PureEvent
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/json-sop-0.2.0.1/src/Generics/SOP/Util/PartialResult.hs
Monad instance: 


instance Functor f => Monad (Partial f) where
  return = PZero
  fail   = Fail . return

  Fail e   >>= _ = Fail e
  PZero a  >>= f = f a
  PSucc fa >>= f = PSucc (fmap (>>= f) fa)
Applicative instance: 


instance Functor f => Applicative (Partial f) where
  pure = return
  f <*> a = do f' <- f ; a' <- a ; return (f' a')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hsc3-lang-0.9/Sound/SC3/Lang/Pattern/Step.hs
Monad instance: 


instance M.Monad (P s) where
    (>>=) p f = Continue p (\x q -> f x `M.mappend` (>>=) q f)
    return = Value
Applicative instance: 


instance A.Applicative (P s) where
    pure = prepeat
    (<*>) = Apply
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hsc3-lang-0.9/Sound/SC3/Lang/Pattern/List.hs
Applicative instance: 


instance A.Applicative P where
    pure = M.return
    (<*>) = M.ap
Monad instance: 


instance Monad P where
    m >>= f = pconcatMap f m
    return x = P [x]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haste-perch-0.1.0.9/Haste/Perch.hs
Applicative instance: 

instance Applicative PerchM
Monad instance: 


instance Monad PerchM where
   (>>) x y= mappend (unsafeCoerce x) y
   (>>=) = error "bind (>>=) invocation in the Perch monad creating DOM elements"
   return  = mempty
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haste-perch-0.1.0.9/Haste/App/Perch.hs
Applicative instance: 

instance Applicative PerchM
Monad instance: 


instance Monad PerchM where
   (>>) x y= mappend (unsafeCoerce x) y
   (>>=) = error "bind (>>=) invocation in the Perch monad creating DOM elements"
   return  = mempty
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/glpk-hs-0.3.5/Data/LinearProgram/GLPK/Types.hs
Monad instance: 


instance Monad GLPK where
        {-# INLINE return #-}
        {-# INLINE (>>=) #-}
        return x = GLP $ \ _ -> return x
        m >>= k = GLP $ \ lp -> do      x <- execGLPK m lp
                                        execGLPK (k x) lp
Applicative instance: 


instance Applicative GLPK where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/EitherT-0.2.0/src/Control/Monad/Trans/Either.hs
Monad instance: 


instance Monad m => Monad (EitherT l m) where
  -- We can't support "fail" because we don't have a
  -- (String -> l). But we can at least make it a Left, with the error inside
  -- it as a pure exception.
  fail = EitherT . return . Left . error
  return = EitherT . return . Right
  EitherT x >>= f = EitherT $ do
    res <- x
    case res of
      Right r -> runEitherT . f $ r
      Left l -> return (Left l)
Applicative instance: 

instance Applicative f => Applicative (EitherT l f) where
  pure = inEitherT0 . pure . pure
  (<*>) = inEitherT2 . liftA2 . liftA2 $ id
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cryptonite-0.9/Crypto/Random/Types.hs
Applicative instance: 


instance DRG gen => Applicative (MonadPseudoRandom gen) where
    pure a     = MonadPseudoRandom $ \g -> (a, g)
    (<*>) fm m = MonadPseudoRandom $ \g1 ->
        let (f, g2) = runPseudoRandom fm g1
            (a, g3) = runPseudoRandom m g2
         in (f a, g3)
Monad instance: 


instance DRG gen => Monad (MonadPseudoRandom gen) where
    return a    = MonadPseudoRandom $ \g -> (a, g)
    (>>=) m1 m2 = MonadPseudoRandom $ \g1 ->
        let (a, g2) = runPseudoRandom m1 g1
         in runPseudoRandom (m2 a) g2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cryptonite-0.9/Crypto/Error/Types.hs
Applicative instance: 


instance Applicative CryptoFailable where
    pure a     = CryptoPassed a
    (<*>) fm m = fm >>= \p -> m >>= \r2 -> return (p r2)
Monad instance: 

instance Monad CryptoFailable where
    return a = CryptoPassed a
    (>>=) m1 m2 = do
        case m1 of
            CryptoPassed a -> m2 a
            CryptoFailed e -> CryptoFailed e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/loops-0.2.0.2/src/Control/Monad/Loop/Internal.hs
Applicative instance: 


instance Applicative (LoopT m) where
    {-# INLINE pure #-}
    pure a = LoopT $ \yield -> yield a
    {-# INLINE (<*>) #-}
    fs <*> as = LoopT $ \yield next ->
        runLoopT fs (\f -> runLoopT (fmap f as) yield) next
Monad instance: 


instance Monad (LoopT m) where
    {-# INLINE return #-}
    return = pure
    {-# INLINE (>>=) #-}
    as >>= f = LoopT $ \yield next ->
        runLoopT as (\a -> runLoopT (f a) yield) next
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/DysFRP-0.1/Control/DysFRP/Internal.hs
Applicative instance: 


instance Applicative Behavior where
    pure x = Behavior $ pure x
    b1 <*> b2 = Behavior $ openBehavior b1 <*> openBehavior b2
Monad instance: 


instance Monad Behavior where
    return = pure
    b >>= bf = Behavior $ openBehavior b >>= openBehavior . bf
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/language-javascript-0.6.0.8/dist/build/Language/JavaScript/Parser/Lexer.hs
