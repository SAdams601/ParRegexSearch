Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/nettle-frp-0.1.1/src/Nettle/FRPControl/AFRPTask.hs
Monad instance: 



------------------------------------------------------------------------------
-- Monad instance
------------------------------------------------------------------------------

instance Monad (Task a b) where
    tk >>= f = Task (\k -> (unTask tk) (\c -> unTask (f c) k))
    return x = Task (\k -> k x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/GLFW-0.5.2.5/Setup.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (StateT s m) where
  pure a  = StateT $ \s -> return (a, s)
  f <*> x = StateT $ \s -> do
        ~(f', s')  <- runStateT f s
        ~(x', s'') <- runStateT x s'
        return (f' x', s'')
Monad instance: 


instance (Functor m, Monad m) => Monad (StateT s m) where
    return = pure
    m >>= k  = StateT $ \s -> do
        ~(a, s') <- runStateT m s
        runStateT (k a) s'
    fail str = StateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/york-lava-0.2/modules/Lava/JList.hs
Monad instance: 


instance Monad JList where
  return a = One a
  Zero >>= f = Zero
  One a >>= f = f a
  (as :+: bs) >>= f = (as >>= f) :+: (bs >>= f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/york-lava-0.2/modules/Recipe.hs
Monad instance: 


instance Monad (RWS r w s) where
  return a = RWS (\r s -> (s, [], a))
  m >>= f = RWS (\r s -> let (s0, w0, a) = runRWS m r s
                             (s1, w1, b) = runRWS (f a) r s0
                         in  (s1, w0 ++ w1, b))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tardis-0.4.1.0/Control/Monad/Trans/Tardis.hs
Monad instance: 



-- Instances
-------------------------------------------------

instance MonadFix m => Monad (TardisT bw fw m) where
  return x = tardis $ \s -> (x, s)
  m >>= f  = TardisT $ \ ~(bw, fw) -> do
    rec (x,  ~(bw'', fw' )) <- runTardisT m (bw', fw)
        (x', ~(bw' , fw'')) <- runTardisT (f x) (bw, fw')
    return (x', (bw'', fw''))
Applicative instance: 


instance MonadFix m => Applicative (TardisT bw fw m) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SGplus-1.1/Data/SG/Vector/Basic.hs
Applicative instance: 


instance Applicative Pair where
  pure a = Pair (a, a)
  (<*>) (Pair (fa, fb)) (Pair (a, b)) = Pair (fa a, fb b)
Applicative instance: 


instance Applicative Triple where
  pure a = Triple (a, a, a)
  (<*>) (Triple (fa, fb, fc)) (Triple (a, b, c)) = Triple (fa a, fb b, fc c)
Applicative instance: 


instance Applicative Quad where
  pure a = Quad (a, a, a, a)
  (<*>) (Quad (fa, fb, fc, fd)) (Quad (a, b, c, d))
    = Quad (fa a, fb b, fc c, fd d)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SGplus-1.1/Data/SG/Geometry/ThreeDim.hs
Applicative instance: 


instance Applicative Point3' where
  pure a = Point3 (a, a, a)
  (<*>) (Point3 (fa, fb, fc)) (Point3 (a, b, c)) = Point3 (fa a, fb b, fc c)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SGplus-1.1/Data/SG/Geometry/TwoDim.hs
Applicative instance: 


instance Applicative Point2' where
  pure a = Point2 (a, a)
  (<*>) (Point2 (fa, fb)) (Point2 (a, b)) = Point2 (fa a, fb b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SGplus-1.1/Data/SG/Matrix.hs
Applicative instance: 


instance Applicative c => Applicative (SquareMatrix c) where
  pure = SquareMatrix . pure . pure
  (SquareMatrix f) <*> (SquareMatrix m) = SquareMatrix $ (fmap (<*>) f) <*> m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monoid-subclasses-0.4.2.1/Data/Monoid/Instances/Positioned.hs
Applicative instance: 


instance Applicative OffsetPositioned where
   pure = OffsetPositioned 0
   OffsetPositioned _ f <*> OffsetPositioned p c = OffsetPositioned p (f c)
Applicative instance: 


instance Applicative LinePositioned where
   pure = LinePositioned 0 0 0
   LinePositioned _ _ _ f <*> LinePositioned p l lp c = LinePositioned p l lp (f c)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monoid-subclasses-0.4.2.1/Data/Monoid/Instances/Concat.hs
Applicative instance: 


instance Applicative Concat where
   pure a = Concat (Seq.singleton a)
   Concat x <*> Concat y = Concat (x <*> y)
   Concat x *> Concat y = Concat (x *> y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monoid-subclasses-0.4.2.1/Data/Monoid/Instances/Stateful.hs
Applicative instance: 


instance Monoid a => Applicative (Stateful a) where
   pure m = Stateful (m, mempty)
   Stateful (f, s1) <*> Stateful (x, s2) = Stateful (f x, s1 <> s2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rev-state-0.1.2/src/Control/Monad/Trans/RevState.hs
Monad instance: 


instance MonadFix m => Monad (StateT s m) where
  return x = state $ \s -> (x, s)
  m >>= f = StateT $ \s -> do
    rec
      (x, s'') <- runStateT m s'
      (x', s') <- runStateT (f x) s
    return (x', s'')
Applicative instance: 


instance MonadFix m => Applicative (StateT s m) where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CC-delcont-alt-0.1.1.1/Generator2.hs
Monad instance: 


instance Monad Identity where
    return = Identity
    m >>= f = f $ runIdentity m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CC-delcont-alt-0.1.1.1/Bench_nondet.hs
Monad instance: 


instance Monad CPS where
    return x = CPS $ \k -> k x
    m >>= f  = CPS $ \k -> unCPS m (\a -> unCPS (f a) k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-ran-0.1.0/Control/Monad/Ran.hs
Applicative instance: 


instance Applicative (Ran Identity) where
    pure = returnRanCodensity
    (<*>) = apRanCodensity
Monad instance: 


instance Monad (Ran Identity) where
    return = returnRanCodensity
    (>>=) = bindRanCodensity
Applicative instance: 


instance Applicative (Ran (State s)) where
    pure = returnRanCodensity
    (<*>) = apRanCodensity
Monad instance: 


instance Monad (Ran (State s)) where
    return = returnRanCodensity
    (>>=) = bindRanCodensity
Applicative instance: 


instance Monoid w => Applicative (Ran (Writer w)) where
    pure = returnRanCodensity
    (<*>) = apRanCodensity
Monad instance: 


instance Monoid w => Monad (Ran (Writer w)) where
    return = returnRanCodensity
    (>>=) = bindRanCodensity
Applicative instance: 


instance Applicative (Ran IO) where
    pure = returnRanCodensity
    (<*>) = apRanCodensity
Monad instance: 


instance Monad (Ran IO) where
    return = returnRanCodensity
    (>>=) = bindRanCodensity
Applicative instance: 


instance Applicative (Ran (ST s)) where
    pure = returnRanCodensity
    (<*>) = apRanCodensity
Monad instance: 


instance Monad (Ran (ST s)) where
    return = returnRanCodensity
    (>>=) = bindRanCodensity
Applicative instance: 


instance Applicative (Ran STM) where
    pure = returnRanCodensity
    (<*>) = apRanCodensity
Monad instance: 


instance Monad (Ran STM) where
    return = returnRanCodensity
    (>>=) = bindRanCodensity
Applicative instance: 


instance Applicative f => Applicative (Ran (Yoneda f)) where
    pure = liftRan . pure
    m <*> n = liftRan (lowerRan m <*> lowerRan n)
Monad instance: 


instance Monad f => Monad (Ran (Yoneda f)) where
    return = liftRan . return
    m >>= k = liftRan (lowerRan m >>= lowerRan . k)
Monad instance: 


instance Monad (Ran Maybe) where
    return x = Ran (\k -> Endo (\_ -> runIdentity (k x)))
    Ran g >>= f = Ran (\k -> Endo (\z -> appEndo (g (\a -> Identity (appEndo (getRan (f a) k) z))) z))
    fail _ = mzero
Applicative instance: 


instance Applicative (Ran Maybe) where
    pure x = Ran (\k -> Endo (\_ -> runIdentity (k x)))
    Ran f <*> Ran g = Ran (\k -> Endo (\z -> appEndo (f (\f' -> Identity (appEndo (g (k . f')) z))) z))
Monad instance: 


instance Error e => Monad (Ran (Either e)) where
    return x = Ran (\k -> ErrorH (\_ -> runIdentity (k x)))
    fail = throwError . strMsg
    Ran g >>= f = Ran (\k -> ErrorH (\z -> getErrorH (g (\a -> Identity (getErrorH (getRan (f a) k) z))) z))
Applicative instance: 


instance Applicative (Ran ((->)e)) where
    pure = return
    Ran f <*> Ran g = Ran (\k r -> runIdentity (k (f Identity r (g Identity r))))
Monad instance: 


instance Monad (Ran ((->)e)) where
    return a = Ran (\f _ -> runIdentity (f a))
    Ran f >>= h = Ran (\k r -> getRan (h (f Identity r)) k r)
Applicative instance: 


instance Applicative (Ran (Reader e)) where
    pure = return
    Ran f <*> Ran g = Ran (\k -> Reader (\r -> runIdentity (k (runReader (f Identity) r (runReader (g Identity) r)))))
Monad instance: 


instance Monad (Ran (Reader e)) where
    return a = Ran (\f -> Reader (\_ -> runIdentity (f a)))
    Ran f >>= h = Ran (\k -> Reader (\r -> runReader(getRan (h (runReader (f Identity) r)) k) r))
Applicative instance: 


instance RanMonad m => Applicative (Ran (ReaderT e m)) where
    pure = inRan . return
    f <*> g = inRan (outRan f `ap` outRan g)
Monad instance: 


instance RanMonad m => Monad (Ran (ReaderT e m)) where
    return = inRan . return
    m >>= f = inRan (outRan m >>= outRan . f)
Applicative instance: 


instance (RanMonad m, Error e) => Applicative (Ran (ErrorT e m)) where
    pure = inRan . return
    f <*> g = inRan (outRan f `ap` outRan g)
Monad instance: 


instance (RanMonad m, Error e)  => Monad (Ran (ErrorT e m)) where
    return = inRan . return
    m >>= f = inRan (outRan m >>= outRan . f)
Applicative instance: 


instance (Monoid w, RanMonad m) => Applicative (Ran (WriterT w m)) where
    pure = inRan . return
    f <*> g = inRan (outRan f `ap` outRan g)
Monad instance: 


instance (Monoid w, RanMonad m) => Monad (Ran (WriterT w m)) where
    return = inRan . return
    m >>= f = inRan (outRan m >>= outRan . f)
Applicative instance: 


instance (Monoid w, RanMonad m) => Applicative (Ran (SW.WriterT w m)) where
    pure = inRan . return
    f <*> g = inRan (outRan f `ap` outRan g)
Monad instance: 


instance (Monoid w, RanMonad m) => Monad (Ran (SW.WriterT w m)) where
    return = inRan . return
    m >>= f = inRan (outRan m >>= outRan . f)
Applicative instance: 


instance RanMonad m => Applicative (Ran (StateT e m)) where
    pure = inRan . return
    f <*> g = inRan (outRan f `ap` outRan g)
Monad instance: 


instance RanMonad m => Monad (Ran (StateT s m)) where
    return = inRan . return
    m >>= f = inRan (outRan m >>= outRan . f)
Applicative instance: 


instance RanMonad m => Applicative (Ran (SS.StateT e m)) where
    pure = inRan . return
    f <*> g = inRan (outRan f `ap` outRan g)
Monad instance: 


instance RanMonad m => Monad (Ran (SS.StateT s m)) where
    return = inRan . return
    m >>= f = inRan (outRan m >>= outRan . f)
Applicative instance: 


instance (RanMonad m, Monoid w) => Applicative (Ran (RWST r w s m)) where
    pure = inRan . return
    f <*> g = inRan (outRan f `ap` outRan g)
Monad instance: 


instance (RanMonad m, Monoid w) => Monad (Ran (RWST r w s m)) where
    return = inRan . return
    m >>= f = inRan (outRan m >>= outRan . f)
Applicative instance: 


instance (RanMonad m, Monoid w) => Applicative (Ran (SR.RWST r w s m)) where
    pure = inRan . return
    f <*> g = inRan (outRan f `ap` outRan g)
Monad instance: 


instance (RanMonad m, Monoid w) => Monad (Ran (SR.RWST r w s m)) where
    return = inRan . return
    m >>= f = inRan (outRan m >>= outRan . f)
Applicative instance: 


instance Applicative (Codensity f) where
    pure x = Codensity (\k -> k x)
    Codensity f <*> Codensity x = Codensity (\k -> f (\f' -> x (k . f')))
Monad instance: 


instance Monad (Codensity f) where
    return x = Codensity (\k -> k x)
    Codensity m >>= k = Codensity
        (\c -> m (\a -> getCodensity (k a) c))
Applicative instance: 


instance Applicative (Ran (Codensity f)) where
    pure = returnRanCodensity
    (<*>) = apRanCodensity
Monad instance: 


instance Monad (Ran (Codensity f)) where
    return = returnRanCodensity
    (>>=) = bindRanCodensity
Applicative instance: 


instance Applicative f => Applicative (Yoneda f) where
    pure a = Yoneda (\f -> pure (f a))
    m <*> n = Yoneda (\f -> getYoneda m (f .) <*> getYoneda n id)
Monad instance: 


instance Monad f => Monad (Yoneda f) where
    return a = Yoneda (\f -> return (f a))
    m >>= k = Yoneda (\f -> getYoneda m id >>= \a -> getYoneda (k a) f)
Applicative instance: 


instance Applicative (Ran (Cont r)) where
    pure = returnRanCodensity
    (<*>) = apRanCodensity
Monad instance: 


instance Monad (Ran (Cont r)) where
    return = returnRanCodensity
    (>>=) = bindRanCodensity
Monad instance: 


instance Monad (Ran (ContT r m)) where
    return = returnRanCodensity
    (>>=) = bindRanCodensity
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/attoparsec-0.9.1.2/tests/QCSupport.hs
Applicative instance: 


instance Applicative NonEmpty where
    NonEmpty f <*> NonEmpty a = NonEmpty (f a)
    pure a                    = NonEmpty a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/attoparsec-0.9.1.2/Data/Attoparsec/Zepto.hs
Monad instance: 


instance Monad Parser where
    return a = Parser $ \s -> (# OK a, s #)
    {-# INLINE return #-}

    m >>= k   = Parser $ \s -> case runParser m s of
                                 (# OK a, s' #) -> runParser (k a) s'
                                 (# Fail err, s' #) -> (# Fail err, s' #)
    {-# INLINE (>>=) #-}

    fail msg = Parser $ \s -> (# Fail msg, s #)
Applicative instance: 


instance Applicative Parser where
    pure   = return
    {-# INLINE pure #-}
    (<*>)  = ap
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/search-0.1.0.1/src/Data/Search.hs
Applicative instance: 


instance Applicative (Search a) where
  pure b = Search $ \_ -> b
  fs <*> as = Search $ \p ->
    let go q = q $ optimum as (p.q)
    in  go $ optimum fs (p.go)
Monad instance: 


instance Monad (Search a) where
  return a = Search $ \_ -> a
  Search ma >>= f = Search $ \p ->
    optimum (f (ma (\a -> p (optimum (f a) p)))) p
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/search-0.1.0.1/src/Data/Search/Intensional.hs
Applicative instance: 


instance Applicative (Search a) where
  pure a = Search $ \_ -> return a
  (<*>) = ap
Monad instance: 


instance Monad (Search a) where
  return a = Search $ \_ -> return a
  m >>= k = jn (fmap k m) where
    jn x = Search $ \p -> do
      z <- optimumM x $ \ y -> optimumM y p >>= p
      optimumM z p
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chalmers-lava2000-1.6.1/Lava/Property.hs
Applicative instance: 


instance Applicative Gen where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad Gen where
  return a =
    Gen (\t -> a)

  Gen m >>= k =
    Gen (\(Fork _ t1 t2) -> let a = m t1 ; Gen m2 = k a in m2 t2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/non-empty-0.3/src/Data/Zip.hs
Applicative instance: 


instance (C.Zip f, C.Repeat f) => Applicative (T f) where
   pure a = Cons $ C.repeat a
   Cons f <*> Cons x = Cons $ C.zipWith ($) f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/non-empty-0.3/src/Data/NonEmptyPrivate.hs
Applicative instance: 


instance
   (Applicative f, C.Empty f, C.Cons f, C.Append f) =>
      Applicative (T f) where
   pure = singleton
   (<*>) = apply
Monad instance: 


instance (Monad f, C.Empty f, C.Cons f, C.Append f) =>
      Monad (T f) where
   return = singleton
   (>>=) = bind
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/vector-space-map-0.2.0/src/Data/Map/Vector.hs
Applicative instance: 


instance (Ord k) => Applicative (MapVector k) where
    pure = ConstantMap
    (ConstantMap f) <*> (ConstantMap v) = ConstantMap $ f v
    (ConstantMap f) <*> (MapVector vs)  = MapVector   $ f     <$> vs
    (MapVector fs)  <*> (ConstantMap v) = MapVector   $ ($ v) <$> fs
    (MapVector fs)  <*> (MapVector vs)  = MapVector   $ Map.intersectionWith ($) fs vs
    {-# INLINABLE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hmatrix-tests-0.5.0.0/src/Numeric/LinearAlgebra/Tests.hs
Applicative instance: 


instance Applicative (State s)
  where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad (State s) where
    return a = State $ \s -> (a,s)
    m >>= f = State $ \s -> let (a,s') = runState m s
                            in runState (f a) s'
Applicative instance: 


instance Monad m => Applicative (MaybeT m)
  where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad m => Monad (MaybeT m) where
    return a = MaybeT $ return $ Just a
    m >>= f  = MaybeT $ do
                        res <- runMaybeT m
                        case res of
                                 Nothing -> return Nothing
                                 Just r  -> runMaybeT (f r)
    fail _   = MaybeT $ return Nothing
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtlparse-0.1.4.0/Text/ParserCombinators/MTLParse/MTLParseCore.hs
Applicative instance: 


instance Applicative ( Parse p ) where
  pure = return; (<*>) = ap
Monad instance: 


instance Monad ( Parse a ) where
  return = Parse . \val inp -> [ (val, inp) ]
  Parse pr >>= f
         = Parse ( \st -> concat
             [ runParse ( f a ) rest | ( a, rest ) <- pr st ] )
Applicative instance: 


instance Monad m => Applicative ( ParseT a m ) where
  pure = return; (<*>) = ap
Monad instance: 


instance Monad m => Monad ( ParseT a m ) where
  return b = ParseT $ \a -> return [ (b, a) ]
  ParseT pr >>= f
    = ParseT $ \a ->
        pr a >>=
          liftM concat . mapM ( \(a', rest) -> runParseT (f a') rest )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/caledon-3.2.2.0/Choice.hs
Monad instance: 


instance Monad Choice where
  fail = Fail
  return = Success
  Fail a >>= _ = Fail a
  (m :<|>: m') >>= f = (m >>= f) :<|>: (m' >>= f)
  Success a >>= f = f a
Applicative instance: 


instance Applicative Choice where
  pure = Success
  mf <*> ma = mf >>= (<$> ma)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/Cont.hs
Monad instance: 


instance Monad (Cont r) where
    return a = Cont ($ a)
    m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
Monad instance: 


instance (Monad m) => Monad (ContT r m) where
    return a = ContT ($ a)
    m >>= k  = ContT $ \c -> runContT m (\a -> runContT (k a) c)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/Error.hs
Monad instance: 


instance (Monad m, Error e) => Monad (ErrorT e m) where
    return a = ErrorT $ return (Right a)
    m >>= k  = ErrorT $ do
        a <- runErrorT m
        case a of
            Left  l -> return (Left l)
            Right r -> runErrorT (k r)
    fail msg = ErrorT $ return (Left (strMsg msg))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/Identity.hs
Monad instance: 


instance Monad Identity where
    return a = Identity a
    m >>= k  = k (runIdentity m)
Monad instance: 


instance Monad m => Monad (IdentityT m) where
  return   =  IdentityT . return
  m >>= f  =  IdentityT $ runIdentityT m >>= runIdentityT . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/State/Strict.hs
Monad instance: 


instance Monad (State s) where
    return a = State $ \s -> (a, s)
    m >>= k  = State $ \s -> case runState m s of
                                 (a, s') -> runState (k a) s'
Monad instance: 


instance (Monad m) => Monad (StateT s m) where
    return a = StateT $ \s -> return (a, s)
    m >>= k  = StateT $ \s -> do
        (a, s') <- runStateT m s
        runStateT (k a) s'
    fail str = StateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/State/Lazy.hs
Monad instance: 


instance Monad (State s) where
    return a = State $ \s -> (a, s)
    m >>= k  = State $ \s -> let
        (a, s') = runState m s
        in runState (k a) s'
Monad instance: 


instance (Monad m) => Monad (StateT s m) where
    return a = StateT $ \s -> return (a, s)
    m >>= k  = StateT $ \s -> do
        ~(a, s') <- runStateT m s
        runStateT (k a) s'
    fail str = StateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/Mask.hs
Monad instance: 


instance Monad m => Monad (Tagged tag m) where
  return   = Tag . return
  m >>= f  = Tag $ unTag m >>= unTag . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/RWS/Strict.hs
Monad instance: 


instance (Monoid w) => Monad (RWS r w s) where
    return a = RWS $ \_ s -> (a, s, mempty)
    m >>= k  = RWS $ \r s -> case runRWS m r s of
                                 (a, s',  w) ->
                                     case runRWS (k a) r s' of
                                         (b, s'', w') ->
                                             (b, s'', w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (RWST r w s m) where
    return a = RWST $ \_ s -> return (a, s, mempty)
    m >>= k  = RWST $ \r s -> do
        (a, s', w)  <- runRWST m r s
        (b, s'',w') <- runRWST (k a) r s'
        return (b, s'', w `mappend` w')
    fail msg = RWST $ \_ _ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/RWS/Lazy.hs
Monad instance: 


instance (Monoid w) => Monad (RWS r w s) where
    return a = RWS $ \_ s -> (a, s, mempty)
    m >>= k  = RWS $ \r s -> let
        (a, s',  w)  = runRWS m r s
        (b, s'', w') = runRWS (k a) r s'
        in (b, s'', w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (RWST r w s m) where
    return a = RWST $ \_ s -> return (a, s, mempty)
    m >>= k  = RWST $ \r s -> do
        ~(a, s', w)  <- runRWST m r s
        ~(b, s'',w') <- runRWST (k a) r s'
        return (b, s'', w `mappend` w')
    fail msg = RWST $ \_ _ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/Reader.hs
Monad instance: 


instance Monad (Reader r) where
    return a = Reader $ \_ -> a
    m >>= k  = Reader $ \r -> runReader (k (runReader m r)) r
Monad instance: 


instance (Monad m) => Monad (ReaderT r m) where
    return a = ReaderT $ \_ -> return a
    m >>= k  = ReaderT $ \r -> do
        a <- runReaderT m r
        runReaderT (k a) r
    fail msg = ReaderT $ \_ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/Zipper.hs
Monad instance: 


instance (MonadTrans t1, MonadTrans t2, Monad m) => Monad ((t1 :> t2) m) where
  return x  = returnZ x
  m >>= f   = m `bindZ` f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/Views.hs
Monad instance: 


instance Monad m => Monad (MonadStateReaderT s m) where
  return   = MonadStateReaderT . return
  x >>= f  = MonadStateReaderT $ runMonadStateReaderT x >>= runMonadStateReaderT . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/List.hs
Monad instance: 


instance (Monad m) => Monad (ListT m) where
    return a = ListT $ return [a]
    m >>= k  = ListT $ do
        a <- runListT m
        b <- mapM (runListT . k) a
        return (concat b)
    fail _ = ListT $ return []
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/Writer/Strict.hs
Monad instance: 


instance (Monoid w) => Monad (Writer w) where
    return a = Writer (a, mempty)
    m >>= k  = Writer $ case runWriter m of
                            (a, w) -> case runWriter (k a) of
                                (b, w') -> (b, w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (WriterT w m) where
    return a = WriterT $ return (a, mempty)
    m >>= k  = WriterT $ do
        (a, w)  <- runWriterT m
        (b, w') <- runWriterT (k a)
        return (b, w `mappend` w')
    fail msg = WriterT $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mzv-0.1.0.2/src/Control/Monad/Writer/Lazy.hs
Monad instance: 


instance (Monoid w) => Monad (Writer w) where
    return a = Writer (a, mempty)
    m >>= k  = Writer $ let
        (a, w)  = runWriter m
        (b, w') = runWriter (k a)
        in (b, w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (WriterT w m) where
    return a = WriterT $ return (a, mempty)
    m >>= k  = WriterT $ do
        ~(a, w)  <- runWriterT m
        ~(b, w') <- runWriterT (k a)
        return (b, w `mappend` w')
    fail msg = WriterT $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/language-c-0.5.0/src/Language/C/Parser/ParserMonad.hs
Applicative instance: 


instance Applicative P where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad P where
  return = returnP
  (>>=) = thenP
  fail m = getPos >>= \pos -> failP pos [m]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/language-c-0.5.0/src/Language/C/Analysis/TravMonad.hs
Applicative instance: 


instance Applicative (Trav s) where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad (Trav s) where
    return x  = Trav (\s -> Right (x,s))
    m >>= k   = Trav (\s -> case unTrav m s of
                              Right (x,s1) -> unTrav (k x) s1
                              Left e       -> Left e)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/DSTM-0.1.2/Control/Distributed/STM/STM.hs
Monad instance: 


instance Monad STM where
  -- (>>=) :: STM a -> (a -> STM b) -> STM b
  (STM tr1)  >>= k = STM (\state -> do
                          stmRes <- tr1 state
                          case stmRes of
                            Success newState v ->
                               let (STM tr2) = k v in
                                 tr2 newState
                            Retry newState -> return (Retry newState)
                            Exception newState e -> return (Exception newState e)
                       )
  -- return :: a -> STM a
  return x      = STM (\state -> return (Success state x))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bake-0.4/src/General/HTML.hs
Applicative instance: 


instance Applicative HTML_ where
    pure = HTML_ mempty
    HTML_ x1 x2 <*> HTML_ y1 y2 = HTML_ (x1 `mappend` y1) (x2 y2)
Monad instance: 


instance Monad HTML_ where
    return = pure
    HTML_ x1 x2 >>= f = let HTML_ y1 y2 = f x2 in HTML_ (x1 `mappend` y1) y2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/STMonadTrans-0.3.3/Control/Monad/ST/Trans.hs
Monad instance: 


#if __GLASGOW_HASKELL__ < 708
isTrue# :: Bool -> Bool
isTrue# x = x
#endif

instance Monad m => Monad (STT s m) where
  return a = STT $ \st -> return (STTRet st a)
  STT m >>= k = STT $ \st ->
    do ret <- m st
       case ret of
         STTRet new_st a ->
             unSTT (k a) new_st
  fail msg = lift (fail msg)
Applicative instance: 


instance (Monad m, Functor m) => Applicative (STT s m) where
  pure a = STT $ \s# -> return (STTRet s# a)
  (STT m) <*> (STT n) = STT $ \s1 ->
                        do (STTRet s2 f) <- m s1
                           (STTRet s3 x) <- n s2
                           return (STTRet s3 (f x))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrowapply-utils-0.2/Control/Arrow/ApplyUtils.hs
Monad instance: 


-- | An instance that lets you work with Arrows that support ArrowApply as monads.
-- | Example:
-- |   myarrow :: ArrowApply a => a Int Int
-- |   myarrow = monadicA $ \v -> do
-- |               let vp1 = v + 1
-- |               v' <- unmonadicA anotherIntToIntArrow vp1
-- |               return (v' * 10)
instance (Arrow a, ArrowApply a) => Monad (ArrowAsMonad a)
  where
    (ArrowAsMonad x) >>= y =
      ArrowAsMonad $ (x >>^ (\v -> (unApplyAsMonad (y v), ()))) >>> app
    return = ArrowAsMonad . arr . const
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/remote-monad-0.2/src/Control/Remote/Monad/Packet/Applicative.hs
Applicative instance: 


instance Applicative (ApplicativePacket c p) where
  pure a = Pure a
  (Pure f) <*> m = fmap f m
  (Command g c)   <*> (Pure a)        = Command (fmap (\ f -> f a) g) c
  (Procedure g p) <*> (Pure a)        = Procedure (fmap (\ f a1 -> f a1 a) g) p
  m <*> (Command g2 c2)               = Command  (m           <*> g2) c2
  m <*> (Procedure g2 p2)             = Procedure (fmap (.) m <*> g2) p2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/remote-monad-0.2/src/Control/Remote/Monad/Types.hs
Applicative instance: 


instance Applicative (RemoteMonad c p) where
  pure a                = Appl (pure a)
  Appl f   <*> Appl g   = Appl (f <*> g)
  Appl f   <*> Bind m k = Bind (pure (,) <*> f <*> m) (\ (a,b) -> pure a <*> k b)
  Bind m k <*> r        = Bind m (\ a -> k a <*> r)

  Appl f   *> Appl g   = Appl (f *> g)
  Appl f   *> Bind m k = Bind (f *> m) k
  Bind m k *> r        = Bind m (\ a -> k a *> r)

  Appl f   <* Appl g   = Appl (f <* g)
  Appl f   <* Bind m k = Bind (pure (,) <*> f <*> m) (\ (a,b) -> pure a <* k b)
  Bind m k <* r        = Bind m (\ a -> k a <* r)
Monad instance: 


instance Monad (RemoteMonad c p) where
  return = pure
  Appl m >>= k    = Bind m k
  Bind m k >>= k2 = Bind m (\ a -> k a >>= k2)

  m1 >> m2 = m1 *> m2
Applicative instance: 


instance Applicative (RemoteApplicative c p) where
  pure a = RemoteApplicative (pure a)
  (RemoteApplicative f) <*> (RemoteApplicative g) = RemoteApplicative (f <*> g)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Cabal-1.8.0.6/Distribution/Compat/ReadP.hs
Monad instance: 
 -- invariant: list is non-empty!

-- Monad, MonadPlus

instance Monad (P s) where
  return x = Result x Fail

  (Get f)      >>= k = Get (\c -> f c >>= k)
  (Look f)     >>= k = Look (\s -> f s >>= k)
  Fail         >>= _ = Fail
  (Result x p) >>= k = k x `mplus` (p >>= k)
  (Final r)    >>= k = final [ys' | (x,s) <- r, ys' <- run (k x) s]

  fail _ = Fail
Monad instance: 


instance Monad (Parser r s) where
  return x  = R (\k -> k x)
  fail _    = R (\_ -> Fail)
  R m >>= f = R (\k -> m (\a -> let R m' = f a in m' k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Cabal-1.8.0.6/Distribution/PackageDescription/Parse.hs
Monad instance: 


instance Monad m => Monad (StT s m) where
    return a = StT (\s -> return (a,s))
    StT f >>= g = StT $ \s -> do
                        (a,s') <- f s
                        runStT (g a) s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Cabal-1.8.0.6/Distribution/ParseUtils.hs
Monad instance: 


instance Monad ParseResult where
        return x = ParseOk [] x
        ParseFailed err >>= _ = ParseFailed err
        ParseOk ws x >>= f = case f x of
                               ParseFailed err -> ParseFailed err
                               ParseOk ws' x' -> ParseOk (ws'++ws) x'
        fail s = ParseFailed (FromString s Nothing)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/archlinux-1.3/Distribution/ArchLinux/PkgBuild.hs
Monad instance: 


instance Monad GetPKG where
  return x       = GetPKG (\s -> Right (x,s))
  fail x         = GetPKG (\_ -> Left x)
  GetPKG m >>= f = GetPKG (\s -> case m s of
                                     Left err -> Left err
                                     Right (a,s1) -> un (f a) s1)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/redHandlers-0.1/Network/HTTP/RedHandler/Response.hs
Monad instance: 
 -- The redirect address is encoded on the headers
--                    | ErrorResp ErrorResp
--data ErrorResp = ForbiddenResp | ...

instance Monad HandlerRsp where
  return x = HandlerRsp [] (Right x)
  (HandlerRsp hdrs (Right x)) >>= f = insertHeaders hdrs $ f x
  (HandlerRsp hdrs (Left non200resp)) >>= f = (HandlerRsp hdrs (Left non200resp))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/welshy-0.1.0.0/Web/Welshy/Action.hs
Applicative instance: 


instance Applicative Action where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad Action where
    return a = Action $ \_ s -> return $ Ok a s
    m >>= k  = Action $ \r s -> runAction m r s >>= \case
        Ok a s1 -> runAction (k a) r s1
        Halt s1 -> return $ Halt s1
        Pass    -> return $ Pass

    fail msg = halt $ error msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hans-3.0.0.1/src/Hans/Monad.hs
Applicative instance: 


instance A.Applicative Hans where
  pure x  = Hans (\ _ k -> k x)

  f <*> x = Hans $ \ e k -> unHans f e
                 $ \ g   -> unHans x e
                 $ \ y   -> k (g y)

  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Hans where
  return  = A.pure

  m >>= f = Hans $ \ e k -> unHans m e
                 $ \ a   -> unHans (f a) e k

  {-# INLINE return #-}
  {-# INLINE (>>=)  #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/numeric-tools-0.2.0.1/Numeric/Tools/Equation.hs
Monad instance: 


instance Monad Root where
  NotBracketed >>= _ = NotBracketed
  SearchFailed >>= _ = SearchFailed
  Root a       >>= m = m a
  return = Root
Applicative instance: 


instance Applicative Root where
  pure  = Root
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/midair-0.2.0.0/Midair/Core.hs
Applicative instance: 


instance Applicative (SFlow a) where
   pure x = SF_Map $ \_ -> x
   (<*>) a b = SF_Compose (SF_Map (\(f, x) -> f x)) (SF_Zip a b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/Cont.hs
Monad instance: 


instance Monad (Cont r) where
    return a = Cont ($ a)
    m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
Monad instance: 


instance (Monad m) => Monad (ContT r m) where
    return a = ContT ($ a)
    m >>= k  = ContT $ \c -> runContT m (\a -> runContT (k a) c)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/Error.hs
Monad instance: 


-- ---------------------------------------------------------------------------
-- Our parameterizable error monad

instance (Error e) => Monad (Either e) where
    return        = Right
    Left  l >>= _ = Left l
    Right r >>= k = k r
    fail msg      = Left (strMsg msg)
Monad instance: 


instance (Monad m, Error e) => Monad (ErrorT e m) where
    return a = ErrorT $ return (Right a)
    m >>= k  = ErrorT $ do
        a <- runErrorT m
        case a of
            Left  l -> return (Left l)
            Right r -> runErrorT (k r)
    fail msg = ErrorT $ return (Left (strMsg msg))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/Identity.hs
Monad instance: 


instance Monad Identity where
    return a = Identity a
    m >>= k  = k (runIdentity m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/State/Strict.hs
Monad instance: 


instance Monad (State s) where
    return a = State $ \s -> (a, s)
    m >>= k  = State $ \s -> case runState m s of
                                 (a, s') -> runState (k a) s'
Monad instance: 


instance (Monad m) => Monad (StateT s m) where
    return a = StateT $ \s -> return (a, s)
    m >>= k  = StateT $ \s -> do
        (a, s') <- runStateT m s
        runStateT (k a) s'
    fail str = StateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/State/Lazy.hs
Monad instance: 


instance Monad (State s) where
    return a = State $ \s -> (a, s)
    m >>= k  = State $ \s -> let
        (a, s') = runState m s
        in runState (k a) s'
Monad instance: 


instance (Monad m) => Monad (StateT s m) where
    return a = StateT $ \s -> return (a, s)
    m >>= k  = StateT $ \s -> do
        ~(a, s') <- runStateT m s
        runStateT (k a) s'
    fail str = StateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/Codensity.hs
Monad instance: 


instance Monad (Codensity f) where
    return a = Codensity (\k -> k a)
    c >>= f  = Codensity (\k -> runCodensity c (\a -> runCodensity (f a) k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/Reader.hs
Monad instance: 


instance Monad (Reader r) where
    return a = Reader $ \_ -> a
    m >>= k  = Reader $ \r -> runReader (k (runReader m r)) r
Monad instance: 


instance (Monad m) => Monad (ReaderT r m) where
    return a = ReaderT $ \_ -> return a
    m >>= k  = ReaderT $ \r -> do
        a <- runReaderT m r
        runReaderT (k a) r
    fail msg = ReaderT $ \_ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/List.hs
Monad instance: 


instance (Monad m) => Monad (ListT m) where
    return a = ListT $ return [a]
    m >>= k  = ListT $ do
        a <- runListT m
        b <- mapM (runListT . k) a
        return (concat b)
    fail _ = ListT $ return []
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/Writer/Strict.hs
Monad instance: 


instance (Monoid w) => Monad (Writer w) where
    return a = Writer (a, mempty)
    m >>= k  = Writer $ case runWriter m of
                            (a, w) -> case runWriter (k a) of
                                (b, w') -> (b, w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (WriterT w m) where
    return a = WriterT $ return (a, mempty)
    m >>= k  = WriterT $ do
        (a, w)  <- runWriterT m
        (b, w') <- runWriterT (k a)
        return (b, w `mappend` w')
    fail msg = WriterT $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmtl-0.1/Control/Monad/Writer/Lazy.hs
Monad instance: 


instance (Monoid w) => Monad (Writer w) where
    return a = Writer (a, mempty)
    m >>= k  = Writer $ let
        (a, w)  = runWriter m
        (b, w') = runWriter (k a)
        in (b, w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (WriterT w m) where
    return a = WriterT $ return (a, mempty)
    m >>= k  = WriterT $ do
        ~(a, w)  <- runWriterT m
        ~(b, w') <- runWriterT (k a)
        return (b, w `mappend` w')
    fail msg = WriterT $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/error-message-1.1/Data/ErrorMessage.hs
Applicative instance: 

-- @-node:gcross.20091202203048.1607:ErrorMessage
-- @-node:gcross.20091202203048.1606:Types
-- @+node:gcross.20091202203048.1608:Instances
-- @+node:gcross.20091202203048.1609:Applicative (Either e a)
-- @@raw
-- @@end_raw

instance (Monoid e) => Applicative (Either e) where
    pure = Right
    (<*>) (Left error2) (Left error1) = Left (error1 `mappend` error2)
    (<*>) (Left error) _ = Left error
    (<*>) _ (Left error) = Left error
    (<*>) (Right function) (Right argument) = Right (function argument)
Applicative instance: 

-- @-node:gcross.20091202203048.1609:Applicative (Either e a)
-- @+node:gcross.20091202203048.1610:Applicative (ErrorT e m a)
instance (Monoid e, Error e, Monad m) => Applicative (ErrorT e m) where
    pure = return
    e_fn <*> e_arg = ErrorT $ liftM2 (<*>) (runErrorT e_fn) (runErrorT e_arg)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gll-0.3.0.9/src/GLL/Parser.hs
Applicative instance: 


instance Applicative (GLL t) where
    (<*>) = ap
    pure  = return
Monad instance: 

instance Monad (GLL t) where
    return a = GLL $ \_ p -> (a, p)
    (GLL m) >>= f  = GLL $ \o p -> let (a, p')  = m o p
                                       (GLL m') = f a
                                    in m' o p'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dejafu-0.3.2.1/Test/DejaFu/Deterministic/Internal/Common.hs
Applicative instance: 


instance Applicative (M n r s) where
    pure x  = M $ \c -> AReturn $ c x
    f <*> v = M $ \c -> runM f (\g -> runM v (c . g))
Monad instance: 


instance Monad (M n r s) where
    return  = pure
    m >>= k = M $ \c -> runM m (\x -> runM (k x) c)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/minioperational-0.4.9/Control/Monad/Trans/Operational/Mini.hs
Applicative instance: 


instance Applicative (ProgramT t m) where
    pure a = ProgramT $ \p _ _ -> p a
    ProgramT mf <*> ProgramT ma = ProgramT $ \p l i -> mf (\f -> ma (p . f) l i) l i
Monad instance: 


instance Monad (ProgramT t m) where
    return a = ProgramT $ \p _ _ -> p a
    ProgramT m >>= k = ProgramT $ \p l i -> m (\a -> unProgramT (k a) p l i) l i
Applicative instance: 


instance Monad m => Applicative (ReifiedProgramT t m) where
    pure = Return
    {-# INLINE pure #-}
    Return f <*> Return a = Return (f a)
    mf <*> m = mf >>= \f -> fmap f m
Monad instance: 


instance Monad m => Monad (ReifiedProgramT t m) where
    return = Return
    {-# INLINE return #-}
    Return a >>= f = f a
    (t :>>= m) >>= k = t :>>= (>>= k) . m
    Lift a c >>= f = Lift a (c >=> f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/minioperational-0.4.9/Control/Monad/Operational/Mini.hs
Applicative instance: 


instance Applicative (Program t) where
    pure a = Program $ \p _ -> p a
    Program mf <*> Program ma = Program $ \p i -> mf (\f -> ma (p . f) i) i
Monad instance: 


instance Monad (Program t) where
    return a = Program $ \p _ -> p a
    Program m >>= k = Program $ \p i -> m (\a -> unProgram (k a) p i) i
Applicative instance: 


instance Applicative (ReifiedProgram t) where
    pure = Return
    {-# INLINE pure #-}
    Return f <*> Return a = Return (f a)
    mf <*> m = mf >>= \f -> fmap f m
Monad instance: 


instance Monad (ReifiedProgram t) where
    return = Return
    {-# INLINE return #-}
    Return a >>= f = f a
    (t :>>= m) >>= k = t :>>= (>>= k) . m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mac-0.1.3.0/MAC/Core.hs
Applicative instance: 


instance Applicative (MAC l) where
    pure = MkMAC . return
    (<*>) (MkMAC f) (MkMAC a) = MkMAC (f <*> a)
Monad instance: 


instance Monad (MAC l) where
   return = pure
   MkMAC m >>= k = ioTCB (m >>= runMAC . k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/protocol-buffers-fork-2.0.16/Text/ProtocolBuffers/Get.hs
Monad instance: 


instance Monad Get where
  return a = seq a $ Get (\sc -> sc a)
  {-# INLINE return #-}
  m >>= k  = Get (\sc -> unGet m (\ a -> seq a $ unGet (k a) sc))
  {-# INLINE (>>=) #-}
  fail = throwError . strMsg
Applicative instance: 


instance Applicative Get where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tuples-homogenous-h98-0.1.1.0/Data/Tuple/Homogenous.hs
Applicative instance: 

instance Applicative Tuple0 where
    pure _ = tuple0
    {-# INLINE pure #-}
    _ <*> _ = tuple0
    {-# INLINE (<*>) #-}
    _  *> _ = tuple0
    {-# INLINE (*>) #-}
    _ <*  _ = tuple0
    {-# INLINE (<*) #-}
Monad instance: 

instance Monad Tuple0 where
    return = pure
    {-# INLINE return #-}
    _ >>= _ = tuple0
    {-# INLINE (>>=) #-}
    (>>)    = (*>)
    {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple1 where
    pure = tuple1
    {-# INLINE pure #-}
    (Tuple1 f) <*> (Tuple1 k) = tuple1 (f k)
    {-# INLINE (<*>) #-}
    _  *> k = k
    {-# INLINE (*>) #-}
    k <*  _ = k
    {-# INLINE (<*) #-}
Monad instance: 

instance Monad Tuple1 where
    return = pure
    {-# INLINE return #-}
    (Tuple1 k) >>= f = f k
    {-# INLINE (>>=) #-}
    (>>)    = (*>)
    {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple2
    where pure x = Tuple2 (x, x)
          {-# INLINE pure #-}
          (<*>) (Tuple2 (f1, f2)) (Tuple2 (x1,
                                                             x2)) = Tuple2 (f1 x1, f2 x2)
          {-# INLINEABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple2
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple2 (x1, x2)) f = Tuple2 (case f x1 of
                                                         Tuple2 (y, _) -> y,
                                                     case f x2 of
                                                         Tuple2 (_, y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple3
    where pure x = Tuple3 (x, x, x)
          {-# INLINE pure #-}
          (<*>) (Tuple3 (f1, f2, f3)) (Tuple3 (x1,
                                                                 x2,
                                                                 x3)) = Tuple3 (f1 x1, f2 x2, f3 x3)
          {-# INLINEABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple3
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple3 (x1, x2, x3)) f = Tuple3 (case f x1 of
                                                             Tuple3 (y, _, _) -> y,
                                                         case f x2 of
                                                             Tuple3 (_, y, _) -> y,
                                                         case f x3 of
                                                             Tuple3 (_, _, y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple4
    where pure x = Tuple4 (x, x, x, x)
          {-# INLINE pure #-}
          (<*>) (Tuple4 (f1, f2, f3, f4)) (Tuple4 (x1,
                                                                     x2,
                                                                     x3,
                                                                     x4)) = Tuple4 (f1 x1,
                                                                                    f2 x2,
                                                                                    f3 x3,
                                                                                    f4 x4)
          {-# INLINEABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple4
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple4 (x1, x2, x3, x4)) f = Tuple4 (case f x1 of
                                                                 Tuple4 (y, _, _, _) -> y,
                                                             case f x2 of
                                                                 Tuple4 (_, y, _, _) -> y,
                                                             case f x3 of
                                                                 Tuple4 (_, _, y, _) -> y,
                                                             case f x4 of
                                                                 Tuple4 (_, _, _, y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple5
    where pure x = Tuple5 (x, x, x, x, x)
          {-# INLINE pure #-}
          (<*>) (Tuple5 (f1, f2, f3, f4, f5)) (Tuple5 (x1,
                                                                         x2,
                                                                         x3,
                                                                         x4,
                                                                         x5)) = Tuple5 (f1 x1,
                                                                                        f2 x2,
                                                                                        f3 x3,
                                                                                        f4 x4,
                                                                                        f5 x5)
          {-# INLINEABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple5
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple5 (x1, x2, x3, x4, x5)) f = Tuple5 (case f x1 of
                                                                     Tuple5 (y, _, _, _, _) -> y,
                                                                 case f x2 of
                                                                     Tuple5 (_, y, _, _, _) -> y,
                                                                 case f x3 of
                                                                     Tuple5 (_, _, y, _, _) -> y,
                                                                 case f x4 of
                                                                     Tuple5 (_, _, _, y, _) -> y,
                                                                 case f x5 of
                                                                     Tuple5 (_, _, _, _, y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple6
    where pure x = Tuple6 (x, x, x, x, x, x)
          {-# INLINE pure #-}
          (<*>) (Tuple6 (f1,
                                           f2,
                                           f3,
                                           f4,
                                           f5,
                                           f6)) (Tuple6 (x1, x2, x3, x4, x5, x6)) = Tuple6 (f1 x1,
                                                                                            f2 x2,
                                                                                            f3 x3,
                                                                                            f4 x4,
                                                                                            f5 x5,
                                                                                            f6 x6)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple6
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple6 (x1,
                                x2,
                                x3,
                                x4,
                                x5,
                                x6)) f = Tuple6 (case f x1 of
                                                     Tuple6 (y, _, _, _, _, _) -> y,
                                                 case f x2 of
                                                     Tuple6 (_, y, _, _, _, _) -> y,
                                                 case f x3 of
                                                     Tuple6 (_, _, y, _, _, _) -> y,
                                                 case f x4 of
                                                     Tuple6 (_, _, _, y, _, _) -> y,
                                                 case f x5 of
                                                     Tuple6 (_, _, _, _, y, _) -> y,
                                                 case f x6 of
                                                     Tuple6 (_, _, _, _, _, y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple7
    where pure x = Tuple7 (x, x, x, x, x, x, x)
          {-# INLINE pure #-}
          (<*>) (Tuple7 (f1,
                                           f2,
                                           f3,
                                           f4,
                                           f5,
                                           f6,
                                           f7)) (Tuple7 (x1,
                                                         x2,
                                                         x3,
                                                         x4,
                                                         x5,
                                                         x6,
                                                         x7)) = Tuple7 (f1 x1,
                                                                        f2 x2,
                                                                        f3 x3,
                                                                        f4 x4,
                                                                        f5 x5,
                                                                        f6 x6,
                                                                        f7 x7)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple7
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple7 (x1,
                                x2,
                                x3,
                                x4,
                                x5,
                                x6,
                                x7)) f = Tuple7 (case f x1 of
                                                     Tuple7 (y, _, _, _, _, _, _) -> y,
                                                 case f x2 of
                                                     Tuple7 (_, y, _, _, _, _, _) -> y,
                                                 case f x3 of
                                                     Tuple7 (_, _, y, _, _, _, _) -> y,
                                                 case f x4 of
                                                     Tuple7 (_, _, _, y, _, _, _) -> y,
                                                 case f x5 of
                                                     Tuple7 (_, _, _, _, y, _, _) -> y,
                                                 case f x6 of
                                                     Tuple7 (_, _, _, _, _, y, _) -> y,
                                                 case f x7 of
                                                     Tuple7 (_, _, _, _, _, _, y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple8
    where pure x = Tuple8 (x, x, x, x, x, x, x, x)
          {-# INLINE pure #-}
          (<*>) (Tuple8 (f1,
                                           f2,
                                           f3,
                                           f4,
                                           f5,
                                           f6,
                                           f7,
                                           f8)) (Tuple8 (x1,
                                                         x2,
                                                         x3,
                                                         x4,
                                                         x5,
                                                         x6,
                                                         x7,
                                                         x8)) = Tuple8 (f1 x1,
                                                                        f2 x2,
                                                                        f3 x3,
                                                                        f4 x4,
                                                                        f5 x5,
                                                                        f6 x6,
                                                                        f7 x7,
                                                                        f8 x8)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple8
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple8 (x1,
                                x2,
                                x3,
                                x4,
                                x5,
                                x6,
                                x7,
                                x8)) f = Tuple8 (case f x1 of
                                                     Tuple8 (y, _, _, _, _, _, _, _) -> y,
                                                 case f x2 of
                                                     Tuple8 (_, y, _, _, _, _, _, _) -> y,
                                                 case f x3 of
                                                     Tuple8 (_, _, y, _, _, _, _, _) -> y,
                                                 case f x4 of
                                                     Tuple8 (_, _, _, y, _, _, _, _) -> y,
                                                 case f x5 of
                                                     Tuple8 (_, _, _, _, y, _, _, _) -> y,
                                                 case f x6 of
                                                     Tuple8 (_, _, _, _, _, y, _, _) -> y,
                                                 case f x7 of
                                                     Tuple8 (_, _, _, _, _, _, y, _) -> y,
                                                 case f x8 of
                                                     Tuple8 (_, _, _, _, _, _, _, y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple9
    where pure x = Tuple9 (x,
                                               x,
                                               x,
                                               x,
                                               x,
                                               x,
                                               x,
                                               x,
                                               x)
          {-# INLINE pure #-}
          (<*>) (Tuple9 (f1,
                                           f2,
                                           f3,
                                           f4,
                                           f5,
                                           f6,
                                           f7,
                                           f8,
                                           f9)) (Tuple9 (x1,
                                                         x2,
                                                         x3,
                                                         x4,
                                                         x5,
                                                         x6,
                                                         x7,
                                                         x8,
                                                         x9)) = Tuple9 (f1 x1,
                                                                        f2 x2,
                                                                        f3 x3,
                                                                        f4 x4,
                                                                        f5 x5,
                                                                        f6 x6,
                                                                        f7 x7,
                                                                        f8 x8,
                                                                        f9 x9)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple9
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple9 (x1,
                                x2,
                                x3,
                                x4,
                                x5,
                                x6,
                                x7,
                                x8,
                                x9)) f = Tuple9 (case f x1 of
                                                     Tuple9 (y, _, _, _, _, _, _, _, _) -> y,
                                                 case f x2 of
                                                     Tuple9 (_, y, _, _, _, _, _, _, _) -> y,
                                                 case f x3 of
                                                     Tuple9 (_, _, y, _, _, _, _, _, _) -> y,
                                                 case f x4 of
                                                     Tuple9 (_, _, _, y, _, _, _, _, _) -> y,
                                                 case f x5 of
                                                     Tuple9 (_, _, _, _, y, _, _, _, _) -> y,
                                                 case f x6 of
                                                     Tuple9 (_, _, _, _, _, y, _, _, _) -> y,
                                                 case f x7 of
                                                     Tuple9 (_, _, _, _, _, _, y, _, _) -> y,
                                                 case f x8 of
                                                     Tuple9 (_, _, _, _, _, _, _, y, _) -> y,
                                                 case f x9 of
                                                     Tuple9 (_, _, _, _, _, _, _, _, y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple10
    where pure x = Tuple10 (x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x)
          {-# INLINE pure #-}
          (<*>) (Tuple10 (f1,
                                            f2,
                                            f3,
                                            f4,
                                            f5,
                                            f6,
                                            f7,
                                            f8,
                                            f9,
                                            f10)) (Tuple10 (x1,
                                                            x2,
                                                            x3,
                                                            x4,
                                                            x5,
                                                            x6,
                                                            x7,
                                                            x8,
                                                            x9,
                                                            x10)) = Tuple10 (f1 x1,
                                                                             f2 x2,
                                                                             f3 x3,
                                                                             f4 x4,
                                                                             f5 x5,
                                                                             f6 x6,
                                                                             f7 x7,
                                                                             f8 x8,
                                                                             f9 x9,
                                                                             f10 x10)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple10
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple10 (x1,
                                 x2,
                                 x3,
                                 x4,
                                 x5,
                                 x6,
                                 x7,
                                 x8,
                                 x9,
                                 x10)) f = Tuple10 (case f x1 of
                                                        Tuple10 (y, _, _, _, _, _, _, _, _, _) -> y,
                                                    case f x2 of
                                                        Tuple10 (_, y, _, _, _, _, _, _, _, _) -> y,
                                                    case f x3 of
                                                        Tuple10 (_, _, y, _, _, _, _, _, _, _) -> y,
                                                    case f x4 of
                                                        Tuple10 (_, _, _, y, _, _, _, _, _, _) -> y,
                                                    case f x5 of
                                                        Tuple10 (_, _, _, _, y, _, _, _, _, _) -> y,
                                                    case f x6 of
                                                        Tuple10 (_, _, _, _, _, y, _, _, _, _) -> y,
                                                    case f x7 of
                                                        Tuple10 (_, _, _, _, _, _, y, _, _, _) -> y,
                                                    case f x8 of
                                                        Tuple10 (_, _, _, _, _, _, _, y, _, _) -> y,
                                                    case f x9 of
                                                        Tuple10 (_, _, _, _, _, _, _, _, y, _) -> y,
                                                    case f x10 of
                                                        Tuple10 (_, _, _, _, _, _, _, _, _, y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple11
    where pure x = Tuple11 (x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x)
          {-# INLINE pure #-}
          (<*>) (Tuple11 (f1,
                                            f2,
                                            f3,
                                            f4,
                                            f5,
                                            f6,
                                            f7,
                                            f8,
                                            f9,
                                            f10,
                                            f11)) (Tuple11 (x1,
                                                            x2,
                                                            x3,
                                                            x4,
                                                            x5,
                                                            x6,
                                                            x7,
                                                            x8,
                                                            x9,
                                                            x10,
                                                            x11)) = Tuple11 (f1 x1,
                                                                             f2 x2,
                                                                             f3 x3,
                                                                             f4 x4,
                                                                             f5 x5,
                                                                             f6 x6,
                                                                             f7 x7,
                                                                             f8 x8,
                                                                             f9 x9,
                                                                             f10 x10,
                                                                             f11 x11)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple11
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple11 (x1,
                                 x2,
                                 x3,
                                 x4,
                                 x5,
                                 x6,
                                 x7,
                                 x8,
                                 x9,
                                 x10,
                                 x11)) f = Tuple11 (case f x1 of
                                                        Tuple11 (y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x2 of
                                                        Tuple11 (_,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x3 of
                                                        Tuple11 (_,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x4 of
                                                        Tuple11 (_,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x5 of
                                                        Tuple11 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x6 of
                                                        Tuple11 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x7 of
                                                        Tuple11 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x8 of
                                                        Tuple11 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x9 of
                                                        Tuple11 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _) -> y,
                                                    case f x10 of
                                                        Tuple11 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _) -> y,
                                                    case f x11 of
                                                        Tuple11 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple12
    where pure x = Tuple12 (x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x)
          {-# INLINE pure #-}
          (<*>) (Tuple12 (f1,
                                            f2,
                                            f3,
                                            f4,
                                            f5,
                                            f6,
                                            f7,
                                            f8,
                                            f9,
                                            f10,
                                            f11,
                                            f12)) (Tuple12 (x1,
                                                            x2,
                                                            x3,
                                                            x4,
                                                            x5,
                                                            x6,
                                                            x7,
                                                            x8,
                                                            x9,
                                                            x10,
                                                            x11,
                                                            x12)) = Tuple12 (f1 x1,
                                                                             f2 x2,
                                                                             f3 x3,
                                                                             f4 x4,
                                                                             f5 x5,
                                                                             f6 x6,
                                                                             f7 x7,
                                                                             f8 x8,
                                                                             f9 x9,
                                                                             f10 x10,
                                                                             f11 x11,
                                                                             f12 x12)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple12
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple12 (x1,
                                 x2,
                                 x3,
                                 x4,
                                 x5,
                                 x6,
                                 x7,
                                 x8,
                                 x9,
                                 x10,
                                 x11,
                                 x12)) f = Tuple12 (case f x1 of
                                                        Tuple12 (y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x2 of
                                                        Tuple12 (_,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x3 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x4 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x5 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x6 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x7 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x8 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x9 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x10 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _) -> y,
                                                    case f x11 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _) -> y,
                                                    case f x12 of
                                                        Tuple12 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple13
    where pure x = Tuple13 (x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x)
          {-# INLINE pure #-}
          (<*>) (Tuple13 (f1,
                                            f2,
                                            f3,
                                            f4,
                                            f5,
                                            f6,
                                            f7,
                                            f8,
                                            f9,
                                            f10,
                                            f11,
                                            f12,
                                            f13)) (Tuple13 (x1,
                                                            x2,
                                                            x3,
                                                            x4,
                                                            x5,
                                                            x6,
                                                            x7,
                                                            x8,
                                                            x9,
                                                            x10,
                                                            x11,
                                                            x12,
                                                            x13)) = Tuple13 (f1 x1,
                                                                             f2 x2,
                                                                             f3 x3,
                                                                             f4 x4,
                                                                             f5 x5,
                                                                             f6 x6,
                                                                             f7 x7,
                                                                             f8 x8,
                                                                             f9 x9,
                                                                             f10 x10,
                                                                             f11 x11,
                                                                             f12 x12,
                                                                             f13 x13)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple13
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple13 (x1,
                                 x2,
                                 x3,
                                 x4,
                                 x5,
                                 x6,
                                 x7,
                                 x8,
                                 x9,
                                 x10,
                                 x11,
                                 x12,
                                 x13)) f = Tuple13 (case f x1 of
                                                        Tuple13 (y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x2 of
                                                        Tuple13 (_,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x3 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x4 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x5 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x6 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x7 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x8 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x9 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x10 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x11 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _) -> y,
                                                    case f x12 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _) -> y,
                                                    case f x13 of
                                                        Tuple13 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple14
    where pure x = Tuple14 (x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x)
          {-# INLINE pure #-}
          (<*>) (Tuple14 (f1,
                                            f2,
                                            f3,
                                            f4,
                                            f5,
                                            f6,
                                            f7,
                                            f8,
                                            f9,
                                            f10,
                                            f11,
                                            f12,
                                            f13,
                                            f14)) (Tuple14 (x1,
                                                            x2,
                                                            x3,
                                                            x4,
                                                            x5,
                                                            x6,
                                                            x7,
                                                            x8,
                                                            x9,
                                                            x10,
                                                            x11,
                                                            x12,
                                                            x13,
                                                            x14)) = Tuple14 (f1 x1,
                                                                             f2 x2,
                                                                             f3 x3,
                                                                             f4 x4,
                                                                             f5 x5,
                                                                             f6 x6,
                                                                             f7 x7,
                                                                             f8 x8,
                                                                             f9 x9,
                                                                             f10 x10,
                                                                             f11 x11,
                                                                             f12 x12,
                                                                             f13 x13,
                                                                             f14 x14)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple14
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple14 (x1,
                                 x2,
                                 x3,
                                 x4,
                                 x5,
                                 x6,
                                 x7,
                                 x8,
                                 x9,
                                 x10,
                                 x11,
                                 x12,
                                 x13,
                                 x14)) f = Tuple14 (case f x1 of
                                                        Tuple14 (y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x2 of
                                                        Tuple14 (_,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x3 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x4 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x5 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x6 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x7 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x8 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x9 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x10 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x11 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x12 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _) -> y,
                                                    case f x13 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _) -> y,
                                                    case f x14 of
                                                        Tuple14 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative Tuple15
    where pure x = Tuple15 (x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x,
                                                x)
          {-# INLINE pure #-}
          (<*>) (Tuple15 (f1,
                                            f2,
                                            f3,
                                            f4,
                                            f5,
                                            f6,
                                            f7,
                                            f8,
                                            f9,
                                            f10,
                                            f11,
                                            f12,
                                            f13,
                                            f14,
                                            f15)) (Tuple15 (x1,
                                                            x2,
                                                            x3,
                                                            x4,
                                                            x5,
                                                            x6,
                                                            x7,
                                                            x8,
                                                            x9,
                                                            x10,
                                                            x11,
                                                            x12,
                                                            x13,
                                                            x14,
                                                            x15)) = Tuple15 (f1 x1,
                                                                             f2 x2,
                                                                             f3 x3,
                                                                             f4 x4,
                                                                             f5 x5,
                                                                             f6 x6,
                                                                             f7 x7,
                                                                             f8 x8,
                                                                             f9 x9,
                                                                             f10 x10,
                                                                             f11 x11,
                                                                             f12 x12,
                                                                             f13 x13,
                                                                             f14 x14,
                                                                             f15 x15)
          {-# INLINABLE (<*>) #-}
          (<*) x _ = x
          {-# INLINE (<*) #-}
          (*>) _ y = y
          {-# INLINE (*>) #-}
Monad instance: 

instance Monad Tuple15
    where return = pure
          {-# INLINE return #-}
          (>>=) (Tuple15 (x1,
                                 x2,
                                 x3,
                                 x4,
                                 x5,
                                 x6,
                                 x7,
                                 x8,
                                 x9,
                                 x10,
                                 x11,
                                 x12,
                                 x13,
                                 x14,
                                 x15)) f = Tuple15 (case f x1 of
                                                        Tuple15 (y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x2 of
                                                        Tuple15 (_,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x3 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x4 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x5 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x6 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x7 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x8 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x9 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x10 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x11 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x12 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _,
                                                                 _) -> y,
                                                    case f x13 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _,
                                                                 _) -> y,
                                                    case f x14 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y,
                                                                 _) -> y,
                                                    case f x15 of
                                                        Tuple15 (_,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 _,
                                                                 y) -> y)
          {-# INLINABLE (>>=) #-}
          (>>) = (*>)
          {-# INLINE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/PermuteEffects-0.2/Control/Permute.hs
Applicative instance: 


-- | 'pure' represents the empty list of computations while '<*>' acts like
-- '++'.
instance Applicative (Effects f) where
  pure             = Nil
  Nil g <*> y      = fmap g y
  Cons a r x <*> y = Cons a r (flip <$> x <*> y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghc-parmake-0.1.9/src/Distribution/Compat/ReadP.hs
Applicative instance: 


instance Applicative (P s) where
  pure x = Result x Fail
  (<*>) = ap
Monad instance: 


instance Monad (P s) where
  return = AP.pure

  (Get f)      >>= k = Get (f >=> k)
  (Look f)     >>= k = Look (f >=> k)
  Fail         >>= _ = Fail
  (Result x p) >>= k = k x `mplus` (p >>= k)
  (Final r)    >>= k = final [ys' | (x,s) <- r, ys' <- run (k x) s]

  fail _ = Fail
Applicative instance: 


instance Applicative (Parser r s) where
  pure x  = R (\k -> k x)
  (<*>) = ap
Monad instance: 


instance Monad (Parser r s) where
  return = AP.pure
  fail _    = R (const Fail)
  R m >>= f = R (\k -> m (\a -> let R m' = f a in m' k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/feldspar-language-0.7/src/Feldspar/Option.hs
Applicative instance: 


instance Applicative Option
  where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad Option
  where
    return = some
    a >>= f = b { isSome = isSome a ? isSome b $ false }
      where
        b = f (fromSome a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fortran-src-0.1.0.3/src/Language/Fortran/ParserMonad.hs
Monad instance: 


instance (Loc b, LastToken b c, Show c) => Monad (Parse b c) where
  return a = Parse $ \s -> ParseOk a s

  (Parse m) >>= f = Parse $ \s ->
    case m s of
      ParseOk a s' -> unParse (f a) s'
      ParseFailed e -> ParseFailed e

  fail msg = Parse $ \s -> ParseFailed ParseError
    { errPos        = (getPos . psAlexInput) s
    , errLastToken  = (getLastToken . psAlexInput) s
    , errFilename   = psFilename s
    , errMsg        = msg }
Applicative instance: 


instance (Loc b, LastToken b c, Show c) => Applicative (Parse b c) where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrowp-0.5.0.2/preprocessor/State.hs
Monad instance: 


instance Monad (State s) where
        return x = State (\n -> (x, n))
        State v >>= f = State (\n -> let (x, n') = v n in runState (f x) n')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/skulk-0.1.3.0/src/Skulk/Deep.hs
Applicative instance: 


#if __GLASGOW_HASKELL__ < 710
instance (Applicative a, Monad a, Applicative b) => Applicative (Deep a b) where
#else
instance (Monad a, Applicative b) => Applicative (Deep a b) where
#endif
    pure = Deep . pure . pure
    (Deep abf) <*> (Deep abx) = Deep $ do
        bf <- abf
        bx <- abx
        let by = bf <*> bx
        return by
Monad instance: 


#if __GLASGOW_HASKELL__ < 710
instance (Applicative a, Monad a, Monad b, Traversable b) => Monad (Deep a b) where
#else
instance (Monad a, Monad b, Traversable b) => Monad (Deep a b) where
#endif
    return = Deep . return . return
    fail = Deep . return . fail
    (Deep abx) >>= f = Deep $ do
        bx <- abx
        let baby = expose . f <$> bx
        let abby = sequenceA baby
        let aby = join <$> abby
        aby
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/skulk-0.1.3.0/src/Skulk/Outcome.hs
Applicative instance: 


instance Applicative Outcome where
    pure = OK
    (OK f) <*> ax = f <$> ax
    (Fail msg) <*> _ = Fail msg
    (Skip msg) <*> _ = Skip msg
Monad instance: 


instance Monad Outcome where
    OK x >>= f = f x
    Fail msg >>= _ = Fail msg
    Skip msg >>= _ = Skip msg
    return = OK
    fail = Fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/async-pool-0.9.0/Control/Concurrent/Async/Pool/Internal.hs
Applicative instance: 


instance Applicative Task where
    pure x = Task $ \_ -> return (return x)
    Task f <*> Task x = Task $ \tg -> do
        xa <- x tg
        x' <- wait <$> async tg xa
        fa <- f tg
        return $ fa <*> x'
Monad instance: 


instance Monad Task where
    return = pure
    Task m >>= f = Task $ \tg -> join (m tg) >>= flip runTask' tg . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/async-pool-0.9.0/Control/Concurrent/Async/Pool/Async.hs
Applicative instance: 


instance Applicative Concurrently where
  pure x = Concurrently $ \_ -> return x
  Concurrently fs <*> Concurrently as =
    Concurrently $ \tg -> (\(f, a) -> f a) <$> concurrently tg (fs tg) (as tg)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/termination-combinators-0.1/Control/Termination.hs
Applicative instance: 


instance Applicative (Gather a) where
    pure _ = Gather id
    Gather xs <*> Gather ys = Gather (xs . ys)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/parsergen-0.2.0.7/src/ParserGen/Parser.hs
Monad instance: 


instance Monad Parser where
    return a = Parser $ \s -> (# OK a, s #)
    {-# INLINE return #-}

    m >>= k   = Parser $ \s -> case runParser m s of
                                 (# OK a, s' #) -> runParser (k a) s'
                                 (# Fail err, s' #) -> (# Fail err, s' #)
    {-# INLINE (>>=) #-}

    fail msg = Parser $ \s -> (# Fail msg, s #)
Applicative instance: 


instance Applicative Parser where
    pure   = return
    {-# INLINE pure #-}
    (<*>)  = ap
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hfusion-0.0.6.1/HFusion/Internal/Compositions.hs
Monad instance: 


instance Monad (TreeT b m) where
  return a = C ($ a)
  C f >>= fc = C$ \k -> f (\a -> runC (fc a) k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pipes-transduce-0.4/src/Pipes/Transduce.hs
Applicative instance: 


{-| 
    'pure' creates a 'Fold1' that does nothing besides draining the
    'Producer'. 

    '<*>' feeds both folds with the data of the same 'Producer'. If any of
    them fails the combination fails.
-}
instance Applicative (Fold1 b e) where
    pure a = Fold1 (pure a)
    Fold1 fa <*> Fold1 a = Fold1 (fa <*> a)
Applicative instance: 


instance Applicative (Fold1_ b e) where
    pure a = ExhaustiveCont (\producer -> do
        r <- runEffect (producer >-> Pipes.drain)
        pure (Right (a,r)))

    TrueFold f1 <*> TrueFold f2 = TrueFold (f1 <*> f2)
    s1 <*> s2 = bifurcate (nonexhaustiveCont s1) (nonexhaustiveCont s2)
        where
        bifurcate fs as = ExhaustiveCont (\producer -> do
            (outbox1,inbox1,seal1) <- spawn' (bounded 1)
            (outbox2,inbox2,seal2) <- spawn' (bounded 1)
            runConceit $
                (\f x r -> (f x,r))
                <$>
                Conceit (fs (fromInput inbox1) `finally` atomically seal1)
                <*>
                Conceit (as (fromInput inbox2) `finally` atomically seal2)
                <*>
                (_Conceit $
                    (runEffect (producer >-> Pipes.tee (toOutput outbox1 *> Pipes.drain)
                                         >->           (toOutput outbox2 *> Pipes.drain)))
                    `finally` atomically seal1
                    `finally` atomically seal2))
Applicative instance: 


instance Applicative (Fold2 b1 b2 e) where
    pure a = Fold2 (pure a)
    Fold2 fa <*> Fold2 a = Fold2 (fa <*> a)
Applicative instance: 


instance Applicative (Fold2_ b1 b2 e) where
    pure a = fmap (const a) (separated_ (pure ()) (pure ()))

    Both fs <*> Both as = Both (\producer1 producer2 -> do
        (outbox1a,inbox1a,seal1a) <- spawn' (bounded 1)
        (outbox2a,inbox2a,seal2a) <- spawn' (bounded 1)
        (outbox1b,inbox1b,seal1b) <- spawn' (bounded 1)
        (outbox2b,inbox2b,seal2b) <- spawn' (bounded 1)
        runConceit $
            (\(f,(),()) (x,(),()) r1 r2 -> (f x,r1,r2))
            <$>
            Conceit (fs (fromInput inbox1a) (fromInput inbox1b) `finally` atomically seal1a `finally` atomically seal1b)
            <*>
            Conceit (as (fromInput inbox2a) (fromInput inbox2b) `finally` atomically seal2a `finally` atomically seal2b)
            <*>
            (_Conceit $
                (runEffect (producer1 >-> Pipes.tee (toOutput outbox1a *> Pipes.drain)
                                      >->           (toOutput outbox2a *> Pipes.drain)))
                `finally` atomically seal1a
                `finally` atomically seal2a)
            <*>
            (_Conceit $
                (runEffect (producer2 >-> Pipes.tee (toOutput outbox1b *> Pipes.drain)
                                      >->           (toOutput outbox2b *> Pipes.drain)))
                `finally` atomically seal1b
                `finally` atomically seal2b))
    First fs <*> First as = First (fs <*> as)
    Second fs <*> Second as = Second (fs <*> as)
    First fs <*> Second as = uncurry ($) <$> separated_ fs as
    Second fs <*> First as = uncurry (flip ($)) <$> separated_ as fs
    First fs <*> Both as =  (\(f,()) x -> f x) <$> separated_ fs (pure ()) <*> Both as
    Both fs <*> First as =  (\f (x,()) -> f x) <$> Both fs <*> separated_ as (pure ())
    Second fs <*> Both as = (\((),f) x -> f x) <$> separated_ (pure ()) fs <*> Both as
    Both fs <*> Second as = (\f ((),x) -> f x) <$> Both fs <*> separated_ (pure ()) as
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/yesod-form-1.4.7.1/Yesod/Form/Input.hs
Applicative instance: 

instance Monad m => Applicative (FormInput m) where
    pure = FormInput . const . const . const . const . return . Right
    (FormInput f) <*> (FormInput x) = FormInput $ \c d e e' -> do
        res1 <- f c d e e'
        res2 <- x c d e e'
        return $ case (res1, res2) of
            (Left a, Left b) -> Left $ a . b
            (Left a, _) -> Left a
            (_, Left b) -> Left b
            (Right a, Right b) -> Right $ a b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/yesod-form-1.4.7.1/Yesod/Form/Types.hs
Applicative instance: 

instance Applicative FormResult where
    pure = FormSuccess
    (FormSuccess f) <*> (FormSuccess g) = FormSuccess $ f g
    (FormFailure x) <*> (FormFailure y) = FormFailure $ x ++ y
    (FormFailure x) <*> _ = FormFailure x
    _ <*> (FormFailure y) = FormFailure y
    _ <*> _ = FormMissing
Applicative instance: 

instance Monad m => Applicative (AForm m) where
    pure x = AForm $ const $ const $ \ints -> return (FormSuccess x, id, ints, mempty)
    (AForm f) <*> (AForm g) = AForm $ \mr env ints -> do
        (a, b, ints', c) <- f mr env ints
        (x, y, ints'', z) <- g mr env ints'
        return (a <*> x, b . y, ints'', c `mappend` z)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pugs-DrIFT-2.2.3.20150815/src/ParseLib2.hs
Monad instance: 


instance Monad Parser where
   -- return      :: a -> Parser a
   return v        = P (\pos inp -> [(v,inp)])

   -- >>=         :: Parser a -> (a -> Parser b) -> Parser b
   (P p) >>= f     = P (\pos inp -> concat [papply (f v) pos out
                                                | (v,out) <- p pos inp])
   fail s          = P (\pos inp -> [])
Applicative instance: 


instance AP.Applicative Parser where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/adjunctions-4.3/src/Control/Comonad/Representable/Store.hs
Applicative instance: 


instance (Applicative w, Monoid (Rep g), Representable g) => Applicative (StoreT g w) where
  pure a = StoreT (pure (pureRep a)) mempty
  StoreT ff m <*> StoreT fa n = StoreT (apRep <$> ff <*> fa) (m `mappend` n)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/adjunctions-4.3/src/Control/Monad/Trans/Contravariant/Adjoint.hs
Applicative instance: 


instance (Adjunction f g, Comonad w) => Applicative (AdjointT f g w) where
  pure = AdjointT . leftAdjunct extract
  (<*>) = ap
Monad instance: 


instance (Adjunction f g, Comonad w) => Monad (AdjointT f g w) where
  return = pure
  AdjointT m >>= f = AdjointT $ contramap (extend (rightAdjunct (runAdjointT . f))) m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/adjunctions-4.3/src/Control/Monad/Trans/Conts.hs
Applicative instance: 


instance Comonad w => Applicative (ContsT r w m) where
  pure x = ContsT $ \f -> extract f x
  (<*>) = ap
Monad instance: 


instance Comonad w => Monad (ContsT r w m) where
  return = pure
  ContsT k >>= f = ContsT $ k . extend (\wa a -> runContsT (f a) wa)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/adjunctions-4.3/src/Control/Monad/Trans/Adjoint.hs
Applicative instance: 


instance (Adjunction f g, Monad m) => Applicative (AdjointT f g m) where
  pure = AdjointT . leftAdjunct return
  (<*>) = ap
Monad instance: 


instance (Adjunction f g, Monad m) => Monad (AdjointT f g m) where
  return = pure
  AdjointT m >>= f = AdjointT $ fmap (>>= rightAdjunct (runAdjointT . f)) m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/adjunctions-4.3/src/Control/Monad/Representable/Reader.hs
Applicative instance: 


instance (Representable f, Applicative m) => Applicative (ReaderT f m) where
  pure = ReaderT . pureRep . pure
  ReaderT ff <*> ReaderT fa = ReaderT (unCo ((<*>) <$> Co ff <*> Co fa))
Monad instance: 


instance (Representable f, Monad m) => Monad (ReaderT f m) where
#if __GLASGOW_HASKELL__ < 710
  return = ReaderT . pureRep . return
#endif
  ReaderT fm >>= f = ReaderT $ tabulate (\a -> index fm a >>= flip index a . getReaderT . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HCodecs-0.5/src/Codec/ByteString/Parser.hs
Monad instance: 


instance Monad Parser where
    return a  = Parser (\s -> Right (a, s))
    m >>= k   = Parser $ \s -> case (unParser m) s of
      Left e -> Left e
      Right (a, s') -> (unParser (k a)) s'
    fail  err  = Parser $ \(S _ _ bytes) ->
        Left (err ++ ". Failed reading at byte position " ++ show bytes)
Applicative instance: 


instance Applicative Parser where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cao-0.1.1/src/Language/CAO/Common/Monad.hs
Monad instance: 


instance Monad CaoResult  where
    return !x = CaoResult $! \ st -> return (Right (x, mempty), st)
    (>>=)     = bindTcMonad
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Top-1.7/src/Top/Monad/StateFix.hs
Monad instance: 


instance Monad m => Monad (StateFixT s m) where
   return  = Fix . return
   m >>= f = Fix (unFix m >>= unFix . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Top-1.7/src/Top/Monad/Select.hs
Monad instance: 


instance Monad m => Monad (Select t m) where
   return a       = Select (return a)
   Select f >>= g = Select (do x <- f
                               let Select h = g x
                               h)
Monad instance: 


instance Monad m => Monad (SelectFix t m) where
   return a          = SelectFix (return a)
   SelectFix f >>= g = SelectFix (do x <- f
                                     let SelectFix h = g x
                                     h)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/language-c-quote-0.9.0/Language/C/Parser/Monad.hs
Applicative instance: 


instance Applicative P where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad P where
    m >>= k = P $ \s ->
        case runP m s of
          Left e         -> Left e
          Right (a, s')  -> runP (k a) s'

    m1 >> m2 = P $ \s ->
        case runP m1 s of
          Left e         -> Left e
          Right (_, s')  -> runP m2 s'

    return a = P $ \s -> Right (a, s)

    fail msg = do
        inp <- getInput
        throw $ ParserException (Loc (alexPos inp) (alexPos inp))
                                (ppr (alexPos inp) <> colon <+> text msg)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pipes-core-0.1.0/Control/Pipe/Common.hs
Monad instance: 


instance Monad m => Monad (Pipe a b m) where
  return r = Pure r []
  Pure r w >>= f = case f r of
    Pure r' w' -> Pure r' (w ++ w')
    Throw e w' -> Throw e (w ++ w')
    p'         -> foldr run p' w
      where
        run m p = M Masked (m >> return p) throwP
  Throw e w >>= _ = Throw e w
  Await k h >>= f = Await (k >=> f) (h >=> f)
  M s m h >>= f = M s (m >>= \p -> return $ p >>= f) (h >=> f)
  Yield x p w >>= f = Yield x (p >>= f) w
Applicative instance: 


instance Monad m => Applicative (Pipe a b m) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/typed-spreadsheet-1.1.0/src/Typed/Spreadsheet.hs
Applicative instance: 


instance Applicative Cell where
    pure a = Cell (pure (empty, pure a))

    Cell mF <*> Cell mX = Cell (liftA2 helper mF mX)
      where
        helper (inputF, foldF) (inputX, foldX) = (input, fold )
          where
            input = fmap Left inputF <|> fmap Right inputX

            fold = Fold.handles _Left foldF <*> Fold.handles _Right foldX
Applicative instance: 


instance Applicative Updatable where
    pure a = Updatable (pure (pure a))

    Updatable mf <*> Updatable mx = Updatable (liftA2 (<*>) mf mx)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ruin-0.1.0.1/Data/Ruin/Eval.hs
Applicative instance: 


instance Applicative Eval where
  {-# INLINE pure #-}
  pure = Done
  {-# INLINE (<*>) #-}
  Done f <*> Done a = Done (f a)
Monad instance: 


instance Monad Eval where
  {-# INLINE return #-}
  return = Done
  {-# INLINE (>>=) #-}
  Done a >>= k = k a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-task-0.1.0/Control/Monad/Trans/Task.hs
Monad instance: 


instance Monad m => Monad (TaskT e m) where
  return = TaskT . return
  (>>=) m f = TaskT $ runTaskT m >>= runTaskT . f
  fail _ = TaskT $ ContT $ \_ -> return EXIT
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unm-hip-0.3.1.6/Data/Image/Boxed.hs
Applicative instance: 


instance Applicative BoxedImage where
  pure a = Image 1 1 (V.fromList [a])
  (<*>) (Image rows cols partial) (Image rows' cols' toApply)
    | rows /= rows' && cols /= cols' = error "Cannot apply images of unequal dimensions."
    | otherwise = Image rows cols (V.fromList applied) where
       indices = [ r*cols + c | r <- [0..rows-1], c <- [0..cols-1]]
       applied = map func indices
       func i = (partial V.! i) (toApply V.! i)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/twilio-0.1.3.1/src/Control/Monad/Twilio.hs
Applicative instance: 


instance Applicative m => Applicative (TwilioT m) where
  pure = liftTwilioT . pure
  f <*> v = TwilioT $ \r -> getTwilioT f r <*> getTwilioT v r
Monad instance: 


{-
instance Alternative m => Alternative (TwilioT m) where
  empty = liftTwilioT empty
  m <|> n = TwilioT $ \r -> getTwilioT m r <|> getTwilioT n r
-}

instance Monad m => Monad (TwilioT m) where
  return a = TwilioT (return . const a)
  m >>= k = TwilioT $ \client -> do
    a <- getTwilioT m client
    getTwilioT (k a) client
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liquidhaskell-0.6.0.0/tests/pos/ToyMVar.hs
Monad instance: 


instance Monad IO where --  GHC-Base.lhs
  return = undefined
  _ >> _ = undefined
Applicative instance: 


instance Applicative IO where
  pure  = undefined
  (<*>) = undefined
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liquidhaskell-0.6.0.0/tests/pos/CountMonad.hs
Applicative instance: 

instance Applicative Count where
  pure  = undefined
  (<*>) = undefined
Monad instance: 


instance Monad Count where
{-@
instance Monad Count where 
  >>=    :: forall <r :: Count a -> Prop, p :: Count b -> Prop, q :: Count b -> Prop>.
            {x::Count a <<r>>, y :: Count b <<p>>  |- {v:Count b | count v == count x + count y} <: Count b <<q>>} 
            Count a <<r>> -> (a -> Count b<<p>>) -> Count b <<q>> ; 
  >>     :: x:Count a -> y:Count b -> {v:Count b | count v == count x + count y}; 
  return :: a -> {v:Count a | count v == 0 } 
@-}
  return x        = let r = Count x in assertCount 0 (Count x)
  (Count x) >>= f = let r = f x in assertCount (getCount (Count x) + getCount r) r
  x >> y = assertCount (getCount x + getCount y) y
  fail          = error
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liquidhaskell-0.6.0.0/tests/pos/StateConstraints0.hs
Monad instance: 



instance Monad (ST s) where
  {-@ instance Monad ST s where
    return :: forall s a <p :: s -> Prop >. x:a -> ST <p, {\s v -> v == s}, {\s v -> x == v}> s a;
    >>= :: forall s a b  < pref :: s -> Prop, postf :: s -> s -> Prop
              , pre  :: s -> Prop, postg :: s -> s -> Prop
              , post :: s -> s -> Prop
              , rg   :: s -> a -> Prop
              , rf   :: s -> b -> Prop
              , r    :: s -> b -> Prop
              , pref0 :: a -> Prop 
              >. 
       {x::s<pre> |- a<rg x> <: a<pref0>}      
       {x::s<pre>, y::s<postg x> |- b<rf y> <: b<r x>}
       {xx::s<pre>, w::s<postg xx> |- s<postf w> <: s<post xx>}
       {ww::s<pre> |- s<postg ww> <: s<pref>}
       (ST <pre, postg, rg> s a)
    -> (a<pref0> -> ST <pref, postf, rf> s b)
    -> (ST <pre, post, r> s b) ;
    >>  :: forall s a b  < pref :: s -> Prop, postf :: s -> s -> Prop
              , pre  :: s -> Prop, postg :: s -> s -> Prop
              , post :: s -> s -> Prop
              , rg   :: s -> a -> Prop
              , rf   :: s -> b -> Prop
              , r    :: s -> b -> Prop
              >. 
       {x::s<pre>, y::s<postg x> |- b<rf y> <: b<r x>}
       {xx::s<pre>, w::s<postg xx> |- s<postf w> <: s<post xx>}
       {ww::s<pre> |- s<postg ww> <: s<pref>}
       (ST <pre, postg, rg> s a)
    -> (ST <pref, postf, rf> s b)
    -> (ST <pre, post, r> s b)
    @-}
  return x     = ST $ \s -> (x, s)
  (ST g) >>= f = ST (\x -> case g x of {(y, s) -> (runState (f y)) s})
  (ST g) >>  f = ST (\x -> case g x of {(y, s) -> (runState f) s})
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liquidhaskell-0.6.0.0/tests/neg/StateConstraints0.hs
Monad instance: 


instance Monad (ST s) where
  {-@ instance Monad ST s where
    return :: forall s a <p :: s -> Prop >. x:a -> ST <p, {\s v -> v == s}, {\s v -> x == v}> s a;
    >>= :: forall s a b  < pref :: s -> Prop, postf :: s -> s -> Prop
              , pre  :: s -> Prop, postg :: s -> s -> Prop
              , post :: s -> s -> Prop
              , rg   :: s -> a -> Prop
              , rf   :: s -> b -> Prop
              , r    :: s -> b -> Prop
              , pref0 :: a -> Prop 
              >. 
       {x::s<pre> |- a<rg x> <: a<pref0>}      
       {x::s<pre>, y::s<postg x> |- b<rf y> <: b<r x>}
       {xx::s<pre>, w::s<postg xx> |- s<postf w> <: s<post xx>}
       {ww::s<pre> |- s<postg ww> <: s<pref>}
       (ST <pre, postg, rg> s a)
    -> (a<pref0> -> ST <pref, postf, rf> s b)
    -> (ST <pre, post, r> s b) ;
    >>  :: forall s a b  < pref :: s -> Prop, postf :: s -> s -> Prop
              , pre  :: s -> Prop, postg :: s -> s -> Prop
              , post :: s -> s -> Prop
              , rg   :: s -> a -> Prop
              , rf   :: s -> b -> Prop
              , r    :: s -> b -> Prop
              >. 
       {x::s<pre>, y::s<postg x> |- b<rf y> <: b<r x>}
       {xx::s<pre>, w::s<postg xx> |- s<postf w> <: s<post xx>}
       {ww::s<pre> |- s<postg ww> <: s<pref>}
       (ST <pre, postg, rg> s a)
    -> (ST <pref, postf, rf> s b)
    -> (ST <pre, post, r> s b)

    @-}
  return x     = ST $ \s -> (x, s)
  (ST g) >>= f = ST (\x -> case g x of {(y, s) -> (runState (f y)) s})
  (ST g) >>  f = ST (\x -> case g x of {(y, s) -> (runState f) s})
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liquidhaskell-0.6.0.0/src/Language/Haskell/Liquid/Transforms/CoreToLogic.hs
Monad instance: 



instance Monad LogicM where
  return = LM . const . Left
  (LM m) >>= f
    = LM $ \s -> case m s of
                (Left x) -> (runM (f x)) s
                (Right x) -> Right x
Applicative instance: 


instance Applicative LogicM where
  pure = LM . const . Left
  (LM f) <*> (LM m)
    = LM $ \s -> case (f s, m s) of
                  (Left f , Left x ) -> Left $ f x
                  (Right f, Left _ ) -> Right f
                  (Left _ , Right x) -> Right x
                  (Right _, Right x) -> Right x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liquidhaskell-0.6.0.0/src/Language/Haskell/Liquid/Desugar710/Coverage.hs
Applicative instance: 


instance Applicative TM where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad TM where
  return a = TM $ \ _env st -> (a,noFVs,st)
  (TM m) >>= k = TM $ \ env st ->
                                case m env st of
                                  (r1,fv1,st1) ->
                                     case unTM (k r1) env st1 of
                                       (r2,fv2,st2) ->
                                          (r2, fv1 `plusOccEnv` fv2, st2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/clash-ghc-0.6.9/src-bin/GhciMonad.hs
Applicative instance: 


instance Applicative GHCi where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad GHCi where
  (GHCi m) >>= k  =  GHCi $ \s -> m s >>= \a -> unGHCi (k a) s
  return a  = GHCi $ \_ -> return a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rose-trees-0.0.4.3/src/Data/Tree/Knuth/Forest.hs
Applicative instance: 


-- | Zippy
instance Applicative KnuthForest where
  pure x = Fork x Nil Nil
  Nil <*> _ = Nil
  _ <*> Nil = Nil
  (Fork f fc fs) <*> (Fork x xc xs) =
    Fork (f x) (fc <*> xc) (fs <*> xs)
Monad instance: 


-- | Breadth-first
instance Monad KnuthForest where
  return = pure
  Nil            >>= _ = Nil
  (Fork x xc xs) >>= f = f x `union` (xs >>= f) `union` (xc >>= f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rose-trees-0.0.4.3/src/Data/Tree/Knuth.hs
Applicative instance: 



instance Applicative KnuthTree where
  pure x = KnuthTree (x,KF.Nil)
  (KnuthTree (f,fs)) <*> (KnuthTree (x,xs)) = KnuthTree (f x,fs <*> xs)
Monad instance: 


instance Monad KnuthTree where
  return x = KnuthTree (x,KF.Nil)
  (KnuthTree (x,xs)) >>= f =
    let (KnuthTree (y,_)) = f x
    in KnuthTree (y,xs >>= (snd . unKnuthTree . f))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hakyll-4.8.3.2/src/Hakyll/Core/Compiler/Internal.hs
Monad instance: 



--------------------------------------------------------------------------------
instance Monad Compiler where
    return x = Compiler $ \_ -> return $ CompilerDone x mempty
    {-# INLINE return #-}

    Compiler c >>= f = Compiler $ \r -> do
        res <- c r
        case res of
            CompilerDone x w    -> do
                res' <- unCompiler (f x) r
                return $ case res' of
                    CompilerDone y w'     -> CompilerDone y (w `mappend` w')
                    CompilerSnapshot s c' -> CompilerSnapshot s $ do
                        compilerTell w  -- Save dependencies!
                        c'
                    CompilerError e       -> CompilerError e
                    CompilerRequire i c'  -> CompilerRequire i $ do
                        compilerTell w  -- Save dependencies!
                        c'

            CompilerSnapshot s c' -> return $ CompilerSnapshot s (c' >>= f)
            CompilerError e       -> return $ CompilerError e
            CompilerRequire i c'  -> return $ CompilerRequire i (c' >>= f)
    {-# INLINE (>>=) #-}

    fail = compilerThrow . return
    {-# INLINE fail #-}
Applicative instance: 



--------------------------------------------------------------------------------
instance Applicative Compiler where
    pure x = return x
    {-# INLINE pure #-}

    f <*> x = f >>= \f' -> fmap f' x
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/transactional-events-0.1.0.0/Control/Concurrent/CHS.hs
Monad instance: 
 -- blocks until var is written

instance Monad CHS where
    return = CHS . return
    fail _ = CHS (prompt Fail)
    m >>= f = CHS $ runCHS m >>= runCHS . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/djinn-2014.9.7/src/LJT.hs
Applicative instance: 


instance Applicative P where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad P where
    return x = P $ \ s -> [(s, x)]
    P m >>= f = P $ \ s ->
        [ y | (s',x) <- m s, y <- unP (f x) s' ]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/list-tries-0.6.3/Data/ListTrie/Base/Classes.hs
Applicative instance: 


instance Applicative Identity where
   pure = Id
   Id f <*> Id a = Id (f a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Coadjute-0.1.1/Coadjute/Rule.hs
Monad instance: 


instance Monad Coadjute where
   return        = Co . return
   (Co rs) >>= f = Co (rs >>= unCo.f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/smartcheck-0.2.2/src/Test/SmartCheck/Types.hs
Monad instance: 


instance Monad Result where
  return a            = Result a
  BaseType      >>= _ = BaseType
  FailedPreCond >>= _ = FailedPreCond
  FailedProp    >>= _ = FailedProp
  Result a      >>= f = f a
Applicative instance: 


instance Applicative Result where
 pure  = return
 (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/demarcate-0.1.0/src/Control/Monad/Trans/Demarcate/Internal.hs
Monad instance: 


instance Monad (Demarcate t m) where
    return  = Demarcate . return
    m >>= f = Demarcate $ unDemarcate m >>= unDemarcate . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/action-permutations-0.0.0.1/Control/Applicative/Permutation.hs
Applicative instance: 


-- These instances actually only need Applicative p, but we specify
-- Alternative for uniformity and to preserve the abstraction.

instance Alternative p => Applicative (Perms p) where
    pure v = Choice (Just v) []
    t1@(Choice d1 bs1) <*> t2@(Choice d2 bs2) =
        Choice (d1 <*> d2) (map ins2 bs1 ++ map ins1 bs2)
          where
            ins1 (Branch perm p) = Branch ((.) <$> t1 <*> perm) p
            ins2 (Branch perm p) = Branch (flip <$> perm <*> t2) p
Applicative instance: 


instance Alternative p => Applicative (Branch p) where
    pure v = branch (pure v)
    Branch perm1 p1 <*> Branch perm2 p2 =
        Branch (lift_id <$> perm1 <*> perm2) ((,) <$> p1 <*> p2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/maude-0.6.1/src/Language/Maude/Exec/XML.hs
Monad instance: 


instance Monad Parser where
    return = Ok
    ParseError e s >>= _ = ParseError e s
    Ok r >>= k = k r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aeson-applicative-0.1.0.0/Data/Aeson/JsonInfo.hs
Applicative instance: 


instance Applicative (JsonFieldInfo t) where
  pure = Pure
  (<*>) = App
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/parsimony-1.3/src/Parsimony/Prim.hs
Monad instance: 


instance Monad (Parser t) where
  return a  = pure a
  p >>= f   = P $ \s ->
    case unP p s of
      R True r  -> R True $ case r of
                              Error e -> Error e
                              Ok a s1 ->
                                case unP (f a) s1 of
                                  R _ r1 -> r1
      R False r -> case r of
                     Error e  -> R False $ Error e
                     Ok a s1  -> unP (f a) s1

  fail m  = parseError (newErrorMessage (Message m))
Applicative instance: 


instance Applicative (Parser t) where
  pure a  = P $ \s -> R False $ Ok a s
  (<*>)   = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/csound-expression-dynamic-0.1.6/src/Csound/Dynamic/Types/Dep.hs
Applicative instance: 


instance Monad m => Applicative (DepT m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad m => Monad (DepT m) where
    return = DepT . return
    ma >>= mf = DepT $ unDepT ma >>= unDepT . mf
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/IOR-0.1/src/System/IOR/Internal.hs
Monad instance: 


instance Monad (IOR r rs) where
    return  = IOR . const . return
    m >>  n = IOR $ liftA2 (>>)  (unIOR m) (unIOR n)
    m >>= f = IOR $ liftA2 (>>=) (unIOR m) (flip $ unIOR . f)

    {-# INLINE return #-}
    {-# INLINE (>>)   #-}
    {-# INLINE (>>=)  #-}
Applicative instance: 


instance Applicative (IOR r rs) where
    pure  = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/vimus-0.2.1/src/Vimus/Command/Parser.hs
Applicative instance: 


instance Applicative Parser where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad Parser where
  fail      = parserFail . ParseError
  return a  = Parser $ \input -> Right (a, input)
  p1 >>= p2 = Parser $ \input -> runParser p1 input >>= uncurry (runParser . p2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-unlift-ref-0.2.0/Control/Monad/Trans/State/Ref.hs
Applicative instance: 


instance Applicative m => Applicative (StateRefT ref s m) where
    pure = StateRefT . const . pure
    {-# INLINE pure #-}
    StateRefT f <*> StateRefT g = StateRefT $ \x -> f x <*> g x
    {-# INLINE (<*>) #-}
Monad instance: 

instance Monad m => Monad (StateRefT ref s m) where
    return = StateRefT . const . return
    {-# INLINE return #-}
    StateRefT f >>= g = StateRefT $ \x -> do
        a <- f x
        unStateRefT (g a) x
    {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-unlift-ref-0.2.0/Control/Monad/Trans/RWS/Ref.hs
Applicative instance: 


instance Applicative m => Applicative (RWSRefT refw refs r w s m) where
    pure m = RWSRefT $ \_ _ _ -> pure m
    {-# INLINE pure #-}
    RWSRefT f <*> RWSRefT g = RWSRefT $ \x y z -> f x y z <*> g x y z
    {-# INLINE (<*>) #-}
Monad instance: 

instance Monad m => Monad (RWSRefT refw refs r w s m) where
    return m = RWSRefT $ \_ _ _ -> return m
    {-# INLINE return #-}
    RWSRefT f >>= g = RWSRefT $ \x y z -> do
        a <- f x y z
        unRWSRefT (g a) x y z
    {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-unlift-ref-0.2.0/Control/Monad/Trans/Writer/Ref.hs
Applicative instance: 


instance Applicative m => Applicative (WriterRefT ref w m) where
    pure = WriterRefT . const . pure
    {-# INLINE pure #-}
    WriterRefT f <*> WriterRefT g = WriterRefT $ \x -> f x <*> g x
    {-# INLINE (<*>) #-}
Monad instance: 

instance Monad m => Monad (WriterRefT ref w m) where
    return = WriterRefT . const . return
    {-# INLINE return #-}
    WriterRefT f >>= g = WriterRefT $ \x -> do
        a <- f x
        unWriterRefT (g a) x
    {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bspack-0.0.4/Data/ByteString/Pack/Internal.hs
Applicative instance: 


instance Applicative Packer where
    pure = returnPacker
    (<*>) = appendPacker
Monad instance: 


instance Monad Packer where
    return = returnPacker
    (>>=) = bindPacker
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Monatron-0.3.1/Control/Monatron/AutoInstances.hs
Monad instance: 


------------------------------------------------------------------
instance (Monad m, MonadT t) => Monad (t m) where
    return = treturn
    fail   = lift . fail
    (>>=)  = tbind
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Monatron-0.3.1/Control/Monatron/Monad.hs
Monad instance: 


instance Monad Id where
    return  = Id
    fail    = error
    m >>= f = f (runId m)
Monad instance: 


instance Monad Lift where
  return x  = L x
  fail x    = error x
  L x >>= k = k x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lattices-1.5.0/Algebra/Lattice/Op.hs
Applicative instance: 


instance Applicative Op where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Op where
  return      = Op
  Op x >>= f  = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lattices-1.5.0/Algebra/Lattice/Levitated.hs
Applicative instance: 


instance Applicative Levitated where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Levitated where
  return            = Levitate
  Top >>= _         = Top
  Bottom >>= _      = Bottom
  Levitate x >>= f  = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lattices-1.5.0/Algebra/Lattice/Dropped.hs
Applicative instance: 


instance Applicative Dropped where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Dropped where
  return        = Drop
  Top >>= _     = Top
  Drop x >>= f  = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lattices-1.5.0/Algebra/Lattice/Lexicographic.hs
Applicative instance: 


instance BoundedJoinSemiLattice k => Applicative (Lexicographic k) where
  pure = return
  (<*>) = ap
Monad instance: 


-- Essentially the Writer monad.
instance BoundedJoinSemiLattice k => Monad (Lexicographic k) where
  return                   =  Lexicographic bottom
  Lexicographic k v >>= f  =
    case f v of
      Lexicographic k' v' -> Lexicographic (k \/ k') v'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lattices-1.5.0/Algebra/Lattice/Lifted.hs
Applicative instance: 


instance Applicative Lifted where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Lifted where
  return        = Lift
  Bottom >>= _  = Bottom
  Lift x >>= f  = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lattices-1.5.0/Algebra/Lattice/Ordered.hs
Applicative instance: 


instance Applicative Ordered where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Ordered where
  return           = Ordered
  Ordered x >>= f  = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HaskellNet-0.5.1/src/Text/Packrat/Parse.hs
Applicative instance: 


instance Derivs d => Applicative (Parser d) where
    pure x = Parser (\dvs -> Parsed x dvs (nullError dvs))
    (<*>) = ap
Monad instance: 


instance Derivs d => Monad (Parser d) where
    (Parser p1) >>= f = Parser parse
        where parse dvs = first (p1 dvs)
              first (Parsed val rem err) =
                  let Parser p2 = f val
                  in second err (p2 rem)
              first (NoParse err) = NoParse err
              second err1 (Parsed val rem err) =
                  Parsed val rem (joinErrors err1 err)
              second err1 (NoParse err) =
                  NoParse (joinErrors err1 err)
    return = pure
    fail msg = Parser (\dvs -> NoParse (msgError (dvPos dvs) msg))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cpsa-3.3.2/src/CPSA/Lib/Utilities.hs
Applicative instance: 


instance Applicative (ReturnFail) where
    pure          = Return
    Fail e <*> _ = Fail e
    Return f <*> r = fmap f r
Monad instance: 


instance Monad ReturnFail where
    return = Return
    Fail l >>= _ = Fail l
    Return r >>= k = k r
    fail s = Fail s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cpsa-3.3.2/src/CPSA/Annotations/Formulas.hs
Applicative instance: 


instance Applicative (EitherS) where
    pure          = RightS
    LeftS e <*> _ = LeftS e
    RightS f <*> r = fmap f r
Monad instance: 


instance Monad EitherS where
    return = RightS
    LeftS l >>= _ = LeftS l
    RightS r >>= k = k r
    fail s = LeftS s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Alternative/Free.hs
Applicative instance: 


instance Functor f => Applicative (AltF f) where
  pure = Pure
  {-# INLINE pure #-}
  (Pure f)   <*> y         = fmap f y      -- fmap
  y          <*> (Pure a)  = fmap ($ a) y  -- interchange
  (Ap a f)   <*> b         = a `Ap` (flip <$> f <*> (Alt [b]))
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Functor f => Applicative (Alt f) where
  pure a = Alt [pure a]
  {-# INLINE pure #-}

  (Alt xs) <*> ys = Alt (xs >>= alternatives . (`ap'` ys))
    where
      ap' :: (Functor f) => AltF f (a -> b) -> Alt f a -> Alt f b

      Pure f `ap'` u      = fmap f u
      (u `Ap` f) `ap'` v  = Alt [u `Ap` (flip <$> f) <*> v]
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Comonad/Cofree.hs
Monad instance: 


instance Alternative f => Monad (Cofree f) where
  return x = x :< empty
  {-# INLINE return #-}
  (a :< m) >>= k = case k a of
                     b :< n -> b :< (n <|> fmap (>>= k) m)
Applicative instance: 


instance Alternative f => Applicative (Cofree f) where
  pure = return
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Comonad/Trans/Cofree.hs
Monad instance: 


instance (Alternative f, Monad w) => Monad (CofreeT f w) where
  return = CofreeT . return . (:< empty)
  {-# INLINE return #-}
  CofreeT cx >>= f = CofreeT $ do
    a :< m <- cx
    b :< n <- runCofreeT $ f a
    return $ b :< (n <|> fmap (>>= f) m)
Applicative instance: 



instance (Alternative f, Applicative w) => Applicative (CofreeT f w) where
  pure = CofreeT . pure . (:< empty)
  {-# INLINE pure #-}
  wf <*> wa = CofreeT $ go <$> runCofreeT wf <*> runCofreeT wa where
    go (f :< t) a = case bimap f (fmap f) a of
      b :< n -> b :< (n <|> fmap (<*> wa) t)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Applicative/Trans/Free.hs
Applicative instance: 


instance Applicative g => Applicative (ApF f g) where
  pure = Pure
  {-# INLINE pure #-}
  Pure f   <*> y       = fmap f y      -- fmap
  y        <*> Pure a  = fmap ($ a) y  -- interchange
  Ap a f   <*> b       = a `Ap` (flip <$> f <*> ApT (pure b))
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative g => Applicative (ApT f g) where
  pure = ApT . pure . pure
  {-# INLINE pure #-}
  ApT xs <*> ApT ys = ApT ((<*>) <$> xs <*> ys)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Applicative/Free.hs
Applicative instance: 


instance Applicative (Ap f) where
  pure = Pure
  Pure f <*> y = fmap f y
  Ap x y <*> z = Ap x (flip <$> y <*> z)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Monad/Free/Church.hs
Applicative instance: 


instance Applicative (F f) where
  pure a = F (\kp _ -> kp a)
  F f <*> F g = F (\kp kf -> f (\a -> g (kp . a) kf) kf)
Monad instance: 


instance Monad (F f) where
  return a = F (\kp _ -> kp a)
  F m >>= f = F (\kp kf -> m (\a -> runF (f a) kp kf) kf)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Monad/Trans/Free/Church.hs
Applicative instance: 


instance Applicative (FT f m) where
  pure a = FT $ \k _ -> k a
  FT fk <*> FT ak = FT $ \b fr -> ak (\d -> fk (\e -> b (e d)) fr) fr
Monad instance: 


instance Monad (FT f m) where
  return = pure
  FT fk >>= f = FT $ \b fr -> fk (\d -> runFT (f d) b fr) fr
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Monad/Trans/Free.hs
Applicative instance: 


instance (Functor f, Monad m) => Applicative (FreeT f m) where
  pure a = FreeT (return (Pure a))
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}
Monad instance: 


instance (Functor f, Monad m) => Monad (FreeT f m) where
  return a = FreeT (return (Pure a))
  {-# INLINE return #-}
  FreeT m >>= f = FreeT $ m >>= \v -> case v of
    Pure a -> runFreeT (f a)
    Free w -> return (Free (fmap (>>= f) w))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Monad/Trans/Iter.hs
Applicative instance: 


instance Monad m => Applicative (IterT m) where
  pure = IterT . return . Left
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad m => Monad (IterT m) where
  return = IterT . return . Left
  {-# INLINE return #-}
  IterT m >>= k = IterT $ m >>= either (runIterT . k) (return . Right . (>>= k))
  {-# INLINE (>>=) #-}
  fail = IterT . fail
  {-# INLINE fail #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-4.9/src/Control/Monad/Free.hs
Applicative instance: 


instance Functor f => Applicative (Free f) where
  pure = Pure
  {-# INLINE pure #-}
  Pure a <*> Pure b = Pure $ a b
  Pure a <*> Free mb = Free $ fmap a <$> mb
  Free ma <*> b = Free $ (<*> b) <$> ma
Monad instance: 


instance Functor f => Monad (Free f) where
  return = Pure
  {-# INLINE return #-}
  Pure a >>= f = f a
  Free m >>= f = Free ((>>= f) <$> m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lojbanParser-0.1.9.2/src/Parse.hs
Monad instance: 
           -- unconditional error labeling

-- Standard monadic combinators
instance Derivs d => Monad (Parser d) where

        -- Sequencing combinator
        (Parser p1) >>= f = Parser parse

                where parse dvs = first (p1 dvs)

                      first (Parsed val rem err) =
                        let Parser p2 = f val
                        in second err (p2 rem)
                      first (NoParse err) = NoParse err

                      second err1 (Parsed val rem err) =
                        Parsed val rem (joinErrors err1 err)
                      second err1 (NoParse err) =
                        NoParse (joinErrors err1 err)

        -- Result-producing combinator
        return x = Parser (\dvs -> Parsed x dvs (nullError dvs))

        -- Failure combinator
        fail [] = Parser (\dvs -> NoParse (nullError dvs))
        fail msg = Parser (\dvs -> NoParse (msgError (dvPos dvs) msg))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HaTeX-3.9.1.0/Text/LaTeX/Packages/TikZ/PathBuilder.hs
Applicative instance: 


instance Applicative PathBuilder where
 pure = PB . pure
 (PB f) <*> (PB x) = PB $ f <*> x
Monad instance: 


instance Monad PathBuilder where
 return = pure
 (PB x) >>= f = PB $ x >>= pathBuilder . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HaTeX-3.9.1.0/Text/LaTeX/Base/Writer.hs
Applicative instance: 


instance Applicative f => Applicative (LaTeXT f) where
 pure = LaTeXT . pure . pairNoth
 (LaTeXT f) <*> (LaTeXT x) = LaTeXT $ fmap (first . fst) f <*> x
Monad instance: 


instance Monad m => Monad (LaTeXT m) where
 return = LaTeXT . return . pairNoth
 (LaTeXT c) >>= f = LaTeXT $ do
  (a,_) <- c
  let LaTeXT c' = f a
  c'
 fail = throwError
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/syb-0.6/tests/Perm.hs
Applicative instance: 


instance Applicative ReadT where
  pure  = return
  (<*>) = ap
Monad instance: 


-- ReadT is a monad!
instance Monad ReadT where
  return x = ReadT (\y -> Just (y,x))
  c >>= f  = ReadT (\x -> case unReadT c x of
                            Nothing -> Nothing
                            Just (x', a) -> unReadT (f a) x'
                   )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/syb-0.6/tests/XML.hs
Applicative instance: 


instance Applicative ReadX where
  pure  = return
  (<*>) = ap
Monad instance: 


-- ReadX is a monad!
instance Monad ReadX where
  return x = ReadX (\y -> Just (y,x))
  c >>= f  = ReadX (\x -> case unReadX c x of
                            Nothing -> Nothing
                            Just (x', a) -> unReadX (f a) x'
                   )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/syb-0.6/tests/Bits.hs
Applicative instance: 


instance Applicative ReadB where
  pure  = return
  (<*>) = ap
Monad instance: 


-- It's a monad.
instance Monad ReadB where
  return a = ReadB (\bs -> (Just a, bs))
  (ReadB c) >>= f = ReadB (\bs -> case c bs of
                             (Just a, bs')  -> unReadB (f a) bs'
                             (Nothing, bs') -> (Nothing, bs')
                          )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/syb-0.6/tests/GRead2.hs
Applicative instance: 


instance Applicative DecM where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad DecM where
    return a = D (\s -> Just (s,a))
    (D m) >>= k = D (\s ->
      case m s of
        Nothing -> Nothing
        Just (s1,a) -> let D n = k a
                        in n s1)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/syb-0.6/tests/Encode.hs
Applicative instance: 

instance Applicative EncM where
  pure  = return
  (<*>) = ap
Monad instance: 

instance Monad EncM
 where
  return  = undefined
  c >>= f = undefined
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/control-monad-omega-0.3.1/Control/Monad/Omega.hs
Monad instance: 


instance Monad Omega where
    return x = Omega [x]
    Omega m >>= f = Omega $ diagonal $ map (runOmega . f) m
    fail _ = Omega []
Applicative instance: 


instance Applicative.Applicative Omega where
    pure = return
    (<*>) = Monad.ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ddc-core-0.4.3.1/DDC/Core/Fragment/Compliance.hs
Applicative instance: 



instance Applicative (CheckM s err) where
 (<*>)  = ap
 pure   = return
Monad instance: 



instance Monad (CheckM a n) where
 return x   = CheckM (Right x)
 (>>=) m f
  = case m of
          CheckM (Left err)     -> CheckM (Left err)
          CheckM (Right x)      -> f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uniform-pair-0.1.9/src/Data/UniformPair.hs
Applicative instance: 
  -- exchange

instance Applicative Pair where
  pure a = a :# a
  (f :# g) <*> (a :# b) = f a :# g b
Monad instance: 


instance Monad Pair where
  return = pure
  m >>= f = joinP (f <$> m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ixmonad-0.57/examples/WriterM.hs
Monad instance: 


instance Monoid w => Monad (Writer w) where
   return a = Writer (a, mempty)
   (Writer (a, w)) >>= k = let (b, w') = runWriter (k a)
                           in Writer (b, w `mappend` w')
Monad instance: 


instance Monad (Writer (Maybe a)) where
   return a = Writer (a, Nothing)
   (Writer (a, w)) >>= k = let (b, w') = runWriter (k a)
                           in case w' of
                                Nothing -> Writer (b, w)
                                Just w' -> Writer (b, Just w')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/effect-monad-0.6.1/examples/WriterM.hs
Monad instance: 


instance Monoid w => Monad (Writer w) where
   return a = Writer (a, mempty)
   (Writer (a, w)) >>= k = let (b, w') = runWriter (k a)
                           in Writer (b, w `mappend` w')
Monad instance: 


instance Monad (Writer (Maybe a)) where
   return a = Writer (a, Nothing)
   (Writer (a, w)) >>= k = let (b, w') = runWriter (k a)
                           in case w' of
                                Nothing -> Writer (b, w)
                                Just w' -> Writer (b, Just w')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Annotations-0.2.1/Annotations/Except.hs
Applicative instance: 


instance Monoid e => Applicative (Except e) where
  pure = OK
  OK f <*> OK x = OK (f x)
  OK _ <*> Failed e = Failed e
  Failed e <*> OK _ = Failed e
  Failed e1 <*> Failed e2 = Failed (e1 `mappend` e2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reflection-2.1.2/fast/Data/Reflection.hs
Applicative instance: 


instance Reifies s (ReifiedApplicative f) => Applicative (ReflectedApplicative f s) where
  pure a = reflectResult1 (\m -> ReflectedApplicative (reifiedPure m a))
  ReflectedApplicative x <*> ReflectedApplicative y = reflectResult1 (\m -> ReflectedApplicative (reifiedAp m x y))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hoauth-0.3.5/src/main/haskell/Network/OAuth/Consumer.hs
Monad instance: 


instance (Monad m) => Monad (OAuthMonadT m) where
  return a = OAuthMonadT $ \t -> return $ Right (t,a)
  fail err = OAuthMonadT $ \_ -> return $ Left err

  (OAuthMonadT ma) >>= f = OAuthMonadT $ \t0 -> ma t0 >>= either left right
    where left = return . Left
          right (t1,a) = let OAuthMonadT mb = f a
                         in mb t1
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dbus-core-0.9.3/hs/DBus/Connection/Authentication.hs
Monad instance: 


instance Monad Auth where
        return a = Auth (\_ -> return a)
        m >>= k = Auth $ \s -> do
                x <- unAuth m s
                unAuth (k x) s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dbus-core-0.9.3/hs/DBus/Introspection.hs
Monad instance: 


instance Monad XmlWriter where
        return a = XmlWriter $ Just (a, Data.Text.empty)
        m >>= f = XmlWriter $ do
                (a, w) <- runXmlWriter m
                (b, w') <- runXmlWriter (f a)
                return (b, Data.Text.append w w')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dbus-core-0.9.3/hs/DBus/Wire/Internal.hs
Monad instance: 


instance Monad (Wire s) where
        {-# INLINE return #-}
        return a = Wire (\_ s -> WireRR a s)

        {-# INLINE (>>=) #-}
        m >>= k = Wire $ \e s -> case unWire m e s of
                WireRL err -> WireRL err
                WireRR a s' -> unWire (k a) e s'

        {-# INLINE (>>) #-}
        m >> k = Wire $ \e s -> case unWire m e s of
                WireRL err -> WireRL err
                WireRR _ s' -> unWire k e s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dbus-core-0.9.3/hs/DBus/Util/MonadError.hs
Monad instance: 


instance Monad (ErrorM e) where
        return = ErrorM . Right
        (>>=) m k = case runErrorM m of
                Left err -> ErrorM $ Left err
                Right x -> k x
Monad instance: 


instance Monad m => Monad (ErrorT e m) where
        return = ErrorT . return . Right
        (>>=) m k = ErrorT $ do
                x <- runErrorT m
                case x of
                        Left l -> return $ Left l
                        Right r -> runErrorT $ k r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/exceptional-0.3.0.0/Control/Exceptional.hs
Applicative instance: 


instance Applicative Exceptional where
  pure = Success
  Success f <*> Success x = Success (f x)
  Failure s <*> _ = Failure s
  _ <*> Failure s = Failure s
Monad instance: 


-- |This is 'fail'-safe, so to speak. That is,
-- 
-- > fail = Failure
instance Monad Exceptional where
  (>>=) (Success x) f = f x
  (>>=) (Failure s) _ = Failure s
  fail = Failure
  return = pure
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/seclib-1.1.0.2/SecLib/TCB/Sec.hs
Monad instance: 


instance Monad (Sec l) where
  return a = MkSec a

  MkSec a >>= k =
    MkSec (let MkSec b = k a in b)
Applicative instance: 


instance Applicative (Sec l) where
    pure  = return
    -- | @(<*>)@ cannot be used since @Sec l@ is not a functor
    (<*>) = undefined
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/seclib-1.1.0.2/SecLib/TCB/SecIO.hs
Monad instance: 


instance Monad (SecIO l) where
  return a =
    MkSecIO (return (return a))

  MkSecIO m >>= k =
    MkSecIO (do sec_a <- m
                let MkSecIO m' = k (unsec sec_a)
                m')
Applicative instance: 


{- |
   For the same reason as above, '(<*>)' is undefined.
-}
instance Applicative (SecIO l) where
    pure  = return
    (<*>) = undefined
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rangemin-2.2.2/Data/RangeMin/LCA/IndexM.hs
Monad instance: 


instance Monad IndexM where
        return a = IndexM (IP a)
        m >>= k = IndexM $ \ i -> case runIndexM m i of
                IP x i' -> runIndexM (k x) i'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/V3.hs
Applicative instance: 


instance Applicative V3 where
  pure a = V3 a a a
  {-# INLINE pure #-}
  V3 a b c <*> V3 d e f = V3 (a d) (b e) (c f)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad V3 where
  return a = V3 a a a
  {-# INLINE return #-}
  V3 a b c >>= f = V3 a' b' c' where
    V3 a' _ _ = f a
    V3 _ b' _ = f b
    V3 _ _ c' = f c
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/Instances.hs
Applicative instance: 


instance Applicative Complex where
  pure a = a :+ a
  (a :+ b) <*> (c :+ d) = a c :+ b d
Monad instance: 


instance Monad Complex where
  return a = a :+ a
  {-# INLINE return #-}

  (a :+ b) >>= f = a' :+ b' where
    a' :+ _  = f a
    _  :+ b' = f b
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/V2.hs
Applicative instance: 

  {-@ INLINE (<.>) #-}

instance Applicative V2 where
  pure a = V2 a a
  {-# INLINE pure #-}
  V2 a b <*> V2 d e = V2 (a d) (b e)
Monad instance: 


instance Monad V2 where
  return a = V2 a a
  {-# INLINE return #-}
  V2 a b >>= f = V2 a' b' where
    V2 a' _ = f a
    V2 _ b' = f b
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/Plucker.hs
Applicative instance: 


instance Applicative Plucker where
  pure a = Plucker a a a a a a
  {-# INLINE pure #-}
  Plucker a b c d e f <*> Plucker g h i j k l =
    Plucker (a g) (b h) (c i) (d j) (e k) (f l)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Plucker where
  return a = Plucker a a a a a a
  {-# INLINE return #-}
  Plucker a b c d e f >>= g = Plucker a' b' c' d' e' f' where
    Plucker a' _ _ _ _ _ = g a
    Plucker _ b' _ _ _ _ = g b
    Plucker _ _ c' _ _ _ = g c
    Plucker _ _ _ d' _ _ = g d
    Plucker _ _ _ _ e' _ = g e
    Plucker _ _ _ _ _ f' = g f
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/V4.hs
Applicative instance: 


instance Applicative V4 where
  pure a = V4 a a a a
  {-# INLINE pure #-}
  V4 a b c d <*> V4 e f g h = V4 (a e) (b f) (c g) (d h)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad V4 where
  return a = V4 a a a a
  {-# INLINE return #-}
  V4 a b c d >>= f = V4 a' b' c' d' where
    V4 a' _ _ _ = f a
    V4 _ b' _ _ = f b
    V4 _ _ c' _ = f c
    V4 _ _ _ d' = f d
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/V1.hs
Applicative instance: 

  {-@ INLINE (<.>) #-}

instance Applicative V1 where
  pure = V1
  {-# INLINE pure #-}
  V1 f <*> V1 x = V1 (f x)
Monad instance: 


instance Monad V1 where
  return = V1
  {-# INLINE return #-}
  V1 a >>= f = f a
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/V.hs
Applicative instance: 


instance Dim n => Applicative (V n) where
  pure = V . V.replicate (reflectDim (Proxy :: Proxy n))
  {-# INLINE pure #-}

  V as <*> V bs = V (V.zipWith id as bs)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Dim n => Monad (V n) where
  return = V . V.replicate (reflectDim (Proxy :: Proxy n))
  {-# INLINE return #-}
  V as >>= f = V $ generate (reflectDim (Proxy :: Proxy n)) $ \i ->
    toVector (f (as `unsafeIndex` i)) `unsafeIndex` i
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/V0.hs
Applicative instance: 

  {-@ INLINE (<.>) #-}

instance Applicative V0 where
  pure _ = V0
  {-# INLINE pure #-}
  V0 <*> V0 = V0
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad V0 where
  return _ = V0
  {-# INLINE return #-}
  V0 >>= _ = V0
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/Covector.hs
Applicative instance: 


instance Applicative (Covector r) where
  pure a = Covector $ \k -> k a
  Covector mf <*> Covector ma = Covector $ \k -> mf $ \f -> ma $ k . f
Monad instance: 


instance Monad (Covector r) where
  return a = Covector $ \k -> k a
  Covector m >>= f = Covector $ \k -> m $ \a -> runCovector (f a) k
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/Vector.hs
Applicative instance: 

instance Applicative SetOne where
  pure a = SetOne a []
  SetOne f fs <*> SetOne a as = SetOne (f a) (Prelude.foldr ((:) . ($ a)) (Prelude.map f as) fs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/linear-1.9.1/src/Linear/Quaternion.hs
Applicative instance: 


instance Applicative Quaternion where
  pure a = Quaternion a (pure a)
  {-# INLINE pure #-}
  Quaternion f fv <*> Quaternion a v = Quaternion (f a) (fv <*> v)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Quaternion where
  return = pure
  {-# INLINE return #-}
  -- the diagonal of a sedenion is super useful!
  Quaternion a (V3 b c d) >>= f = Quaternion a' (V3 b' c' d') where
    Quaternion a' _          = f a
    Quaternion _ (V3 b' _ _) = f b
    Quaternion _ (V3 _ c' _) = f c
    Quaternion _ (V3 _ _ d') = f d
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/clash-prelude-0.9.3/src/CLaSH/Signal/Internal.hs
Applicative instance: 


instance Applicative (Signal' clk) where
  pure  = signal#
  (<*>) = appSignal#
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/clash-prelude-0.9.3/src/CLaSH/Sized/Vector.hs
Applicative instance: 


instance KnownNat n => Applicative (Vec n) where
  pure      = repeat
  fs <*> xs = zipWith ($) fs xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/NestedFunctor-0.2.0.2/Data/Functor/Nested.hs
Applicative instance: 


instance (Applicative f) => Applicative (Nested (Flat f)) where
   pure              = Flat . pure
   Flat f <*> Flat x = Flat (f <*> x)
Applicative instance: 


instance (Applicative f, Applicative (Nested fs)) => Applicative (Nested (Nest fs f)) where
   pure              = Nest . pure . pure
   Nest f <*> Nest x = Nest ((<*>) <$> f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/nonempty-alternative-0.4.0/src/Data/NonEmpty.hs
Applicative instance: 


----------------------------------------------------------------------

instance Alternative f => Applicative (NonEmptyL f) where
  pure x = x :<: empty

  (f :<: fs) <*> (x :<: xs) = (f x) :<: (   (pure f <*> xs    )
                                     <|> (fs     <*> (pure x <|> xs)))
Applicative instance: 


instance Alternative f => Applicative (NonEmptyR f) where
  pure x = empty :>: x

  (fs :>: f) <*> (xs :>: x) = (   (fs     <*> (xs <|> pure x) )
                            <|> (pure f <*> xs    ) ) :>: (f x)
Monad instance: 


----------------------------------------------------------------------

instance (Alternative f, Monad f) => Monad (NonEmptyL f) where
  (x :<: xs) >>= f = y :<: (ys <|> zs)
                  where (y :<: ys) = f x
                        zs = xs >>= flattenL . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/compressed-3.10/src/Data/Compressed/RunLengthEncoding.hs
Applicative instance: 


instance Applicative Run where
  pure = Run 1
  Run n f <*> Run m a = Run (n * m) (f a)
  Run n _  *> Run m a = Run (n * m) a
  Run n a <*  Run m _ = Run (n * m) a
Monad instance: 


instance Monad Run where
  return = Run 1
  Run n _ >> Run m b = Run (n * m) b
  Run n a >>= f = case f a of
    Run m b -> Run (n * m) b
Applicative instance: 


instance Applicative RLE where
  pure = RLE . F.singleton . pure
  RLE fs <*> RLE as = RLE $ F.fromList $ do
    Run n f <- toList fs
    Run m a <- toList as
    return $ Run (n * m) (f a)
  RLE as <* RLE bs = RLE $ F.fmap' (\(Run n a) -> Run (n * m) a) as where
    m = reduceWith getCount bs
  RLE as *> RLE bs = RLE $ mconcat $ replicate (reduceWith getCount as) bs
Monad instance: 


instance Monad RLE where
  return = RLE . F.singleton . pure
  (>>) = (*>)
  RLE xs >>= f = RLE $ mconcat [ mconcat $ replicate n (getRLE (f a)) | Run n a <- toList xs ]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/compressed-3.10/src/Data/Compressed/Internal/LZ78.hs
Applicative instance: 


instance Applicative LZ78 where
  pure a = Cons (Token 0 a) Nil
  fs <*> as = fmap extract $ encode $ do
    Entry i f <- decode (entries fs)
    Entry j a <- decode (entries as)
    return $ Entry (i,j) (f a)
  as *> bs = fmap extract $ encode $ Prelude.concat $ replicate (reduceWith getCount as)  $  decode (entries bs)
  as <* bs = fmap extract $ encode $ Prelude.concat $ replicate (reduceWith getCount bs) <$> decode (entries as)
Monad instance: 


instance Monad LZ78 where
  return a = Cons (Token 0 a) Nil
  (>>) = (*>)
  as >>= k = fmap extract $ encode $ do
    Entry i a <- decode (entries as)
    Entry j b <- decode (entries (k a))
    return $ Entry (i,j) b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/frpnow-0.18/Control/FRPNow/BehaviorEnd.hs
Monad instance: 


instance Monad (BehaviorEnd x) where
  return x = pure (error "ended!") `Until` pure x
  (b `Until` e) >>= f  =
     let v = f <$> e
         b' = b `switch` (behavior <$> v)
         e' = v >>= end
     in b' `Until` e'
Applicative instance: 

instance Applicative (BehaviorEnd x) where pure = return ; (<*>) = ap
Monad instance: 


instance Swap f g => Monad (f :. g) where
  -- see (Composing Monads, Jones and Duponcheel) for proof
  return  = Close . return . return
  m >>= f = joinComp (fmap2m f m)
Applicative instance: 

-- this works as follows, we have 
-- b . e . b . e      flip middle two
-- b . b . e . e      join left and right
-- b . e 


instance (Applicative b, Applicative e) => Applicative (b :. e) where
   pure = Close . pure . pure
   x <*> y = Close $ (<*>) <$> open x <*> open y
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/frpnow-0.18/Control/FRPNow/Core.hs
Monad instance: 



instance Monad Event where
  return = Occ
  Never >>= _ = Never
  (Occ x) >>= f = f x
  (E m)   >>= f = memoE $ bindInternal m f
Monad instance: 



{-
whenJustSample' :: Behavior (Maybe (Behavior a)) -> Behavior (Event a)
whenJustSample' (Const Nothing)  = pure never
whenJustSample' (Const (Just x)) = B $ do v <- fst <$> runB x; return (pure v, never)
whenJustSample' (B bm) = B $
  do (h, t) <- bm
     case h of
      Just x -> do v <- fst <$> runB x; return (pure v, whenJustSample' <$> t)
      Nothing -> do en <- planM (runB . whenJustSample' <$> t)
                    return (en >>= fst, never)
-}
instance Monad Behavior where
  return x = B $ return (x, never)
  m >>= f = m `bindB` f
Applicative instance: 


instance Applicative Behavior where
  pure = return
  (<*>) = ap
Applicative instance: 


instance Applicative Event where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/WebCont-0.0.1/WebCont.hs
Monad instance: 


instance Monad (WebCont r) where
    return = WebCont . const . Done
    w >>= f = WebCont $ \e -> case (runWeb w e) of
        Done a -> runWeb (f a) e
        Via r w' -> Via r (w' >>= f)
Applicative instance: 

instance Applicative Identity where pure = return; (<*>) = ap;
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/helix-0.9.5/src/Util/Free.hs
Applicative instance: 

instance Functor f => Applicative (F f) where
  pure a = F (\kp _ -> kp a)
  F f <*> F g = F (\kp kf -> f (\a -> g (kp . a) kf) kf)
Monad instance: 

instance Functor f => Monad (F f) where
  return a = F (\kp _ -> kp a)
  F m >>= f = F (\kp kf -> m (\a -> runF (f a) kp kf) kf)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CC-delcont-cxe-0.1.0.2/Generator2.hs
Monad instance: 


instance Monad Identity where
    return = Identity
    m >>= f = f $ runIdentity m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CC-delcont-cxe-0.1.0.2/Bench_nondet.hs
Monad instance: 


instance Monad CPS where
    return x = CPS $ \k -> k x
    m >>= f  = CPS $ \k -> unCPS m (\a -> unCPS (f a) k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CC-delcont-cxe-0.1.0.2/Control/Monad/CC/CCCxe.hs
Monad instance: 



-- --------------------------------------------------------------------
-- | CC monad: general monadic operations

instance Monad m => Monad (CC p m) where
    return x = CC $ \ki kd -> ki x

    m >>= f = CC $ \ki kd -> unCC m
                              (\a -> unCC (f a) ki kd)
                              (\ctx -> kd (\x -> ctx x >>= f))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/compression-0.1/Codec/Compression/LazyStateT.hs
Monad instance: 


instance Monad m => Monad (LazyStateT s m) where
 -- (>>=)  :: LazyStateT s m a -> (a -> LazyStateT s m b) -> LazyStateT s m b
    LazyStateT v >>= f = LazyStateT $ \s -> do ~(x, s') <- v s
                                               let LazyStateT y = f x
                                               y s'
 -- return :: a -> LazyStateT s m a
    return x = LazyStateT $ \s -> return (x, s)
 -- fail :: String -> LazyStateT s m a
    fail str = LazyStateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/graph-serialize-0.2/Data/Serialize/References.hs
Monad instance: 


instance Monad BuildM where
  return a = BuildM $ \s nr nl k -> k s nr nl a
  BuildM f >>= kont = BuildM $ \s nr nl k ->
    f s nr nl (\s' nr' nl' a -> unBuildM (kont a) s' nr' nl' k)
Applicative instance: 

instance Applicative BuildM where pure = return; (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hadoop-rpc-1.1.0.0/src/Network/Hadoop/Hdfs.hs
Applicative instance: 


instance Applicative Hdfs where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad Hdfs where
    return  = Hdfs . const . return
    m >>= k = Hdfs $ \c -> unHdfs m c >>= \x -> unHdfs (k x) c
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/open-signals-0.1.0.3/src/Control/Monad/Signal.hs
Applicative instance: 


instance Applicative (Signal sigs) where
    pure = Value
    Signal u <*> _        = Signal u
    Value f  <*> Value x  = Value (f x)
    Value _  <*> Signal u = Signal u
Monad instance: 


instance Monad (Signal sigs) where
    return = pure
    Signal u >>= _ = Signal u
    Value a  >>= f = f a
Applicative instance: 


instance Applicative m => Applicative (SignalT sigs m) where
    pure x = SignalT (pure (Value x))
    SignalT mcab <*> SignalT mca = SignalT mcb
        where mcacb = fmap (<*>) mcab
              mcb = mcacb <*> mca
Monad instance: 


instance Monad m => Monad (SignalT sigs m) where
    return = pure
    SignalT mca >>= f = SignalT $ mca >>= \case
        Value a  -> runSignalT (f a)
        Signal u -> return (Signal u)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tip-lib-0.2.2/src/Tip/Parser/ErrM.hs
Monad instance: 


instance Monad Err where
  return      = Ok
  fail        = Bad
  Ok a  >>= f = f a
  Bad s >>= _ = Bad s
Applicative instance: 


instance Applicative Err where
  pure = Ok
  (Bad s) <*> _ = Bad s
  (Ok f) <*> o  = liftM f o
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tip-lib-0.2.2/src/Tip/Writer.hs
Applicative instance: 


instance (Monoid w, Monad m) => Applicative (WriterT w m) where
  {-# INLINE pure #-}
  pure = return
  {-# INLINE (<*>) #-}
  (<*>) = liftM2 ($)
Monad instance: 


instance (Monoid w, Monad m) => Monad (WriterT w m) where
  {-# INLINE return #-}
  return x = WriterT (\k -> k mempty x)

  {-# INLINE (>>=) #-}
  WriterT m >>= f =
    WriterT $ \k ->
      m (\w x -> unWriterT (f x) (\w' y -> k (w `mappend` w') y))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/llvm-pretty-bc-parser-0.2.1.0/src/Data/LLVM/BitCode/GetBits.hs
Applicative instance: 


instance Applicative GetBits where
  {-# INLINE pure #-}
  pure x = GetBits (\ off -> return (x,off))

  {-# INLINE (<*>) #-}
  f <*> x = GetBits $ \ off0 -> do
    (g,off1) <- unGetBits f off0
    (y,off2) <- unGetBits x off1
    return (g y,off2)
Monad instance: 


instance Monad GetBits where
  {-# INLINE return #-}
  return = pure

  {-# INLINE (>>=) #-}
  m >>= f = GetBits $ \ off0 -> do
    (x,off1) <- unGetBits m off0
    unGetBits (f x) off1

  {-# INLINE fail #-}
  fail str = GetBits (\ _ -> fail str)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/llvm-pretty-bc-parser-0.2.1.0/src/Data/LLVM/BitCode/Parse.hs
Monad instance: 


instance Monad Parse where
  {-# INLINE return #-}
  return  = Parse . return

  {-# INLINE (>>=) #-}
  Parse m >>= f = Parse (m >>= unParse . f)

  {-# INLINE fail #-}
  fail = failWithContext
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/scion-0.1.0.2/lib/Scion/Types.hs
Monad instance: 


instance Monad ScionM where
  return x = ScionM $ \_ -> return x
  (ScionM ma) >>= fb =
      ScionM $ \s -> do
        a <- ma s
        unScionM (fb a) s
  fail msg = dieHard msg
Applicative instance: 


instance Applicative ScionM where
  pure a = ScionM $ \_ -> return a
  ScionM mf <*> ScionM ma =
      ScionM $ \s -> do f <- mf s; a <- ma s; return (f a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/scion-0.1.0.2/server/Scion/Server/Commands.hs
Monad instance: 

instance Monad Pa where
  return x = Pa $ \_ -> Right x
  m >>= k = Pa $ \req ->
            case unPa m req of
              Left err -> Left err
              Right a -> unPa (k a) req
  fail msg = Pa $ \_ -> Left msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hakaru-0.1.4/Language/Hakaru/Metropolis.hs
Monad instance: 


instance Monad Measure where
  return = return_
  (>>=)  = bind
Applicative instance: 


instance Applicative Measure where
  pure = return_
  (<*>) = app
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hakaru-0.1.4/Language/Hakaru/ImportanceSampler.hs
Monad instance: 


instance Monad Measure where
  return x = Measure (\conds -> deterministic (point (x,conds) 1))
  (>>=)    = bind
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ObjectIO-1.0.1.1/Graphics/UI/ObjectIO/OS/Picture.hs
Monad instance: 


instance Monad Draw where
   return x = Draw (\pict -> return (x, pict))
   (Draw f) >>= g = Draw (\pict -> do
        (x, pict) <- f pict
        let (Draw f2) = g x
        f2 pict)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-concurrent-0.1.0.1/src/Control/Concurrent/Free.hs
Applicative instance: 


instance Applicative (F f) where
  pure = Pure
  Pure f <*> y = fmap f y
  x <*> y = Ap y x
Monad instance: 


instance Monad (F f) where
  return = pure
  Pure x >>= f = f x
  x >>= f = Join (fmap f x)
  x >> y = x *> y
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/colour-2.3.3/Data/Colour/RGB.hs
Applicative instance: 


instance Applicative RGB where
 pure c = RGB c c c
 (RGB fr fg fb) <*> (RGB r g b) = RGB (fr r) (fg g) (fb b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/llvm-general-quote-0.2.0.0/src/LLVM/General/Quote/Parser/Monad.hs
Applicative instance: 


instance Applicative P where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad P where
    m >>= k = P $ \s ->
        case runP m s of
          Left e         -> Left e
          Right (a, s')  -> runP (k a) s'

    m1 >> m2 = P $ \s ->
        case runP m1 s of
          Left e         -> Left e
          Right (_, s')  -> runP m2 s'

    return a = P $ \s -> Right (a, s)

    fail msg = do
        inp <- getInput
        throw $ ParserException (Loc (alexPos inp) (alexPos inp))
                                (ppr (alexPos inp) <> colon <+> text msg)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/UMM-0.3.1/UMMData.hs
Monad instance: 


-- Note that because we use append (++) for lists here, this is fairly
-- low-performance: it's entirely ok for this application, where we
-- toss around a few to a few thousand list entries, but for longer
-- lists it might not be suitable. <shrug>

instance Monad (Ledger e i) where
  return a = Ledger (a, [], [])
  (>>=) m k =
    let (a,li1,le1) = runLedger m
        n = k a
        (b,li2,le2) = runLedger n
    in Ledger (b, li1 ++ li2, le1 ++ le2)
  (>>) a f = a >>= const f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/orc-1.2.1.4/src/Control/Concurrent/Hierarchical.hs
Monad instance: 


instance Monad HIO where
  return x = HIO $ \_ -> return x
  m >>= k  = HIO $ \w -> do
                 x <- m `inGroup` w
                 k x `inGroup` w
Applicative instance: 



instance Applicative HIO where
  pure  = return
  f <*> x = ap f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/orc-1.2.1.4/src/Orc/Monad.hs
Monad instance: 


instance Monad Orc where
  return x = Orc $ \k -> k x
  p >>= h  = Orc $ \k -> p # (\x -> h x # k)
  fail _   = stop
Applicative instance: 


instance Applicative Orc where
  pure    = return
  f <*> x = ap f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sample-frame-0.0.3/src/Sound/Frame/Stereo/Record.hs
Applicative instance: 


-- useful for defining Additive instance
instance Applicative T where
   {-# INLINE pure #-}
   pure a = Cons a a
   {-# INLINE (<*>) #-}
   Cons fl fr <*> Cons l r = Cons (fl l) (fr r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sample-frame-0.0.3/src/Sound/Frame/Stereo/Traversable.hs
Applicative instance: 


-- useful for defining Additive instance
instance Applicative T where
   {-# INLINE pure #-}
   pure a = Cons a a
   {-# INLINE (<*>) #-}
   ~(Cons fl fr) <*> ~(Cons l r) = Cons (fl l) (fr r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sample-frame-0.0.3/src/Sound/Frame/Stereo.hs
Applicative instance: 


-- useful for defining Additive instance
instance Applicative T where
   {-# INLINE pure #-}
   pure a = Cons a a
   {-# INLINE (<*>) #-}
   Cons fl fr <*> Cons l r = Cons (fl l) (fr r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/piet-0.1/sources/Language/Piet/PietMonad.hs
Monad instance: 


instance Monad PietMonad where
        return x = PietMonad (\status _ _ -> return (return (x, status)))

        (PietMonad m01) >>= f = PietMonad (\status0 requestChan inputChan -> do
                        either1 <- m01 status0 requestChan inputChan
                        case either1 of
                                Left msg                -> return (fail msg)
                                Right (x1, status1)     -> do
                                        let (PietMonad m12) = f x1
                                        m12 status1 requestChan inputChan
                )

        fail msg = do
                logMessage Fatal msg
                PietMonad (\_ _ _ -> return (fail msg))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bytestringparser-temporary-0.4.1/src/Data/ParserCombinators/Attoparsec/Internal.hs
Monad instance: 


instance Monad Parser where
    return a = Parser $ \s -> Right (a, s)
    m >>= f = Parser $ \s ->
              case unParser m s of
                Right (a, s') -> unParser (f a) s'
                Left (s', msgs) -> Left (s', msgs)
    fail err = Parser $ \(S sb lb _) -> Left (sb +: lb, [err])
Applicative instance: 


instance Applicative Parser where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mrm-0.1.0.0/src/Data/Match/Effects.hs
Monad instance: 


instance (fs <: fs) => Monad (Free fs) where
    return         = Free . inn . Pure
    (Free p) >>= f = fold ((\(Pure x) -> f x) :::
                           transFree) p
Applicative instance: 

instance (Monad (Free fs), Functor (Free fs)) => Applicative (Free fs) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/comfort-graph-0.0.1/src/Data/Graph/Comfort/TotalMap.hs
Applicative instance: 


instance (Ord k) => Applicative (TotalMap k) where
   pure a = TotalMap a Map.empty
   TotalMap fd fm <*> TotalMap ad am =
      TotalMap (fd ad) $
         fmap ($ad) (Map.difference fm am) <>
         fmap (fd$) (Map.difference am fm) <>
         Map.intersectionWith ($) fm am
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gsasl-0.3.6/lib/Network/Protocol/SASL/GNU.hs
Applicative instance: 


instance Applicative SASL where
        pure = SASL . pure
        (<*>) = ap
Monad instance: 


instance Monad SASL where
        return = SASL . return
        (>>=) sasl f = SASL $ unSASL sasl >>= unSASL . f
Applicative instance: 


instance Applicative Session where
        pure = Session . pure
        (<*>) = ap
Monad instance: 


instance Monad Session where
        return = Session . return
        (>>=) m f = Session $ unSession m >>= unSession . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pdfinfo-1.5.4/src/Text/PDF/Info.hs
Applicative instance: 

instance Applicative ParsePDFInfo where (<*>) = ap; pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fay-0.9.2.0/tests/Monad2.hs
Monad instance: 

instance Monad (State a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/biohazard-0.6.6.1/tools/bam-fixpair.hs
Applicative instance: 


instance Applicative (Mating r m) where
    pure a = Mating $ \k -> k a
    u <*> v = Mating $ \k -> runMating u (\a -> runMating v (k . a))
Monad instance: 


instance Monad (Mating r m) where
    return a = Mating $ \k -> k a
    m >>=  k = Mating $ \k2 -> runMating m (\a -> runMating (k a) k2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/biohazard-0.6.6.1/src/Bio/Bam/Pileup.hs
Applicative instance: 


instance Applicative (PileM m) where
    {-# INLINE pure #-}
    pure a = PileM $ \k -> k a
    {-# INLINE (<*>) #-}
    u <*> v = PileM $ \k -> runPileM u (\a -> runPileM v (k . a))
Monad instance: 


instance Monad (PileM m) where
    {-# INLINE return #-}
    return a = PileM $ \k -> k a
    {-# INLINE (>>=) #-}
    m >>=  k = PileM $ \k' -> runPileM m (\a -> runPileM (k a) k')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/biohazard-0.6.6.1/src/Data/Avro.hs
Applicative instance: 

instance Applicative MkSchema where pure a = MkSchema (\k -> k a)
                                    u <*> v = MkSchema (\k -> mkSchema u (\a -> mkSchema v (k . a)))
Monad instance: 

instance Monad MkSchema where return a = MkSchema (\k -> k a)
                              a >>= m = MkSchema (\k -> mkSchema a (\a' -> mkSchema (m a') k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sifflet-lib-2.2.1/Language/Sifflet/Util.hs
Monad instance: 


instance Monad SuccFail where
  Succ val >>= f = f val
  Fail err >>= _f = Fail err
  return = Succ
  fail = Fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sifflet-lib-2.2.1/Language/Sifflet/Expr.hs
Monad instance: 


instance Monad EvalRes where
  EvalOk value >>= f = f value
  EvalError e >>= _f = EvalError e
  EvalUntried >>= _f = EvalUntried
  return = EvalOk
  fail = EvalError
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uni-util-2.3.0.1/Util/BinaryUtils.hs
Applicative instance: 


instance Applicative m => Applicative (ArgMonad arg m) where
   pure v = ArgMonad (const (pure v))
   ArgMonad fn1 <*> ArgMonad fn2 =
      let
         fn arg = fn1 arg <*> fn2 arg
      in
         ArgMonad fn
Monad instance: 


instance Monad m => Monad (ArgMonad arg m) where
   (>>=) (ArgMonad fn1) getArgMonad =
      let
         fn arg =
            do
               v1 <- fn1 arg
               let
                  (ArgMonad fn2) = getArgMonad v1
               fn2 arg
      in
         ArgMonad fn

   return v = ArgMonad (const (return v))

   fail s = ArgMonad (const (fail s))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uni-util-2.3.0.1/Util/Computation.hs
Applicative instance: 


instance Applicative WithError where
   pure = return
   (<*>) = ap
Monad instance: 


instance Monad WithError where
   return v = hasValue v
   (>>=) aWE toBWe =
      mapWithError' toBWe aWE
   fail s = hasError s
Applicative instance: 


instance Monad m => Applicative (MonadWithError m) where
   pure = return
   (<*>) = ap
Monad instance: 


instance Monad m => Monad (MonadWithError m) where
   return v = MonadWithError (return (Value v))
   (>>=) (MonadWithError act1) getAct2 =
      MonadWithError (
         do
            valWithError <- act1
            case valWithError of
               Value v ->
                  let
                     (MonadWithError act2) = getAct2 v
                  in
                     act2
               Error s -> return (Error s)
         )
   fail s = MonadWithError (return (Error s))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uni-util-2.3.0.1/Util/Sources.hs
Applicative instance: 


instance Applicative SimpleSource where
   pure = return
   (<*>) = ap
Monad instance: 


instance Monad SimpleSource where
   return x = SimpleSource (staticSource x)
   (>>=) (SimpleSource source1) getSimpleSource2 =
      let
         getSource2 x =
            let
               (SimpleSource source2) = getSimpleSource2 x
            in
               source2
      in
         SimpleSource (seqSource source1 getSource2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/comonad-random-0.1.2/Control/Comonad/Random.hs
Applicative instance: 


instance Applicative Three where
    pure x = Three (x, x, x)
    Three ~(f, g, h) <*> Three ~(x, y, z) = Three (f x, g y, h z)
Applicative instance: 


instance Applicative Rand where
    pure x = let tree = cofree x $ Three (tree, tree, tree)
             in Rand tree
    Rand a <*> Rand b = let ~(f, fs) = runCofree a
                            ~(x, xs) = runCofree b
                        in Rand . cofree (f x) . fmap unRand .
                           liftA2 (<*>) (fmap Rand fs) . fmap Rand $ xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HoleyMonoid-0.1.1/Data/HoleyMonoid.hs
Applicative instance: 


instance Applicative (HoleyMonoid m r) where
  pure x = HoleyMonoid (pure x)
  HoleyMonoid f <*> HoleyMonoid g = HoleyMonoid (f <*> g)
Monad instance: 


instance Monad (HoleyMonoid m r) where
  return x = HoleyMonoid (return x)
  HoleyMonoid f >>= g = HoleyMonoid (f >>= \x -> runHM (g x))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Frames-0.1.6/src/Frames/Frame.hs
Applicative instance: 


instance Applicative Frame where
  -- | A frame of 'maxBound' rows, each of which is the given value.
  pure x = Frame maxBound (const x)
  -- | Zips two 'Frame's together, applying the rows of the first to
  -- those of the second. The result has as many rows as the smaller
  -- of the two argument 'Frame's.
  Frame l1 f1 <*> Frame l2 f2 = Frame (min l1 l2) $ ($) <$> f1 <*> f2
Monad instance: 


instance Monad Frame where
  -- | A frame of 'maxBound' rows, each of which is the given value.
  return = pure
  -- | Like 'concatMap' for lists.
  Frame l f >>= fb = foldMap (fb . f) [0 .. l - 1]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghc-exactprint-0.5.2.1/tests/examples/ghc8/T5908.hs
Monad instance: 


instance (Category w, Prelude.Monad m) => Monad (WriterT w m) where
  return a = WriterT $ return (a, id)
    where
      return = Prelude.return
  m >>= k = WriterT $ do
    ~(a, w) <- runWriterT m
    ~(b, w') <- runWriterT (k a)
    return (b, w >>> w')
    where
      (>>=) = (Prelude.>>=)
      return = Prelude.return
  fail msg = WriterT $ fail msg
    where
      fail = Prelude.fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghc-exactprint-0.5.2.1/tests/examples/ghc8/T10753.hs
Monad instance: 

instance (Monad m) => Monad (StateT s m) where
Applicative instance: 

instance (Functor m, Monad m) => Applicative (StateT s m) where
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghc-exactprint-0.5.2.1/tests/examples/ghc8/T11128.hs
Applicative instance: 


instance A.Applicative T0 where
    pure   = T0
    (<*>)  = M.ap
Monad instance: 


instance M.Monad T0 where
    (>>=)  = undefined
Applicative instance: 


instance A.Applicative T1 where
    pure   = return
    (<*>)  = M.ap
    (*>)   = (M.>>)
Monad instance: 


instance M.Monad T1 where
    (>>=)  = undefined
    return = T1
    (>>)   = undefined
Applicative instance: 


instance Applicative T2 where
    pure   = T2
    (<*>)  = ap
    (*>)   = undefined
Monad instance: 


instance M.Monad T2 where
    (>>=)  = undefined
    return = pure
    (>>)   = (*>)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghc-exactprint-0.5.2.1/tests/examples/ghc8/MonadFailWarningsDisabled.hs
Applicative instance: 

instance Applicative Maybe' where pure = undefined; (<*>) = undefined
Monad instance: 

instance Monad Maybe' where (>>=) = undefined
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghc-exactprint-0.5.2.1/tests/examples/ghc8/MonadFailWarnings.hs
Applicative instance: 

instance Applicative Maybe' where pure = undefined; (<*>) = undefined
Monad instance: 

instance Monad Maybe' where (>>=) = undefined
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghc-exactprint-0.5.2.1/tests/examples/ghc710/Undefined4.hs
Applicative instance: 


instance Applicative (StateL s) where
    pure x = StateL (\ s -> (s, x))
    StateL kf <*> StateL kv = StateL $ \ s ->
        let (s', f) = kf s
            (s'', v) = kv s'
        in (s'', f v)
Applicative instance: 


instance Applicative (StateR s) where
    pure x = StateR (\ s -> (s, x))
    StateR kf <*> StateR kv = StateR $ \ s ->
        let (s', v) = kv s
            (s'', f) = kf s'
        in (s'', f v)
Applicative instance: 


instance Applicative Id where
    pure = Id
    Id f <*> Id x = Id (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghc-exactprint-0.5.2.1/tests/examples/ghc710/Expr.hs
Monad instance: 

instance Monad (CharParser a) where
Applicative instance: 

instance Applicative (CharParser a) where
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ampersand-3.1.0/src/Database/Design/Ampersand/ADL1/Disambiguate.hs
Applicative instance: 

instance Applicative Change where
 (<*>) (Change f b) (Change a b2) = Change (f a) (b && b2)
 pure a = Change a True
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ampersand-3.1.0/src/Database/Design/Ampersand/Input/ADL1/LexerMonad.hs
Monad instance: 


instance Monad LexerMonad where
    (>>=) = bindLM
    return = returnLM
Applicative instance: 


instance Applicative LexerMonad where
    pure = returnLM
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ampersand-3.1.0/src/Database/Design/Ampersand/Input/ADL1/CtxError.hs
Applicative instance: 


instance Applicative Guarded where
 pure = Checked
 (<*>) (Checked f) (Checked a) = Checked (f a)
 (<*>) (Errors  a) (Checked _) = Errors a
 (<*>) (Checked _) (Errors  b) = Errors b
 (<*>) (Errors  a) (Errors  b) = Errors (a ++ b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/supplemented-0.5.1/library/Supplemented.hs
Applicative instance: 


instance Monad m => Applicative (Supplemented m) where
  {-# INLINE pure #-}
  pure a =
    Supplemented (Left (a, pure ()))
  {-# INLINABLE [2] (<*>) #-}
  (<*>) (Supplemented either1) (Supplemented either2) =
    {-# SCC "(<*>)" #-}
    Supplemented either3
    where
      either3 =
        case either1 of
          Left (result1, supplement1) ->
            case either2 of
              Left (result2, supplement2) ->
                Left (result1 result2, supplement1 *> supplement2)
              Right m2 ->
                Right $
                liftM (\(result2, supplement2) -> (result1 result2, supplement2)) $
                supplement1 *> m2
          Right m1 ->
            case either2 of
              Left (result2, supplement2) ->
                Right $
                liftM (\(result1, supplement1) -> (result1 result2, supplement1 *> supplement2)) $
                m1
              Right m2 ->
                Right $
                do
                  (result1, supplement1) <- m1
                  supplement1
                  (result2, supplement2) <- m2
                  return (result1 result2, supplement2)
Monad instance: 


instance Monad m => Monad (Supplemented m) where
  {-# INLINE return #-}
  return =
    pure
  {-# INLINABLE (>>=) #-}
  (>>=) (Supplemented either1) k2 =
    {-# SCC "(>>=)" #-}
    Supplemented either3
    where
      either3 =
        case either1 of
          Left (result1, supplement1) ->
            case k2 result1 of
              Supplemented either2 ->
                case either2 of
                  Left (result2, supplement2) ->
                    Left (result2, supplement1 *> supplement2)
                  Right m2 ->
                    Right (supplement1 *> m2)
          Right m1 ->
            Right $
            do
              (result1, supplement1) <- m1
              case k2 result1 of
                Supplemented either2 ->
                  case either2 of
                    Left (result2, supplement2) ->
                      return (result2, supplement1 *> supplement2)
                    Right m2 ->
                      do
                        supplement1
                        m2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/nanoparsec-0.1.1/Data/Nanoparsec/Internal.hs
Applicative instance: 


instance Monoid δ ⇒ Applicative (Parser δ) where
    pure = return
    {-# INLINE pure #-}
    {-# SPECIALIZE pure ∷ a → Parser B.ByteString a #-}
    {-# SPECIALIZE pure ∷ a → Parser LB.ByteString a #-}
    (<*>) = ap
    {-# INLINE (<*>) #-}
    {-# SPECIALIZE (<*>) ∷ Parser B.ByteString (a → b) → Parser B.ByteString a → Parser B.ByteString b #-}
    {-# SPECIALIZE (<*>) ∷ Parser LB.ByteString (a → b) → Parser LB.ByteString a → Parser LB.ByteString b #-}
    (*>) = (>>)
    {-# INLINE (*>) #-}
    {-# SPECIALIZE (*>) ∷ Parser B.ByteString a → Parser B.ByteString b → Parser B.ByteString b #-}
    {-# SPECIALIZE (*>) ∷ Parser LB.ByteString a → Parser LB.ByteString b → Parser LB.ByteString b #-}
    x <* y = x >>= \a → y >> return a
    {-# INLINE (<*) #-}
    {-# SPECIALIZE (<*) ∷ Parser B.ByteString a → Parser B.ByteString b → Parser B.ByteString a #-}
    {-# SPECIALIZE (<*) ∷ Parser LB.ByteString a → Parser LB.ByteString b → Parser LB.ByteString a #-}
Monad instance: 


instance Monoid δ ⇒ Monad (Parser δ) where
    return x = Parser $ \s _ su → su x s
    {-# INLINE return #-}
    {-# SPECIALIZE return ∷ a → Parser B.ByteString a #-}
    {-# SPECIALIZE return ∷ a → Parser LB.ByteString a #-}
    Parser p >>= g
        = Parser $ \s fa su → p s fa (\a s' → runParser (g a) s' fa su)
    {-# INLINE (>>=) #-}
    {-# SPECIALIZE (>>=) ∷ Parser B.ByteString a → (a → Parser B.ByteString b) → Parser B.ByteString b #-}
    {-# SPECIALIZE (>>=) ∷ Parser LB.ByteString a → (a → Parser LB.ByteString b) → Parser LB.ByteString b #-}
    Parser p >> Parser r
        = Parser $ \s fa su → p s fa (\_ s' → r s' fa su)
    {-# INLINE (>>) #-}
    {-# SPECIALIZE (>>) ∷ Parser B.ByteString a → Parser B.ByteString b → Parser B.ByteString b #-}
    {-# SPECIALIZE (>>) ∷ Parser LB.ByteString a → Parser LB.ByteString b → Parser LB.ByteString b #-}
    fail err = Parser (\s fa _ → fa s [] ("Failed reading: " ++ err))
    {-# INLINE fail #-}
    {-# SPECIALIZE fail ∷ String → Parser B.ByteString a #-}
    {-# SPECIALIZE fail ∷ String → Parser LB.ByteString a #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/MonadPrompt-1.0.0.5/Control/Monad/Prompt.hs
Monad instance: 


instance Monad (Prompt p) where
    return a = Prompt $ \done _   -> done a
    f >>= g  = Prompt $ \done prm -> runP f (\x -> runP (g x) done prm) prm
Applicative instance: 


instance Applicative (Prompt p) where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad (RecPrompt p) where
    return  = RecPrompt . return
    m >>= f = RecPrompt $ unRecPrompt m >>= (unRecPrompt . f)
Applicative instance: 


instance Applicative (RecPrompt p) where
    pure    = return
    (<*>)   = ap
Monad instance: 


instance Monad (PromptT p m) where
   return  = PromptT . return
   m >>= f = PromptT $ unPromptT m >>= (unPromptT . f)
Applicative instance: 


instance Applicative (PromptT p m) where
   pure    = return
   (<*>)   = ap
Monad instance: 


instance Monad (RecPromptT p m) where
   return  = RecPromptT . return
   m >>= f = RecPromptT $ unRecPromptT m >>= (unRecPromptT . f)
Applicative instance: 


instance Applicative (RecPromptT p m) where
   pure    = return
   (<*>)   = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/diagrams-rubiks-cube-0.2.0.0/src/Diagrams/RubiksCube/Model.hs
Applicative instance: 


instance Applicative Vec3 where
  pure v = Vec3 v v v
  Vec3 f1 f2 f3 <*> Vec3 v1 v2 v3 =
    Vec3 (f1 v1) (f2 v2) (f3 v3)
Applicative instance: 


instance Applicative Vec4 where
  pure v = Vec4 v v v v
  Vec4 f1 f2 f3 f4 <*> Vec4 v1 v2 v3 v4 =
    Vec4 (f1 v1) (f2 v2) (f3 v3) (f4 v4)
Applicative instance: 


instance  Applicative Side where
  pure v = Side v v v v v v v v v
  Side f1 f2 f3 f4 f5 f6 f7 f8 f9 <*> Side v1 v2 v3 v4 v5 v6 v7 v8 v9 =
    Side (f1 v1) (f2 v2) (f3 v3) (f4 v4) (f5 v5) (f6 v6) (f7 v7) (f8 v8) (f9 v9)
Applicative instance: 


instance Applicative Cube where
  pure v = Cube v v v v v v
  Cube ff fb fl fr fu fd <*> Cube vf vb vl vr vu vd =
    Cube (ff vf) (fb vb) (fl vl) (fr vr) (fu vu) (fd vd)
Applicative instance: 


instance Applicative RubiksCube where
  pure = RubiksCube . pure . pure
  RubiksCube f <*> RubiksCube v = RubiksCube ((<*>) <$> f <*> v)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bearriver-0.10.4/src/FRP/BearRiver.hs
Applicative instance: 


instance Applicative Event where
  pure = Event

  Event f <*> Event x = Event (f x)
  _       <*> _       = NoEvent
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sylvia-0.2.2/Sylvia/Model.hs
Applicative instance: 


instance Applicative Inc where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad Inc where
    return = S
    val >>= f = joinI (mapI f val)
Applicative instance: 


instance Applicative Exp where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad Exp where
    return = Ref
    e >>= f = joinE (mapE f e)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sylvia-0.2.2/Sylvia/Render/Pair.hs
Applicative instance: 


instance Applicative P where
    pure x = x :| x
    f :| g <*> x :| y = f x :| g y
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SimpleGL-0.9.3/src/SimpleH/GL/Base.hs
Applicative instance: 

instance Applicative V2 where
  V2 fx fy <*> V2 x y = V2 (fx x) (fy y)
Applicative instance: 

instance Applicative V3 where
  V3 fx fy fz <*> V3 x y z = V3 (fx x) (fy y) (fz z)
Applicative instance: 

instance Applicative V4 where
  V4 fx fy fz fw <*> V4 x y z w = V4 (fx x) (fy y) (fz z) (fw w)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SimpleGL-0.9.3/src/SimpleH/GL.hs
Applicative instance: 

instance Applicative Vector3 where
  Vector3 fx fy fz <*> Vector3 x y z = Vector3 (fx x) (fy y) (fz z)
Applicative instance: 

instance Applicative Vertex3 where
  Vertex3 fx fy fz <*> Vertex3 x y z = Vertex3 (fx x) (fy y) (fz z)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/future-resource-0.4.0.0/Control/Future.hs
Applicative instance: 


instance Monoid a => Applicative (Future a) where
        pure = Future . return . Finished
        Future fs <*> Future as =
                Future $ do
                        fs' <- fs
                        as' <- as
                        return $ case (fs', as') of
                                (Finished f, Finished a) -> Finished $ f a
                                (Fixme f, Finished _) -> Fixme f
                                (Finished _, Fixme a) -> Fixme a
                                (Fixme f, Fixme a) -> Fixme (f `mappend` a)
                                _ -> Making
Monad instance: 


instance Monoid a => Monad (Future a) where
        return = pure
        Future m >>= f =
                Future $ do
                        m' <- m
                        case m' of
                                Finished x -> runFuture (f x)
                                Fixme l -> return (Fixme l)
                                Making -> return Making
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/stochastic-0.1.1.1/src/Data/Stochastic/Types.hs
Monad instance: 


-- | Monad instance for Sample.
instance (RandomGen g, Sampleable d) => Monad (Sample g d) where
    return x = Sample $ do
                modify (snd . next)
                return $ certainDist x

    (>>=) ma f = Sample $ do
                     modify (snd . next)
                     dist <- runSample ma
                     g <- get
                     let a = fst $ sampleFrom dist g
                     runSample (f a)
Applicative instance: 


-- | Trivial 'Applicative' instance for 'Sample' 'StdGen' 'Distribution'.
instance (RandomGen g, Sampleable s) => Applicative (Sample g s) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lens-4.9.1/src/Control/Lens/Reified.hs
Applicative instance: 


instance Applicative (ReifiedGetter s) where
  pure a = Getter $ to $ \_ -> a
  {-# INLINE pure #-}
  Getter mf <*> Getter ma = Getter $ to $ \s -> view mf s (view ma s)
  {-# INLINE (<*>) #-}
  m <* _ = m
  {-# INLINE (<*) #-}
  _ *> m = m
  {-# INLINE (*>) #-}
Monad instance: 


instance Monad (ReifiedGetter s) where
  return a = Getter $ to $ \_ -> a
  {-# INLINE return #-}
  Getter ma >>= f = Getter $ to $ \s -> view (runGetter (f (view ma s))) s
  {-# INLINE (>>=) #-}
Applicative instance: 


instance Applicative (ReifiedFold s) where
  pure a = Fold $ folding $ \_ -> [a]
  {-# INLINE pure #-}
  Fold mf <*> Fold ma = Fold $ folding $ \s -> toListOf mf s <*> toListOf ma s
  {-# INLINE (<*>) #-}
  Fold mf <* Fold ma = Fold $ folding $ \s -> toListOf mf s <* toListOf ma s
  {-# INLINE (<*) #-}
  Fold mf *> Fold ma = Fold $ folding $ \s -> toListOf mf s *> toListOf ma s
  {-# INLINE (*>) #-}
Monad instance: 


instance Monad (ReifiedFold s) where
  return a = Fold $ folding $ \_ -> [a]
  {-# INLINE return #-}
  Fold ma >>= f = Fold $ folding $ \s -> toListOf ma s >>= \a -> toListOf (runFold (f a)) s
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lens-4.9.1/src/Control/Lens/Internal/Level.hs
Applicative instance: 


-- | This is an illegal 'Applicative'.
instance Applicative (Flows i b) where
  pure a = Flows (const a)
  {-# INLINE pure #-}
  Flows mf <*> Flows ma = Flows $ \ xss -> case xss of
    []             -> mf [] (ma [])
    (_:xs)         -> mf (triml <$> xs) $ ma (trimr <$> xs)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lens-4.9.1/src/Control/Lens/Internal/Magma.hs
Applicative instance: 


instance Applicative (Molten i a b) where
  pure  = Molten #. MagmaPure
  {-# INLINE pure #-}
  Molten xs <*> Molten ys = Molten (MagmaAp xs ys)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative (Mafic a b) where
  pure a = Mafic 0 $ \_ -> MagmaPure a
  {-# INLINE pure #-}
  Mafic wf mf <*> ~(Mafic wa ma) = Mafic (wf + wa) $ \o -> MagmaAp (mf o) (ma (o + wf))
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative (TakingWhile p f a b) where
  pure a = TakingWhile True a $ \_ -> MagmaPure a
  {-# INLINE pure #-}
  TakingWhile wf tf mf <*> ~(TakingWhile wa ta ma) = TakingWhile (wf && wa) (tf ta) $ \o ->
    if o then MagmaAp (mf True) (ma wf) else MagmaPure (tf ta)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lens-4.9.1/src/Control/Lens/Internal/Deque.hs
Applicative instance: 


instance Applicative Deque where
  pure a = BD 1 [a] 0 []
  {-# INLINE pure #-}
  fs <*> as = fromList (toList fs <*> toList as)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Deque where
  return a = BD 1 [a] 0 []
  {-# INLINE return #-}
  ma >>= k = fromList (toList ma >>= toList . k)
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lens-4.9.1/src/Control/Lens/Internal/Zoom.hs
Applicative instance: 


instance (Monad m, Monoid s) => Applicative (Focusing m s) where
  pure a = Focusing (return (mempty, a))
  {-# INLINE pure #-}
  Focusing mf <*> Focusing ma = Focusing $ do
    (s, f) <- mf
    (s', a) <- ma
    return (mappend s s', f a)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance (Monad m, Monoid s, Monoid w) => Applicative (FocusingWith w m s) where
  pure a = FocusingWith (return (mempty, a, mempty))
  {-# INLINE pure #-}
  FocusingWith mf <*> FocusingWith ma = FocusingWith $ do
    (s, f, w) <- mf
    (s', a, w') <- ma
    return (mappend s s', f a, mappend w w')
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative (k (s, w)) => Applicative (FocusingPlus w k s) where
  pure = FocusingPlus . pure
  {-# INLINE pure #-}
  FocusingPlus kf <*> FocusingPlus ka = FocusingPlus (kf <*> ka)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative (k (f s)) => Applicative (FocusingOn f k s) where
  pure = FocusingOn . pure
  {-# INLINE pure #-}
  FocusingOn kf <*> FocusingOn ka = FocusingOn (kf <*> ka)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative (k (May s)) => Applicative (FocusingMay k s) where
  pure = FocusingMay . pure
  {-# INLINE pure #-}
  FocusingMay kf <*> FocusingMay ka = FocusingMay (kf <*> ka)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative (k (Err e s)) => Applicative (FocusingErr e k s) where
  pure = FocusingErr . pure
  {-# INLINE pure #-}
  FocusingErr kf <*> FocusingErr ka = FocusingErr (kf <*> ka)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance (Monad m, Monoid r) => Applicative (Effect m r) where
  pure _ = Effect (return mempty)
  {-# INLINE pure #-}
  Effect ma <*> Effect mb = Effect (liftM2 mappend ma mb)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance (Monoid s, Monoid w, Monad m) => Applicative (EffectRWS w st m s) where
  pure _ = EffectRWS $ \st -> return (mempty, st, mempty)
  {-# INLINE pure #-}
  EffectRWS m <*> EffectRWS n = EffectRWS $ \st -> m st >>= \ (s,t,w) -> n t >>= \ (s',u,w') -> return (mappend s s', u, mappend w w')
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lens-4.9.1/src/Control/Lens/Internal/Bazaar.hs
Applicative instance: 


instance Applicative (Bazaar p a b) where
  pure a = Bazaar $ \_ -> pure a
  {-# INLINE pure #-}
  Bazaar mf <*> Bazaar ma = Bazaar $ \ pafb -> mf pafb <*> ma pafb
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative (BazaarT p g a b) where
  pure a = BazaarT $ tabulate $ \_ -> pure (pure a)
  {-# INLINE pure #-}
  BazaarT mf <*> BazaarT ma = BazaarT $ \ pafb -> mf pafb <*> ma pafb
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lens-4.9.1/src/Control/Lens/Internal/Indexed.hs
Applicative instance: 


instance Applicative (Indexed i a) where
  pure b = Indexed $ \_ _ -> b
  {-# INLINE pure #-}
  Indexed f <*> Indexed g = Indexed $ \i a -> f i a (g i a)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad (Indexed i a) where
  return b = Indexed $ \_ _ -> b
  {-# INLINE return #-}
  Indexed f >>= k = Indexed $ \i a -> runIndexed (k (f i a)) i a
  {-# INLINE (>>=) #-}
Applicative instance: 


instance Applicative f => Applicative (Indexing f) where
  pure x = Indexing $ \i -> (i, pure x)
  {-# INLINE pure #-}
  Indexing mf <*> Indexing ma = Indexing $ \i -> case mf i of
    (j, ff) -> case ma j of
       ~(k, fa) -> (k, ff <*> fa)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative f => Applicative (Indexing64 f) where
  pure x = Indexing64 $ \i -> (i, pure x)
  {-# INLINE pure #-}
  Indexing64 mf <*> Indexing64 ma = Indexing64 $ \i -> case mf i of
    (j, ff) -> case ma j of
       ~(k, fa) -> (k, ff <*> fa)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lambdabot-core-5.1/src/Lambdabot/Command.hs
Applicative instance: 

instance Applicative f => Applicative (Cmd f) where
    pure = Cmd . pure
    Cmd f <*> Cmd x = Cmd (f <*> x)
Monad instance: 

instance Monad m => Monad (Cmd m) where
    return = Cmd . return
    Cmd x >>= f = Cmd (x >>= (unCmd . f))
    fail = lift . fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/blaze-builder-0.4.0.2/benchmarks/UnboxedAppend.hs
Monad instance: 


instance Monad Put where
  return x = Put $ \k -> k x
  {-# INLINE return #-}
  m >>= f  = Put $ \k -> unPut m (\x -> unPut (f x) k)
  {-# INLINE (>>=) #-}
  m >>  n  = Put $ \k -> unPut m (\_ -> unPut n k)
  {-# INLINE (>>) #-}
Monad instance: 


instance Monad LBSM where
    return x                       = LBSM (x, id)
    (LBSM (x,k)) >>= f             = let LBSM (x',k') = f x in LBSM (x', k . k')
    (LBSM (_,k)) >> (LBSM (x',k')) = LBSM (x', k . k')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/blaze-builder-0.4.0.2/benchmarks/Throughput/BlazePutMonad.hs
Applicative instance: 


instance Applicative PutM where
        pure    = return
        m <*> k = Put $
            let PairS f w  = unPut m
                PairS x w' = unPut k
            in PairS (f x) (w `mappend` w')
Monad instance: 


-- Standard Writer monad, with aggressive inlining
instance Monad PutM where
    return a = Put $ PairS a mempty
    {-# INLINE return #-}

    m >>= k  = Put $
        let PairS a w  = unPut m
            PairS b w' = unPut (k a)
        in PairS b (w `mappend` w')
    {-# INLINE (>>=) #-}

    m >> k  = Put $
        let PairS _ w  = unPut m
            PairS b w' = unPut k
        in PairS b (w `mappend` w')
    {-# INLINE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/blaze-builder-0.4.0.2/benchmarks/FastPut.hs
Monad instance: 


instance Monad Put where
  return x = Put $ \k -> k x
  {-# INLINE return #-}
  m >>= f  = Put $ \k -> unPut m (\x -> unPut (f x) k)
  {-# INLINE (>>=) #-}
  m >>  n  = Put $ \k -> unPut m (\_ -> unPut n k)
  {-# INLINE (>>) #-}
Monad instance: 


instance Monad LBSM where
    return x                       = LBSM (x, id)
    (LBSM (x,k)) >>= f             = let LBSM (x',k') = f x in LBSM (x', k . k')
    (LBSM (_,k)) >> (LBSM (x',k')) = LBSM (x', k . k')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/grapefruit-frp-0.1.0.5/src/Internal/Signal/Discrete/Capsule.hs
Applicative instance: 


    instance Applicative Capsule where

        pure = Capsule

        Capsule fun <*> Capsule arg = Capsule (fun arg)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/midi-0.2.2.1/src/Sound/MIDI/Parser/File.hs
Applicative instance: 


instance Applicative T where
   pure = return
   (<*>) = ap
Monad instance: 


instance Monad T where
   return = Cons . return
   x >>= y = Cons $ decons . y =<< decons x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/midi-0.2.2.1/src/Sound/MIDI/Parser/Restricted.hs
Applicative instance: 


instance (Applicative parser, Monad parser) => Applicative (T parser) where
   pure = Cons . pure
   Cons f <*> Cons a = Cons $ f <*> a
Monad instance: 


instance Monad parser => Monad (T parser) where
   return = Cons . return
   x >>= y = Cons $ decons . y =<< decons x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/midi-0.2.2.1/src/Sound/MIDI/Parser/ByteString.hs
Applicative instance: 


instance Applicative T where
   pure = return
   (<*>) = ap
Monad instance: 


instance Monad T where
   return = Cons . return
   x >>= y = Cons $ decons . y =<< decons x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/midi-0.2.2.1/parser/Sound/MIDI/Parser/Stream.hs
Applicative instance: 


instance Applicative (T str) where
   pure = return
   (<*>) = ap
Monad instance: 


instance Monad (T str) where
   return = Cons . return
   x >>= y = Cons $ decons . y =<< decons x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bits-0.5/src/Data/Bits/Coding.hs
Applicative instance: 


instance Monad m => Applicative (Coding m) where
  pure a = Coding $ \k -> k a
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad m => Monad (Coding m) where
  return = pure
  {-# INLINE return #-}
  Coding m >>= f = Coding $ \ k -> m $ \a -> runCoding (f a) k
  {-# INLINE (>>=) #-}
  fail e = Coding $ \_ _ _ -> fail e
  {-# INLINE fail #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uhc-util-0.1.6.6/src/UHC/Util/CompileRun.hs
Applicative instance: 


instance CompileRunner state n pos loc u i e m => Applicative (CompilePhaseT n u i e m) where
    pure  = return
    (<*>) = ap
Monad instance: 


-- instance CompileRunner state n pos loc u i e m where

instance CompileRunner state n pos loc u i e m => Monad (CompilePhaseT n u i e m) where
  return x = CompilePhaseT $ return x -- \cr -> return (x, cr)
  cp >>= f = CompilePhaseT $ do -- \cr1 -> do
        x <- cpHandleErr' $ runCompilePhaseT cp -- (x,cr2) <- runCompilePhaseT cp cr1
{-        
        let modf f = do {modify f ; return x}
        cr <- get
        case crState cr of
          CRSFailErrL about es mbLim
            -> do { let (showErrs,omitErrs) = maybe (es,[]) (flip splitAt es) mbLim
                  ; liftIO (unless (null about) (hPutPPLn stderr (pp about)))
                  ; liftIO $ unless (null showErrs) $ 
                           do { hPutPPLn stderr (crePPErrL showErrs)
                              ; unless (null omitErrs) $ hPutStrLn stderr "... and more errors"
                              ; hFlush stderr
                              }
                  ; if creAreFatal es then liftIO exitFailure else modf crSetOk
                  }
          CRSErrInfoL about doPrint is
            -> do { if null is
                    then return x
                    else liftIO (do { hFlush stdout
                                    ; hPutPPLn stderr (about >#< "found errors" >-< e)
                                    ; return x
                                    })
                  ; if not (null is) then liftIO exitFailure else return x
                  }
            where e = empty -- if doPrint then crePPErrL is else empty
          CRSFailMsg msg
            -> do { liftIO $ hPutStrLn stderr msg
                  ; liftIO exitFailure
                  }
          CRSFail
            -> do { liftIO exitFailure
                  }
          CRSStop
            -> do { liftIO $ exitWith ExitSuccess
                  }
          _ -> return x
-}
        cr <- get
        case crState cr of
          CRSOk         -> runCompilePhaseT (f x)
          CRSStopSeq    -> do { modify crSetOk ; ME.throwError CRSStopSeq }
          CRSStopAllSeq -> do { modify crSetStopAllSeq ; ME.throwError CRSStopAllSeq }
          crs           -> ME.throwError crs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uhc-util-0.1.6.6/src/UHC/Util/CompileRun3.hs
Applicative instance: 


instance CompileRunner state n pos loc u i e m => Applicative (CompilePhaseT n u i e m) where
    pure  = return
    (<*>) = ap
Monad instance: 


-- instance CompileRunner state n pos loc u i e m where

instance CompileRunner state n pos loc u i e m => Monad (CompilePhaseT n u i e m) where
  return x = CompilePhaseT $ return x -- \cr -> return (x, cr)
  cp >>= f = CompilePhaseT $ do -- \cr1 -> do
        x <- {- cpHandleErr' $ -} runCompilePhaseT cp -- (x,cr2) <- runCompilePhaseT cp cr1
        let modf f = do {modify f ; return x}
        cr <- get
        case _crState cr of
          CRSFailErrL about es mbLim
            -> do { let (showErrs,omitErrs) = maybe (es,[]) (flip splitAt es) mbLim
                  ; liftIO (unless (null about) (hPutPPLn stderr (pp about)))
                  ; liftIO $ unless (null showErrs) $
                           do { hPutPPLn stderr (crePPErrL showErrs)
                              ; unless (null omitErrs) $ hPutStrLn stderr "... and more errors"
                              ; hFlush stderr
                              }
                  ; if creAreFatal es then liftIO exitFailure else modf crSetOk
                  }
          CRSErrInfoL about doPrint is
            -> do { if null is
                    then return x
                    else liftIO (do { hFlush stdout
                                    ; hPutPPLn stderr (about >#< "found errors" >-< e)
                                    ; return x
                                    })
                  ; if not (null is) then liftIO exitFailure else return x
                  }
            where e = empty -- if doPrint then crePPErrL is else empty
          CRSFailMsg msg
            -> do { liftIO $ hPutStrLn stderr msg
                  ; liftIO exitFailure
                  }
          CRSFail
            -> do { liftIO exitFailure
                  }
          CRSStop
            -> do { liftIO $ exitWith ExitSuccess
                  }
          _ -> return x
        cr <- get
        case _crState cr of
          CRSOk         -> runCompilePhaseT (f x)
          CRSStopSeq    -> do { modf crSetOk ; return $ panic "Monad.CompilePhaseT.CRSStopSeq" }
          CRSStopAllSeq -> do { modf crSetStopAllSeq ; return $ panic "Monad.CompilePhaseT.CRSStopAllSeq" }
          crs           -> return $ panic "Monad.CompilePhaseT._"
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uhc-util-0.1.6.6/src/UHC/Util/CompileRun2.hs
Applicative instance: 


instance CompileRunner state n pos loc u i e m => Applicative (CompilePhaseT n u i e m) where
    pure  = return
    (<*>) = ap
Monad instance: 


-- instance CompileRunner state n pos loc u i e m where

instance CompileRunner state n pos loc u i e m => Monad (CompilePhaseT n u i e m) where
  return x = CompilePhaseT $ return x -- \cr -> return (x, cr)
  cp >>= f = CompilePhaseT $ do -- \cr1 -> do
        x <- {- cpHandleErr' $ -} runCompilePhaseT cp -- (x,cr2) <- runCompilePhaseT cp cr1
        let modf f = do {modify f ; return x}
        cr <- get
        case _crState cr of
          CRSFailErrL about es mbLim
            -> do { let (showErrs,omitErrs) = maybe (es,[]) (flip splitAt es) mbLim
                  ; liftIO (unless (null about) (hPutPPLn stderr (pp about)))
                  ; liftIO $ unless (null showErrs) $
                           do { hPutPPLn stderr (crePPErrL showErrs)
                              ; unless (null omitErrs) $ hPutStrLn stderr "... and more errors"
                              ; hFlush stderr
                              }
                  ; if creAreFatal es then liftIO exitFailure else modf crSetOk
                  }
          CRSErrInfoL about doPrint is
            -> do { if null is
                    then return x
                    else liftIO (do { hFlush stdout
                                    ; hPutPPLn stderr (about >#< "found errors" >-< e)
                                    ; return x
                                    })
                  ; if not (null is) then liftIO exitFailure else return x
                  }
            where e = empty -- if doPrint then crePPErrL is else empty
          CRSFailMsg msg
            -> do { liftIO $ hPutStrLn stderr msg
                  ; liftIO exitFailure
                  }
          CRSFail
            -> do { liftIO exitFailure
                  }
          CRSStop
            -> do { liftIO $ exitWith ExitSuccess
                  }
          _ -> return x
        cr <- get
        case _crState cr of
          CRSOk         -> runCompilePhaseT (f x)
          CRSStopSeq    -> do { modf crSetOk ; return $ panic "Monad.CompilePhaseT.CRSStopSeq" }
          CRSStopAllSeq -> do { modf crSetStopAllSeq ; return $ panic "Monad.CompilePhaseT.CRSStopAllSeq" }
          crs           -> return $ panic "Monad.CompilePhaseT._"
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/casui-0.3/Casui/Menu.hs
Monad instance: 


instance Monad GenMenu where
    return = GenMenu []
    GenMenu l a >>= f = case f a of GenMenu k b -> GenMenu (l++k) b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/casui-0.3/Casui/Draw.hs
Monad instance: 


instance Monad (Draw t) where
    return a = Draw $ \_ _ _ -> return (Nothing, a)
    d >>= f = Draw $ \s c m -> do (d, a) <- drawF d s c m
                                  (e, a') <- drawF (f a) s c m
                                  return (case (d, e) of
                                            (Just x, Just y) -> Just $ m x y
                                            (Just x, _) -> Just x
                                            (_, Just y) -> Just y
                                            _ -> Nothing
                                         , a')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/casui-0.3/Casui/Casui.hs
Monad instance: 


instance Monad (Casui l) where
  (Casui f) >>= g = Casui $ \s c e -> do
    (a, e) <- f s c e
    let Casui h = g a
    h s c e
  return a = Casui $ \s c e -> return (a, e)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/parsec-permutation-0.1.2.0/Text/Parsec/Permutation.hs
Applicative instance: 


instance Stream s m t => Applicative (PermParser s u m) where
  parser1 <*> parser2 =
      PermParser (permValue parser1 <*> permValue parser2)
                 (attemptParser1 <|> attemptParser2)
    where attemptParser1 = do parser1 <- permParser parser1
                              return $ parser1 <*> parser2
          attemptParser2 = do parser2 <- permParser parser2
                              return $ parser1 <*> parser2

  pure value = PermParser (Just value) parserZero
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/active-0.2.0.9/src/Data/Active.hs
Applicative instance: 


instance Applicative Duration where
  pure = Duration
  Duration f <*> Duration x = Duration (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/IOSpec-0.3/src/Test/IOSpec/VirtualMachine.hs
Applicative instance: 


instance Applicative Effect where
  pure = Done
  (<*>) = ap
Monad instance: 


instance Monad Effect where
  return = Done
  (Done x) >>= f = f x
  (ReadChar t) >>= f = ReadChar (\c -> t c >>= f)
  (Print c t) >>= f = Print c (t >>= f)
  (Fail msg) >>= _ = Fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/IOSpec-0.3/src/Test/IOSpec/Types.hs
Applicative instance: 


instance (Functor f) => Applicative (IOSpec f) where
  pure             = Pure
  (<*>)            = ap
Monad instance: 


instance (Functor f) => Monad (IOSpec f) where
  return           = Pure
  (Pure x) >>= f   = f x
  (Impure t) >>= f = Impure (fmap (>>= f) t)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/IOSpec-0.3/src/Test/IOSpec/STM.hs
Applicative instance: 


instance Applicative STM where
  pure  = STMReturn
  (<*>) = ap
Monad instance: 


instance Monad STM where
  return                = STMReturn
  STMReturn a >>= f     = f a
  NewTVar d g >>= f     = NewTVar d (\l -> g l >>= f)
  ReadTVar l g >>= f    = ReadTVar l (\d -> g d >>= f)
  WriteTVar l d p >>= f = WriteTVar l d (p >>= f)
  Retry >>= _           = Retry
  OrElse p q >>= f      = OrElse (p >>= f) (q >>= f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hood-0.3/Debug/Hood/Observe.hs
Applicative instance: 


instance Applicative ObserverM where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad ObserverM where
        return a = ObserverM (\ c i -> (a,i))
        fn >>= k = ObserverM (\ c i ->
                case runMO fn c i of
                  (r,i2) -> runMO (k r) c i2
                )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/xmonad-0.9.2/XMonad/Core.hs
Applicative instance: 

#endif

instance Applicative X where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hspread-0.3.3/Spread/Client/Message.hs
Monad instance: 


instance (Functor m, Monad m) => Monad (Ask p m) where
    return = Result
    Ask i m >>= f = Ask i (fmap (>>= f) m)
    Result a >>= f = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sized-types-0.5.1/Data/Sized/Sparse/Matrix.hs
Applicative instance: 


instance (Bounded i, Ix i) => Applicative (SpMatrix i) where
    pure a =  SpMatrix a (Map.empty)
    sm1@(SpMatrix d1 m1) <*> sm2@(SpMatrix d2 m2)
            = SpMatrix (d1 d2) (Map.fromList [ (k, (getElem sm1  k) (getElem sm2 k)) | k <- Set.toList keys ])
        where keys = Map.keysSet m1 `Set.union` Map.keysSet m2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sized-types-0.5.1/Data/Sized/Matrix.hs
Applicative instance: 


instance (Bounded i, Ix i) => Applicative (Matrix i) where
    pure a = fmap (const a) coord   -- possible because we are a fixed size
                                    -- Also why use use newtype here.
    a <*> b = forAll $ \ i -> (a ! i) (b ! i)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/set-cover-0.0.8/src/Math/SetCover/Cuboid.hs
Applicative instance: 


instance Applicative Coords where
   pure x = Coords x x x
   Coords fx fy fz <*> Coords x y z = Coords (fx x) (fy y) (fz z)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/keys-3.11/src/Data/Key.hs
Applicative instance: 


instance Applicative (StateL s) where
  pure x = StateL (\ s -> (s, x))
  StateL kf <*> StateL kv = StateL $ \ s ->
    let (s', f) = kf s
        (s'', v) = kv s'
    in  (s'', f v)
Applicative instance: 


instance Applicative (StateR s) where
  pure x = StateR (\ s -> (s, x))
  StateR kf <*> StateR kv = StateR $ \ s ->
    let (s', v) = kv s
        (s'', f) = kf s'
    in (s'', f v)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/jmacro-rpc-0.3.2/Network/JMacroRPC/Panels.hs
Applicative instance: 


instance Applicative (Signal Hask) where
    pure x = PureSig x
    (PureSig f) <*> x = fmap f x
    f <*> (PureSig y) = fmap ($ y) f
    f <*> x = MultiSig f x (uncurry ($))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Cabal-ide-backend-1.23.0.0/Distribution/Compat/ReadP.hs
Applicative instance: 


instance Applicative (P s) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad (P s) where
  return x = Result x Fail

  (Get f)      >>= k = Get (\c -> f c >>= k)
  (Look f)     >>= k = Look (\s -> f s >>= k)
  Fail         >>= _ = Fail
  (Result x p) >>= k = k x `mplus` (p >>= k)
  (Final r)    >>= k = final [ys' | (x,s) <- r, ys' <- run (k x) s]

  fail _ = Fail
Applicative instance: 


instance Applicative (Parser r s) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad (Parser r s) where
  return x  = R (\k -> k x)
  fail _    = R (\_ -> Fail)
  R m >>= f = R (\k -> m (\a -> let R m' = f a in m' k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Cabal-ide-backend-1.23.0.0/Distribution/Simple/BuildTarget.hs
Applicative instance: 


instance Applicative Match where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Match where
  return a                = ExactMatch 0 [a]
  NoMatch      d ms >>= _ = NoMatch d ms
  ExactMatch   d xs >>= f = addDepth d
                          $ foldr matchPlus matchZero (map f xs)
  InexactMatch d xs >>= f = addDepth d .  forceInexact
                          $ foldr matchPlus matchZero (map f xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Cabal-ide-backend-1.23.0.0/Distribution/PackageDescription/Parse.hs
Applicative instance: 


#if __GLASGOW_HASKELL__ >= 710
instance (Monad m) => Applicative (StT s m) where
#else
instance (Monad m, Functor m) => Applicative (StT s m) where
#endif
    pure = return
    (<*>) = ap
Monad instance: 



instance Monad m => Monad (StT s m) where
    return a = StT (\s -> return (a,s))
    StT f >>= g = StT $ \s -> do
                        (a,s') <- f s
                        runStT (g a) s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Cabal-ide-backend-1.23.0.0/Distribution/ParseUtils.hs
Applicative instance: 


instance Applicative ParseResult where
        pure = return
        (<*>) = ap
Monad instance: 



instance Monad ParseResult where
        return = ParseOk []
        ParseFailed err >>= _ = ParseFailed err
        ParseOk ws x >>= f = case f x of
                               ParseFailed err -> ParseFailed err
                               ParseOk ws' x' -> ParseOk (ws'++ws) x'
        fail s = ParseFailed (FromString s Nothing)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HaskellForMaths-0.4.8/Math/Algebras/VectorSpace.hs
Applicative instance: 

-- Note that if f is not order-preserving, then we need to call "nf" afterwards

-- From GHC 7.10, Monad has Applicative as a superclass, so we must define an instance.
-- It doesn't particularly make sense for Vect k.
-- (Although given Vect k b, we could represent the dual space as Vect k (b -> ()),
-- and then have a use for <*>.)
instance Num k => Applicative (Vect k) where
    pure = return
    -- pure b = V [(b,1)]
    (<*>) = ap
Monad instance: 

    -- V fs <*> V xs = V [(f x, a*b) | (f,a) <- fs, (x,b) <- xs]

-- |Given a field k, the type constructor (Vect k) is a monad, the \"free k-vector space monad\".
--
-- In order to understand this, it is probably easiest to think of a free k-vector space as a kind of container,
-- a bit like a list, except that order doesn't matter, and you're allowed arbitrary (even negative or fractional)
-- quantities of the basis elements in the container.
--
-- According to this way of thinking, return is the function that puts a basis element into the vector space (container).
--
-- Given a function f from the basis of one vector space to another vector space (a -> Vect k b),
-- bind (>>=) lifts it to a function (>>= f) from the first vector space to the second (Vect k a -> Vect k b).
--
-- Note that in general (>>= f) applied to a vector will not return a result in normal form,
-- so it is usually preferable to use (linear f) instead.
instance Num k => Monad (Vect k) where
    return a = V [(a,1)]
    V ts >>= f = V $ concat [ [(b,y*x) | let V us = f a, (b,y) <- us] | (a,x) <- ts]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/interleave-1.0/Control/Alternative/Interleave.hs
Applicative instance: 


instance Alternative f => Applicative (InterleaveT f) where
  pure = NoMore
  (<*>) a b = uncurry ($) <$> (a `alongside` b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/marxup-3.0.0.1/MarXup/Text.hs
Monad instance: 


instance Monad Text where
  (>>=) = (:>>=)
  return = Return
Applicative instance: 


instance Applicative Text where
  (<*>) = ap
  pure = Return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/marxup-3.0.0.1/MarXup/Verbatim.hs
Monad instance: 


instance Monad Verbatim where
    return x = Verbatim "" x
    (Verbatim s0 x) >>= f =
        Verbatim (s0 ++ s1) y
        where Verbatim s1 y = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/shortcut-links-0.4.2.0/src/ShortcutLinks/All.hs
Applicative instance: 


instance Applicative Result where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Result where
  fail = Failure
  return = Success
  Failure x    >>= _ = Failure x
  Warning wa a >>= f = case f a of
    Success    b -> Warning wa b
    Warning wb b -> Warning (wa ++ wb) b
    Failure x    -> Failure x
  Success    a >>= f = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ginsu-0.8.2.2/CacheIO.hs
Applicative instance: 


instance Applicative CacheIO where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad CacheIO where
    {-# INLINE (>>=) #-}
    {-# INLINE return #-}
    CacheIO a >>= b = CacheIO $ a >>= \(x,cv) -> unCacheIO (b x) >>= \(y,cv') -> return  (y,cv ++ cv')
    return a = CacheIO (return (a, []))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ginsu-0.8.2.2/Boolean/Boolean.hs
Applicative instance: 


instance Applicative Boolean where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad Boolean where
    --a >> b = a && b
    a >>= f = dropBoolean (fmap f a)
    return x = BoolJust x
    fail _ = false
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ginsu-0.8.2.2/Text/ParserCombinators/ReadP/ByteString.hs
Applicative instance: 


-- Applicative

instance Applicative P where
  pure = return
  (<*>) = ap
Monad instance: 


-- Monad, MonadPlus

instance Monad (P) where
  return x = Result x Fail

  (Skip n f)   >>= k = Skip n (f >>= k)
  (Look f)     >>= k = Look (\s -> f s >>= k)
  Fail         >>= _ = Fail
  (Result x p) >>= k = k x `mplus` (p >>= k)
  (Final r)    >>= k = final [ys' | (x,s) <- r, ys' <- run (k x) s]

  fail _ = Fail
Applicative instance: 


instance Applicative (ReadP) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad (ReadP) where
  return x  = R (\k -> k x)
  fail _    = R (const Fail)
  R m >>= f = R (\k -> m (\a -> let R m' = f a in m' k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ginsu-0.8.2.2/SimpleParser.hs
Monad instance: 




instance Monad (GenParser c) where
    return a = MkP (\s -> (Just (a,s)))
    (MkP p) >>= q = MkP $ \s ->  (maybe Nothing (\(v,s') -> app (q v) s') (p s))
    fail _ = MkP $ \_ ->  Nothing
Applicative instance: 


instance Applicative (GenParser c) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/web-routes-0.27.9/Web/Routes/RouteT.hs
Applicative instance: 


instance (Applicative m) => Applicative (RouteT url m) where
  pure = liftRouteT . pure
  f <*> v = RouteT $ \ url -> unRouteT f url <*> unRouteT v url
Monad instance: 


instance (Monad m) => Monad (RouteT url m) where
    return   = liftRouteT . return
    m >>= k  = RouteT $ \ url -> do
        a <- unRouteT m url
        unRouteT (k a) url
    fail msg = liftRouteT (fail msg)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/weighted-search-0.1.0.1/Control/Monad/WeightedSearch.hs
Monad instance: 


instance (Weight w) => Monad (T w) where
    return x = Yield x Fail
    Fail >>= _ = Fail
    Yield x m >>= f = f x `mplus` (m >>= f)
    Weight w m >>= f = Weight w (m >>= f)
Applicative instance: 


instance (Weight w) => Applicative (T w) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/primula-bot-0.0.2/ApplicativeParsec.hs
Applicative instance: 


-- The Applicative instance for every Monad looks like this.
instance Applicative (GenParser s a) where
    pure  = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rand-vars-0.1/Control/Monad/Random.hs
Monad instance: 


instance Monad Rand where
    return x = Rand (\ g -> (x, g))
    r >>= f = Rand (\ g -> let (x, g') = r `runRand` g in f x `runRand` g')
Applicative instance: 


instance Applicative Rand where
    pure = return
    f <*> x = do
        h <- f
        a <- x
        return (h a)
Applicative instance: 


instance Applicative m => Applicative (RandT m) where
    pure x = RandT (\ g -> pure (x, g))
    f <*> x = RandT (\ g -> let (g', g'') = split g in
        fmap (\ (h, g3') x -> (h x, g3')) (f `runRandT` g') <*>
        fmap fst (x `runRandT` g''))
Monad instance: 


instance Monad m => Monad (RandT m) where
    return x = RandT (\ g -> return (x, g))
    r >>= f = RandT (runRandT r >=> (\ ( x, g) -> f x `runRandT` g))
    fail err = RandT (\ _ -> fail err)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/AC-MiniTest-1.1.1/Test/AC/Private.hs
Monad instance: 


instance Monad LogM where
  return x = LogM $ \ _ -> return x

  (LogM f1) >>= fn = LogM $ \ st -> do
    x <- f1 st
    let LogM f2 = fn x
    f2 st
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/AC-MiniTest-1.1.1/Test/AC/Label.hs
Monad instance: 


instance Monad c => Monad (Label1 c) where
  return x = Label1 {label1 = "return", value1 = return x}

  lc >>= f = lc {value1 = value1 lc >>= \ x -> let lc' = f x in value1 lc'}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/AC-MiniTest-1.1.1/Test/AC/Test.hs
Monad instance: 


instance Monad TestM where
  return = TestM . return

  (TestM m1) >>= f = TestM $ m1 >>= \ x -> let TestM m2 = f x in m2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ctpl-0.1.0.4/Text/CTPL0.hs
Monad instance: 


instance Monad Exec where
  return = Succ
  (Succ a) >>= f = f a
  Expired >>= f = Expired
  ConfViol >>= f = ConfViol
  SynViol >>= f = SynViol
Applicative instance: 


instance Applicative Exec where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad CTPL0 where
  return a = CTPL0 $ \i k -> Succ (a, k, i)
  m >>= f = CTPL0 $ \i k ->
    case runCTPL0 m i k of
      Succ (a, k', i') -> runCTPL0 (f a) i' k'
      Expired -> Expired
      ConfViol -> ConfViol
      SynViol -> SynViol
Applicative instance: 


instance Applicative CTPL0 where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ctpl-0.1.0.4/Text/CTPL0n.hs
Monad instance: 
 -- ^ Nope. See 'Fail' type.

instance Monad Exec where
  return = Succ
  fail = Fail . Dead
  (Succ a) >>= f = f a
  (Fail e) >>= f = Fail e
Applicative instance: 


instance Applicative Exec where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad (CTPL0 s) where
  return a = CTPL0 $ \i ref cfg -> return $ Succ (a,i)
  m >>= f = CTPL0 $ \i ref cfg -> do
    r <- runCTPL0 m i ref cfg
    case r of
      Succ (a, i') -> runCTPL0 (f a) i' ref cfg
      Fail f -> return $ Fail f
Applicative instance: 


instance Applicative (CTPL0 s) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ctpl-0.1.0.4/Text/CTPL.hs
Monad instance: 


instance Monad Exec where
  return a = Succ a
  (Succ a) >>= f = f a
  (NoSuchProc s) >>= f = NoSuchProc s
  SyntaxFault >>= f = SyntaxFault
Applicative instance: 


instance Applicative Exec where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad CTPL where
  return a = CTPL $ \s cfg -> return (a, s, id)
  m >>= f = CTPL $ \s cfg -> do
                           (a', s', f') <- runCTPL m s cfg
                           (a'', s'', f'') <- runCTPL (f a') s' cfg
                           return (a'', s'', f' . f'')
Applicative instance: 


instance Applicative CTPL where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/deiko-config-0.5.0.0/Data/Config/Internal/DkM.hs
Applicative instance: 


--------------------------------------------------------------------------------
instance Applicative (DkM e s) where
    pure  = return
    (<*>) = ap
Monad instance: 


--------------------------------------------------------------------------------
instance Monad (DkM e s) where
    return a = DkM $ \_ s -> return (a, s)

    DkM k >>= f
        = DkM $ \e s -> do
            (a, !s') <- k e s
            runDkM (f a) e s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/helium-1.8.1/src/Helium/Parser/LexerMonad.hs
Monad instance: 


instance Monad LexerMonad where
    (>>=) = bindLM
    return = returnLM
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/freer-0.2.3.0/src/Control/Monad/Freer/Internal.hs
Applicative instance: 


instance Applicative (Eff r) where
  {-# INLINE pure #-}
  {-# INLINE (<*>) #-}
  pure = Val
  Val f <*> Val x = Val $ f x
  Val f <*> E u q = E u (q |> (Val . f))
  E u q <*> Val x = E u (q |> (Val . ($ x)))
  E u q <*> m     = E u (q |> (`fmap` m))
Monad instance: 


instance Monad (Eff r) where
  {-# INLINE return #-}
  {-# INLINE (>>=) #-}
  return = Val
  Val x >>= k = k x
  E u q >>= k = E u (q |> k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chell-0.4.0.1/lib/Test/Chell.hs
Applicative instance: 


instance Control.Applicative.Applicative Assertions where
        pure = return
        (<*>) = ap
Monad instance: 


instance Monad Assertions where
        return x = Assertions (\s -> return (Just x, s))
        m >>= f = Assertions (\s -> do
                (maybe_a, s') <- unAssertions m s
                case maybe_a of
                        Nothing -> return (Nothing, s')
                        Just a -> unAssertions (f a) s')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/testing-feat-0.4.0.3/Test/Feat/Enumerate.hs
Applicative instance: 


-- | Pure is 'singleton' and '<*>' corresponds to cartesian product (as with lists)
instance Applicative Enumerate where
  pure     = singleton
  f <*> a  = fmap (uncurry ($)) (cartesian f a)
Applicative instance: 


instance Applicative Finite where
  pure = finPure
  a <*> b = fmap (uncurry ($)) (finCart a b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/LTree-0.1/Control/Trees/LTreeT.hs
Monad instance: 


instance Monad m => Monad (TreeT m) where
    return c =  TreeT $ return $ Leaf c
    tmb_v >>= f = TreeT $ runTreeT tmb_v >>= onone f
               where onone f (Node b_ets) = do
                       ets_ <- mapM (onone f) b_ets
                       return $ Node ets_
                     onone f (Leaf x) = runTreeT $ f x
Applicative instance: 


instance Applicative m => Applicative (TreeT m)where
   pure = treeT0 . pure . pure
   (<*>) = treeT2 . liftA2 . liftA2 $ id
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/LTree-0.1/Data/Trees/LTree.hs
Applicative instance: 


instance Applicative Tree where
    pure c = Leaf c
    Node l <*> t = Node (map (<*> t) l)
    Leaf c <*> Node l = Node (map (c <$>) l)
    Leaf c <*> Leaf c' = Leaf (c c')
Monad instance: 


instance Monad Tree where
    return x = Leaf x
    Node l >>= f = Node (map (>>= f) l)
    Leaf c >>= f = f c
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hs-watchman-0.0.0.3/src/System/Directory/Watchman/BSER/Parser.hs
Monad instance: 


instance Monad Parser where
    m >>= g = Parser $ \kf ks -> let ks' a = runParser (g a) kf ks
                                 in runParser m kf ks'
    {-# INLINE (>>=) #-}
    return a = Parser $ \_kf ks -> ks a
    {-# INLINE return #-}
    fail msg = Parser $ \kf _ks -> kf msg
    {-# INLINE fail #-}
Applicative instance: 


instance Applicative Parser where
    pure  = return
    {-# INLINE pure #-}
    (<*>) = apP
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SG-1.0/Data/SG/Vector/Basic.hs
Applicative instance: 


instance Applicative Pair where
  pure a = Pair (a, a)
  (<*>) (Pair (fa, fb)) (Pair (a, b)) = Pair (fa a, fb b)
Applicative instance: 


instance Applicative Triple where
  pure a = Triple (a, a, a)
  (<*>) (Triple (fa, fb, fc)) (Triple (a, b, c)) = Triple (fa a, fb b, fc c)
Applicative instance: 


instance Applicative Quad where
  pure a = Quad (a, a, a, a)
  (<*>) (Quad (fa, fb, fc, fd)) (Quad (a, b, c, d))
    = Quad (fa a, fb b, fc c, fd d)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SG-1.0/Data/SG/Geometry/ThreeDim.hs
Applicative instance: 


instance Applicative Point3' where
  pure a = Point3 (a, a, a)
  (<*>) (Point3 (fa, fb, fc)) (Point3 (a, b, c)) = Point3 (fa a, fb b, fc c)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SG-1.0/Data/SG/Geometry/TwoDim.hs
Applicative instance: 


instance Applicative Point2' where
  pure a = Point2 (a, a)
  (<*>) (Point2 (fa, fb)) (Point2 (a, b)) = Point2 (fa a, fb b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SG-1.0/Data/SG/Matrix.hs
Applicative instance: 


instance Applicative c => Applicative (SquareMatrix c) where
  pure = SquareMatrix . pure . pure
  (SquareMatrix f) <*> (SquareMatrix m) = SquareMatrix $ (fmap (<*>) f) <*> m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/inc-ref-0.3.0.0/src/Control/Concurrent/IncRef.hs
Applicative instance: 


instance Applicative IncRef where
  pure x = IncRef retry (return x) (return (pure x))
  f <*> x
     =  IncRef
     (cache f <*> cache x)
     (do
          e <- (Left . F <$> stream f) <|> (Right . X <$> stream x)
          case e of
            Left  (F f') -> f'     <$> cache x
            Right (X x') -> ($ x') <$> cache f
      )
    $ (do
         f' <- dup f
         x' <- dup x
         return $ f' <*> x'
      )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chalkboard-1.9.0.16/Graphics/ChalkBoard/OpenGL/Monad.hs
Monad instance: 



instance Monad CBM where
    return n = CBM $ \_ -> return n
    m >>= k = CBM $ \env -> do
        a <- runCBM m env
        a' <- runCBM (k a) env
        return a'
    fail msg = CBM $ \_ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/scat-1.1.0.2/src/Scat/Builder.hs
Applicative instance: 


instance Applicative Builder where
    pure x = Builder (\ n -> (n, x))
    f <*> x = Builder $ \ n ->
        let (n', g) = runBuilder f n
        in g <$> runBuilder x n'
Monad instance: 


instance Monad Builder where
    return = pure
    x >>= f = Builder $ \ n ->
        let (n', v) = runBuilder x n
        in runBuilder (f v) n'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monadacme-0.0.2/src/Control/Monad/Acme.hs
Applicative instance: 


instance Applicative Acme where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Acme where
  return = Acme
  Acme x >>= f = f x
  fail = return . unsafeCoerce
Applicative instance: 


instance (Applicative m) => Applicative (AcmeT m) where
  pure = AcmeT . pure
  a <*> b = AcmeT $ runAcmeT a <*> runAcmeT b
Monad instance: 


instance (Monad m) => Monad (AcmeT m) where
  return = AcmeT . return
  AcmeT m >>= f = AcmeT $ m >>= runAcmeT . f
  fail = return . unsafeCoerce
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/manifolds-0.2.2.0/Data/Manifold/TreeCover.hs
Applicative instance: 

instance Hask.Applicative Hourglass where
  pure x = Hourglass x x
  Hourglass f g <*> Hourglass x y = Hourglass (f x) (g y)
Applicative instance: 

instance (Hask.Applicative f) => Hask.Applicative (OuterMaybeT f) where
  pure = OuterJust . pure
  OuterJust fs <*> OuterJust xs = OuterJust $ fs <*> xs
  _ <*> _ = OuterNothing
Applicative instance: 


instance (AdditiveGroup x) => Hask.Applicative (WithAny x) where
  pure x = WithAny x zeroV
  WithAny f x <*> WithAny t ξ = WithAny (f t) (x^+^ξ)
Monad instance: 


instance (AdditiveGroup x) => Hask.Monad (WithAny x) where
  return x = WithAny x zeroV
  WithAny y x >>= f = WithAny r $ x^+^q
   where WithAny r q = f y
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/manifolds-0.2.2.0/Data/CoNat.hs
Applicative instance: 


instance (KnownNat n) => Hask.Applicative (FreeVect n) where
  pure = replicVector
  (<*>) = perfectZipWith ($)
Applicative instance: 

instance (Monoidal f (->) (->)) => Hask.Applicative (AsHaskFunctor f) where
  pure x = fmap (const x) . AsHaskFunctor $ pureUnit ()
  AsHaskFunctor fs <*> AsHaskFunctor xs = AsHaskFunctor . fmap (uncurry ($)) $ fzip (fs, xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/manifolds-0.2.2.0/Data/SimplicialComplex.hs
Applicative instance: 

instance (Hask.Functor m, Monad m (->))
             => Hask.Applicative (TriangT t n x m) where
  pure x = TriangT $ pure . (x,)
  TriangT fs <*> TriangT xs = TriangT $
      fs >=> \(f, t') -> fmap (first f) $ xs t'
Monad instance: 

instance (Hask.Functor m, Monad m (->)) => Hask.Monad (TriangT t n x m) where
  return x = TriangT $ pure . (x,)
  TriangT xs >>= f = TriangT $
      \t -> xs t >>= \(y,t') -> let (TriangT zs) = f y in zs t'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Tensor-1.1.0.1/src/Data/Tensor.hs
Applicative instance: 


instance Applicative Vertex1 where
   pure a = Vertex1 a
   Vertex1 f <*> Vertex1 x = Vertex1 (f x)
Applicative instance: 


instance Applicative Vertex2 where
   pure a = Vertex2 a a
   Vertex2 f g <*> Vertex2 x y = Vertex2 (f x) (g y)
Applicative instance: 


instance Applicative Vertex3 where
   pure a = Vertex3 a a a
   Vertex3 f g h <*> Vertex3 x y z = Vertex3 (f x) (g y) (h z)
Applicative instance: 


instance Applicative Vertex4 where
   pure a = Vertex4 a a a a
   Vertex4 f g h i <*> Vertex4 x y z w = Vertex4 (f x) (g y) (h z) (i w)
Applicative instance: 


instance Applicative Vector1 where
   pure a = Vector1 a
   Vector1 f <*> Vector1 x = Vector1 (f x)
Applicative instance: 


instance Applicative Vector2 where
   pure a = Vector2 a a
   Vector2 f g <*> Vector2 x y = Vector2 (f x) (g y)
Applicative instance: 


instance Applicative Vector3 where
   pure a = Vector3 a a a
   Vector3 f g h <*> Vector3 x y z = Vector3 (f x) (g y) (h z)
Applicative instance: 


instance Applicative Vector4 where
   pure a = Vector4 a a a a
   Vector4 f g h i <*> Vector4 x y z w = Vector4 (f x) (g y) (h z) (i w)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/DrIFT-cabalized-2.3.0/src/ParseLib2.hs
Monad instance: 


instance Monad Parser where
   -- return      :: a -> Parser a
   return v        = P (\pos inp -> [(v,inp)])

   -- >>=         :: Parser a -> (a -> Parser b) -> Parser b
   (P p) >>= f     = P (\pos inp -> concat [papply (f v) pos out
                                                | (v,out) <- p pos inp])
   fail s          = P (\pos inp -> [])
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskell-neo4j-client-0.3.2.2/src/Database/Neo4j/Types.hs
Monad instance: 


instance Monad Neo4j where
    return x = Neo4j (const (return x))
    (Neo4j cmd) >>= f = Neo4j $ \con -> do
                            a <- cmd con
                            runNeo4j (f a) con
Applicative instance: 


instance Applicative Neo4j where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-functors-0.6.5/src/Data/Functor/Cofree.hs
Applicative instance: 


instance (ForallF c Identity, ForallF c (Cofree c), ForallF c (Compose (Cofree c) (Cofree c)))
  => Applicative (Cofree c) where
  pure = leftAdjunctF runIdentity . Identity
  (<*>) = ap
Monad instance: 


instance (ForallF c Identity, ForallF c (Cofree c), ForallF c (Compose (Cofree c) (Cofree c)))
  => Monad (Cofree c) where
  return = pure
  m >>= g = leftAdjunctF (extract . extract . getCompose) (Compose $ fmap g m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-functors-0.6.5/src/Data/Functor/HFree.hs
Applicative instance: 


instance Applicative (HFree Monad f) where
  pure = return
  (<*>) = ap
Monad instance: 


-- | The free monad of a functor.
instance Monad (HFree Monad f) where
  return a = HFree $ const (return a)
  HFree f >>= g = HFree $ \k -> f k >>= (rightAdjunct k . g)
Applicative instance: 

-- HFree Monad is only a monad transformer if rightAdjunct is called with monad morphisms.
-- F.e. lift . return == return fails if the results are inspected with rightAdjunct (const Nothing).
-- instance MonadTrans (HFree Monad) where
--   lift = liftFree

instance Applicative (HFree Applicative f) where
  pure a = HFree $ const (pure a)
  HFree f <*> HFree g = HFree $ \k -> f k <*> g k
Applicative instance: 


instance Applicative (HFree Alternative f) where
  pure a = HFree $ const (pure a)
  HFree f <*> HFree g = HFree $ \k -> f k <*> g k
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-functors-0.6.5/src/Data/Functor/Free.hs
Applicative instance: 


instance Applicative (Free c) where
  pure = unit
  fs <*> as = transform (\k f -> rightAdjunct (k . f) as) fs
Monad instance: 


instance Monad (Free c) where
  return = unit
  as >>= f = transform (\k -> rightAdjunct k . f) as
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lol-0.5.0.2/Crypto/Lol/Types/IZipVector.hs
Applicative instance: 


-- Zip-py 'Applicative' instance.
instance (Fact m) => Applicative (IZipVector m) where
  pure = repl
  (IZipVector f) <*> (IZipVector a) = IZipVector $ V.zipWith ($) f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lol-0.5.0.2/Crypto/Lol/Cyclotomic/Tensor/CTensor.hs
Applicative instance: 


instance Fact m => Applicative (CT m) where
  pure = ZV . pure

  (ZV f) <*> (ZV a) = ZV (f <*> a)
  f@(ZV _) <*> v@(CT _) = f <*> toZV v
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lol-0.5.0.2/Crypto/Lol/Cyclotomic/Tensor/RepaTensor.hs
Applicative instance: 


instance Fact m => Applicative (RT m) where
  pure = ZV . pure

  -- RT can never hold an a -> b
  (ZV f) <*> (ZV a) = ZV (f <*> a)
  f@(ZV _) <*> v@(RT _) = f <*> toZV v
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lol-0.5.0.2/Crypto/Lol/Cyclotomic/UCyc.hs
Applicative instance: 


-- CJP: no Functor instance for C, because CRTrans for a doesn't imply
-- it for b.

instance (Tensor t, Fact m) => Applicative (UCyc t m P) where
  pure = Pow . pure \\ proxy entailIndexT (Proxy::Proxy (t m r))
  (Pow f) <*> (Pow v) = Pow $ f <*> v \\ witness entailIndexT v

  {-# INLINABLE pure #-}
  {-# INLINABLE (<*>) #-}
Applicative instance: 


instance (Tensor t, Fact m) => Applicative (UCyc t m D) where
  pure = Dec . pure \\ proxy entailIndexT (Proxy::Proxy (t m r))
  (Dec f) <*> (Dec v) = Dec $ f <*> v \\ witness entailIndexT v

  {-# INLINABLE pure #-}
  {-# INLINABLE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tfp-1.0.0.2/src/Type/Base/Proxy.hs
Applicative instance: 


instance Applicative Proxy where
   pure _ = Proxy
   Proxy <*> Proxy = Proxy
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/timeout-with-results-0.2/src/System/Timeout/Returning/Writer.hs
Applicative instance: 

instance Applicative (TimeoutWriter w) where
    pure  = return
    (<*>) = ap
Monad instance: 

instance Monad (TimeoutWriter w) where
    return = TimeoutWriter . return
    (TimeoutWriter v) >>= f = TimeoutWriter (v >>= (getTimeoutWriter . f))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/timeout-with-results-0.2/src/System/Timeout/Returning.hs
Applicative instance: 

instance Applicative (Timeout w) where
    pure  = return
    (<*>) = ap
Monad instance: 

instance Monad (Timeout w) where
    return = Timeout . return
    (Timeout v) >>= f = Timeout (v >>= (getTimeout . f))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gore-and-ash-1.2.1.0/src/Control/Wire/Session.hs
Applicative instance: 


instance (Applicative m) => Applicative (Session m) where
    pure x = let s = Session (pure (x, s)) in s

    Session ff <*> Session fx =
        Session $ liftA2 (\(f, sf) (x, sx) -> (f x, sf <*> sx)) ff fx
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gore-and-ash-1.2.1.0/src/Game/GoreAndAsh/Core/Monad.hs
Applicative instance: 


-- | Monad is needed as StateT Applicative instance requires it
instance Monad m => Applicative (GameMonadT m) where
  pure a = GameMonadT $ pure a
  (GameMonadT f) <*> (GameMonadT m) = GameMonadT $ f <*> m
Monad instance: 


instance Monad m => Monad (GameMonadT m) where
  return = pure
  (GameMonadT ma) >>= f = GameMonadT $ do
    a <- ma
    runGameMonadT $ f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/simple-pipe-0.0.0.9/src/Data/Pipe.hs
Monad instance: 


instance Monad m => Monad (Pipe i o m) where
        Ready f o p >>= k = Ready f o $ p >>= k
        Need f n >>= k = Need f $ n >=> k
--	Done f r >>= k = Make (return ()) $ f >> return (k r)
        Done _ r >>= k = k r
        Make f m >>= k = Make f $ (>>= k) `liftM` m
        return = Done (return ())
Applicative instance: 


instance Monad m => Applicative (Pipe i o m) where
        pure = return
        (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-0.32.0.8/lib/Penny/Lincoln/Serial.hs
Applicative instance: 


instance Applicative GenSerial where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad GenSerial where
  return a = GenSerial $ \s -> (a, s)
  (GenSerial k) >>= f = GenSerial $ \s ->
    let (a, s') = k s
        GenSerial g = f a
    in g s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-0.32.0.8/lib/Penny/Cabin/Posts/Allocated.hs
Applicative instance: 


instance Applicative Fields where
  pure a = Fields a a
  ff <*> fa = Fields {
    payee = payee ff (payee fa)
    , account = account ff (account fa) }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-0.32.0.8/lib/Penny/Cabin/Posts/Fields.hs
Applicative instance: 


instance Applicative Fields where
  pure a = Fields {
    globalTransaction = a
    , revGlobalTransaction = a
    , globalPosting = a
    , revGlobalPosting = a
    , fileTransaction = a
    , revFileTransaction = a
    , filePosting = a
    , revFilePosting = a
    , filtered = a
    , revFiltered = a
    , sorted = a
    , revSorted = a
    , visible = a
    , revVisible = a
    , lineNum = a
    , date = a
    , flag = a
    , number = a
    , payee = a
    , account = a
    , postingDrCr = a
    , postingCmdty = a
    , postingQty = a
    , totalDrCr = a
    , totalCmdty = a
    , totalQty = a
    , tags = a
    , memo = a
    , filename = a }

  ff <*> fa = Fields {
    globalTransaction = globalTransaction ff (globalTransaction fa)
    , revGlobalTransaction = revGlobalTransaction ff
                             (revGlobalTransaction fa)
    , globalPosting = globalPosting ff (globalPosting fa)
    , revGlobalPosting = revGlobalPosting ff (revGlobalPosting fa)
    , fileTransaction = fileTransaction ff (fileTransaction fa)
    , revFileTransaction = revFileTransaction ff (revFileTransaction fa)
    , filePosting = filePosting ff (filePosting fa)
    , revFilePosting = revFilePosting ff (revFilePosting fa)
    , filtered = filtered ff (filtered fa)
    , revFiltered = revFiltered ff (revFiltered fa)
    , sorted = sorted ff (sorted fa)
    , revSorted = revSorted ff (revSorted fa)
    , visible = visible ff (visible fa)
    , revVisible = revVisible ff (revVisible fa)
    , lineNum = lineNum ff (lineNum fa)
    , date = date ff (date fa)
    , flag = flag ff (flag fa)
    , number = number ff (number fa)
    , payee = payee ff (payee fa)
    , account = account ff (account fa)
    , postingDrCr = postingDrCr ff (postingDrCr fa)
    , postingCmdty = postingCmdty ff (postingCmdty fa)
    , postingQty = postingQty ff (postingQty fa)
    , totalDrCr = totalDrCr ff (totalDrCr fa)
    , totalCmdty = totalCmdty ff (totalCmdty fa)
    , totalQty = totalQty ff (totalQty fa)
    , tags = tags ff (tags fa)
    , memo = memo ff (memo fa)
    , filename = filename ff (filename fa) }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-0.32.0.8/lib/Penny/Cabin/Posts/BottomRows.hs
Applicative instance: 


instance Applicative Fields where
  pure a = Fields a a a
  ff <*> fa = Fields {
    tags = (tags ff) (tags fa)
    , memo = (memo ff) (memo fa)
    , filename = (filename ff) (filename fa)
    }
Applicative instance: 


instance Applicative TopRowCells where
  pure a = TopRowCells
    { globalTransaction    = a
    , revGlobalTransaction = a
    , globalPosting        = a
    , revGlobalPosting     = a
    , fileTransaction      = a
    , revFileTransaction   = a
    , filePosting          = a
    , revFilePosting       = a
    , filtered             = a
    , revFiltered          = a
    , sorted               = a
    , revSorted            = a
    , visible              = a
    , revVisible           = a
    , lineNum              = a
    , date                 = a
    , flag                 = a
    , number               = a
    , payee                = a
    , account              = a
    , postingDrCr          = a
    , postingCmdty         = a
    , postingQty           = a
    , totalDrCr            = a
    , totalCmdty           = a
    , totalQty             = a }

  ff <*> fa = TopRowCells
    { globalTransaction    = globalTransaction    ff (globalTransaction    fa)
    , revGlobalTransaction = revGlobalTransaction ff (revGlobalTransaction fa)
    , globalPosting        = globalPosting        ff (globalPosting        fa)
    , revGlobalPosting     = revGlobalPosting     ff (revGlobalPosting     fa)
    , fileTransaction      = fileTransaction      ff (fileTransaction      fa)
    , revFileTransaction   = revFileTransaction   ff (revFileTransaction   fa)
    , filePosting          = filePosting          ff (filePosting          fa)
    , revFilePosting       = revFilePosting       ff (revFilePosting       fa)
    , filtered             = filtered             ff (filtered             fa)
    , revFiltered          = revFiltered          ff (revFiltered          fa)
    , sorted               = sorted               ff (sorted               fa)
    , revSorted            = revSorted            ff (revSorted            fa)
    , visible              = visible              ff (visible              fa)
    , revVisible           = revVisible           ff (revVisible           fa)
    , lineNum              = lineNum              ff (lineNum              fa)
    , date                 = date                 ff (date                 fa)
    , flag                 = flag                 ff (flag                 fa)
    , number               = number               ff (number               fa)
    , payee                = payee                ff (payee                fa)
    , account              = account              ff (account              fa)
    , postingDrCr          = postingDrCr          ff (postingDrCr          fa)
    , postingCmdty         = postingCmdty         ff (postingCmdty         fa)
    , postingQty           = postingQty           ff (postingQty           fa)
    , totalDrCr            = totalDrCr            ff (totalDrCr            fa)
    , totalCmdty           = totalCmdty           ff (totalCmdty           fa)
    , totalQty             = totalQty             ff (totalQty             fa) }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-0.32.0.8/lib/Penny/Cabin/Posts/Growers.hs
Applicative instance: 


instance Applicative Fields where
  pure a = Fields
    { globalTransaction     = a
    , revGlobalTransaction = a
    , globalPosting        = a
    , revGlobalPosting     = a
    , fileTransaction      = a
    , revFileTransaction   = a
    , filePosting          = a
    , revFilePosting       = a
    , filtered             = a
    , revFiltered          = a
    , sorted               = a
    , revSorted            = a
    , visible              = a
    , revVisible           = a
    , lineNum              = a
    , date                 = a
    , flag                 = a
    , number               = a
    , postingDrCr          = a
    , postingCmdty         = a
    , postingQty           = a
    , totalDrCr            = a
    , totalCmdty           = a
    , totalQty             = a }

  fl <*> fa = Fields
    { globalTransaction    = globalTransaction    fl (globalTransaction    fa)
    , revGlobalTransaction = revGlobalTransaction fl (revGlobalTransaction fa)
    , globalPosting        = globalPosting        fl (globalPosting        fa)
    , revGlobalPosting     = revGlobalPosting     fl (revGlobalPosting     fa)
    , fileTransaction      = fileTransaction      fl (fileTransaction      fa)
    , revFileTransaction   = revFileTransaction   fl (revFileTransaction   fa)
    , filePosting          = filePosting          fl (filePosting          fa)
    , revFilePosting       = revFilePosting       fl (revFilePosting       fa)
    , filtered             = filtered             fl (filtered             fa)
    , revFiltered          = revFiltered          fl (revFiltered          fa)
    , sorted               = sorted               fl (sorted               fa)
    , revSorted            = revSorted            fl (revSorted            fa)
    , visible              = visible              fl (visible              fa)
    , revVisible           = revVisible           fl (revVisible           fa)
    , lineNum              = lineNum              fl (lineNum              fa)
    , date                 = date                 fl (date                 fa)
    , flag                 = flag                 fl (flag                 fa)
    , number               = number               fl (number               fa)
    , postingDrCr          = postingDrCr          fl (postingDrCr          fa)
    , postingCmdty         = postingCmdty         fl (postingCmdty         fa)
    , postingQty           = postingQty           fl (postingQty           fa)
    , totalDrCr            = totalDrCr            fl (totalDrCr            fa)
    , totalCmdty           = totalCmdty           fl (totalCmdty           fa)
    , totalQty             = totalQty             fl (totalQty             fa) }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-0.32.0.8/lib/Penny/Cabin/Balance/MultiCommodity/Chunker.hs
Applicative instance: 


instance Applicative Columns where
  pure a = Columns a a a a
  fn <*> fa = Columns {
    acct = (acct fn) (acct fa)
    , drCr = (drCr fn) (drCr fa)
    , commodity = (commodity fn) (commodity fa)
    , quantity = (quantity fn) (quantity fa)
     }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-0.32.0.8/lib/Penny/Cabin/Balance/Convert/ChunkerPct.hs
Applicative instance: 


instance Applicative Columns where
  pure a = Columns a a a
  fn <*> fa = Columns {
    acct = (acct fn) (acct fa)
    , drCr = (drCr fn) (drCr fa)
    , quantity = (quantity fn) (quantity fa)
     }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-0.32.0.8/lib/Penny/Cabin/Balance/Convert/Chunker.hs
Applicative instance: 


instance Applicative Columns where
  pure a = Columns a a a
  fn <*> fa = Columns {
    acct = (acct fn) (acct fa)
    , drCr = (drCr fn) (drCr fa)
    , quantity = (quantity fn) (quantity fa)
     }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tinytemplate-0.1.2.0/src/Data/Text/Template.hs
Applicative instance: 


instance Applicative Id where
  pure = Id
  (<*>) f x = Id $ runId f (runId x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/persistable-record-0.4.0.2/src/Database/Record/FromSql.hs
Monad instance: 


-- | 'Monad' instance like parser 'Monad'.
instance Monad (RecordFromSql q) where
  return a = createRecordFromSql ((,) a)
  ma >>= fmb =
    createRecordFromSql
    (\vals -> let (a, vals') = runTakeRecord ma vals
              in  runTakeRecord (fmb a) vals')
Applicative instance: 


-- | Derived 'Applicative' instance from 'Monad' instance
instance Applicative (RecordFromSql q) where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dunai-0.1.0.0/src/Data/MonadicStreamFunction.hs
Applicative instance: 


instance Applicative m => Applicative (MStreamF m r) where
  -- pure a = constantly a
  pure a = MStreamF $ \_ -> pure (a, pure a)
  {-
  fs <*> as = proc _ -> do
      f <- fs -< ()
      a <- as -< ()
      returnA -< f a
  -}
  fs <*> as = MStreamF $ \r -> applyTuple <$> unMStreamF fs r <*> unMStreamF as r
    where
      applyTuple (f, fs') (a, as') = (f a, fs' <*> as')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskell-rules-0.1.0.1/src/Language/Rules/NDSM.hs
Monad instance: 


instance Monad (NDSM s) where
        return x = NDSM (\s -> [(s,x)])
        (NDSM f) >>= c = NDSM (\s -> let svl = f s
                                         ml = map (\(_,x)->(unNDSM $ c x)) svl
                                         sl = map fst svl
                                         aml = zipWith ($) ml sl
                                     in concat aml)
Applicative instance: 


instance Applicative (NDSM s) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/acme-iot-0.1.0.1/src/Control/Monad/Trans/IO.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (IOT m) where
    pure x = IOT# $ \s# -> return $ IORet# (# s#, x #)
    IOT# ff <*> IOT# fx = IOT# $ \s# -> do
        IORet# (# s#, f #) <- ff s#
        IORet# (# s#, x #) <- fx s#
        return $ IORet# (# s#, f x #)
Monad instance: 


instance Monad m => Monad (IOT m) where
    return x = IOT# $ \s# -> return $ IORet# (# s#, x #)
    IOT# fx >>= ff = IOT# $ \s# -> do
        IORet# (# s#, x #) <- fx s#
        getIOT# (ff x) s#
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/coordinate-0.1.2/src/Data/Geodetic/EllipsoidReaderT.hs
Applicative instance: 


instance Applicative f => Applicative (EllipsoidReaderT f) where
  pure =
    EllipsoidReaderT . pure . pure
  EllipsoidReaderT f <*> EllipsoidReaderT a =
      EllipsoidReaderT (liftA2 (<*>) f a)
Monad instance: 


instance Monad f => Monad (EllipsoidReaderT f) where
  return =
    EllipsoidReaderT . return . return
  EllipsoidReaderT k >>= f =
    EllipsoidReaderT (\e -> k e >>= \q -> e & f q ^. _Wrapped')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-mersenne-random-0.1/Control/Monad/Mersenne/Random.hs
Monad instance: 


instance Monad Rand where

    {-# INLINE return #-}
    return a = Rand $ \s -> R a s

    {-# INLINE (>>=) #-}
    m >>= k  = Rand $ \s -> case runRand m s of
                                R a s' -> runRand (k a) s'

    {-# INLINE (>>) #-}
    m >>  k  = Rand $ \s -> case runRand m s of
                                R _ s' -> runRand k s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reasonable-operational-0.1.0.1/src/Control/Monad/Operational.hs
Applicative instance: 


instance Functor f => Applicative (Free f) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Functor f => Monad (Free f) where
  return = Pure
  Free x >>= f = Free $ fmap (>>= f) x
  Pure x >>= f = f x
Applicative instance: 


instance Applicative (Program f) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad (Program f) where
  return = Program . return
  x >>= f = Program $ toFree x >>= toFree . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/threepenny-gui-0.6.0.6/src/Reactive/Threepenny.hs
Applicative instance: 


instance Applicative Behavior where
    pure a  = B (Prim.pureL a) never
    ~(B lf ef) <*> ~(B lx ex) =
        B (Prim.applyL lf lx) (unionWith const ef ex)
Applicative instance: 


-- | The applicative instance combines 'rumors'
-- and uses 'facts' when some of the 'rumors' are not available.
instance Applicative Tidings where
    pure x  = T (pure x) never
    f <*> x = uncurry ($) <$> pair f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/threepenny-gui-0.6.0.6/src/Graphics/UI/Threepenny/Internal.hs
Applicative instance: 


instance Applicative UI where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad UI where
    return  = UI . return
    m >>= k = UI $ unUI m >>= unUI . k
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hask-0/src/Hask/Tensor/Compose.hs
Monad instance: 

instance (Functor m, Dom m ~ Cod m, Monoid (Compose (Dom m) (Dom m) (Dom m)) m, Identified (Dom m), Composed (Dom m)) => Monad m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrows-0.4.4.1/Control/Arrow/Transformer/State.hs
Applicative instance: 


instance Arrow a => Applicative (StateArrow s a b) where
        pure x = arr (const x)
        f <*> g = f &&& g >>> arr (uncurry id)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrows-0.4.4.1/Control/Arrow/Transformer/Error.hs
Applicative instance: 


instance ArrowChoice a => Applicative (ErrorArrow ex a b) where
        pure x = arr (const x)
        f <*> g = f &&& g >>> arr (uncurry id)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrows-0.4.4.1/Control/Arrow/Transformer/Writer.hs
Applicative instance: 


instance (Arrow a, Monoid w) => Applicative (WriterArrow w a b) where
        pure x = arr (const x)
        f <*> g = f &&& g >>> arr (uncurry id)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrows-0.4.4.1/Control/Arrow/Transformer/Reader.hs
Applicative instance: 


instance Arrow a => Applicative (ReaderArrow r a b) where
        pure x = arr (const x)
        f <*> g = f &&& g >>> arr (uncurry id)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrows-0.4.4.1/Control/Arrow/Transformer/Automaton.hs
Applicative instance: 


instance Arrow a => Applicative (Automaton a b) where
        pure x = arr (const x)
        f <*> g = f &&& g >>> arr (uncurry id)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrows-0.4.4.1/Control/Arrow/Transformer/Stream.hs
Applicative instance: 


instance Arrow a => Applicative (StreamArrow a b) where
        pure x = arr (const x)
        f <*> g = f &&& g >>> arr (uncurry id)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrows-0.4.4.1/Control/Arrow/Transformer/CoState.hs
Applicative instance: 


instance Arrow a => Applicative (CoStateArrow s a b) where
        pure x = arr (const x)
        f <*> g = f &&& g >>> arr (uncurry id)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrows-0.4.4.1/Control/Arrow/Transformer/Static.hs
Applicative instance: 


instance (Arrow a, Applicative f) => Applicative (StaticArrow f a b) where
        pure x = arr (const x)
        f <*> g = f &&& g >>> arr (uncurry id)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-reactive-1.0/Data/TimeVal.hs
Applicative instance: 

instance Applicative TimeVal
Monad instance: 

instance Monad TimeVal where
  join (Since b) = b
  join Always = Always
  join Never = Never
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-reactive-1.0/Data/Reactive.hs
Applicative instance: 

instance Ord t => Applicative (Reactive t) where
  Reactive f fs <*> Reactive x xs = Reactive (f x) (cons (pure f) fs<*>cons (pure x) xs)
Applicative instance: 

instance Ord t => Applicative (Event t) where
  fe@(yb i'event -> ff:-:_) <*> xe@(yb i'event -> fx:-:_) =
    ste & traverse (by state) & yb state & map snd & \st ->
    br (ff^.l'time + fx^.l'time) (st (ff^.l'value,fx^.l'value))
    where ste = map (\f (_,x) -> ((f,x),f x)) fe
              + map (\x (f,_) -> ((f,x),f x)) xe
          br t (yb i'event -> e) = (map (l'time %- t) b ++ a)^.i'event
            where (b,a) = span (\f -> f^.l'time<t) e
Monad instance: 


instance Ord t => Monad (Event t) where
  join m = m & (i'event %%~ merge . trace "merge" . map2 (trace "map2" . yb i'event . trace "map"))
    where
      merge (xs:-:ys:-:t) = trace "xi" (xi ++ merge ((ys&l'value%~add xe) :-: t) & l'1.l'time %~ (+tx))
        where add = warp2 i'event (+)
              (tx,~(xi,xe)) = xs^..i'future & l'2%~(break (ltFut ys).trace "break")
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lowgl-0.3.1.1/Graphics/GL/Low/Cube.hs
Applicative instance: 


instance Applicative Cube where
  pure x = Cube x x x x x x
  (Cube f1 f2 f3 f4 f5 f6) <*> (Cube x1 x2 x3 x4 x5 x6) =
    Cube (f1 x1) (f2 x2) (f3 x3) (f4 x4) (f5 x5) (f6 x6)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/XSaiga-1.1.0.0/AGParser2.hs
Applicative instance: 


instance Applicative StateM where
    pure  = return
    (<*>) = ap
Monad instance: 
  -- defined in Control.Monad

instance Monad StateM where
  -- defines state propagation
  State m            >>= k
         = State (\s -> let (a,y) = m s in unState (k a) y)
  return k             =  State (\s -> (k,s))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Pugs-6.2.13.9/src/Pugs/AST/Eval.hs
Monad instance: 


instance Monad Eval where
    return a = EvalT $ return (RNormal a)
    m >>= k = EvalT $ do
        a <- runEvalT m
        case a of
            RNormal x   -> runEvalT (k x)
            RException x-> return (RException x)
    fail str = do
        pos <- asks envPos'
        EvalT $ return (RException (errStrPos (cast str) pos))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Pugs-6.2.13.9/src/Pugs/AST/SIO.hs
Monad instance: 


instance Monad SIO where
    return a = MkSIO a
    (MkIO io)   >>= k = MkIO $ do { a <- io; runIO (k a) }
    (MkSTM stm) >>= k = MkSTM $ do { a <- stm; runSTM (k a) }
    (MkSIO x)   >>= k = k x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Pugs-6.2.13.9/src/Pugs/Monads.hs
Monad instance: 


instance (Monad m) => Monad (MaybeT m) where
    (MaybeT mon) >>= f =
        MaybeT (mon >>= maybe (return Nothing) (runMaybeT . f))
    return              = MaybeT . return . Just
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/broccoli-0.4.1.0/Control/Broccoli.hs
Applicative instance: 


instance Applicative X where
  pure x = PureX x
  f <*> x = ApplX f x
Monad instance: 


instance Monad Setup where
  return x = Setup (\_ -> return x)
  (Setup r) >>= f = Setup r' where
    r' mv = do
      x <- r mv
      let Setup r'' = f x
      r'' mv
Applicative instance: 


instance Applicative Setup where
  pure = return
  (<*>) = ap
Applicative instance: 


instance Applicative Promise where
  pure x = Promise (return x)
  ff <*> xx = Promise $ do
    f <- force ff
    x <- force xx
    return (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/http-kinder-0.2.0.0/src/Network/HTTP/Kinder/MediaType.hs
Applicative instance: 


instance Applicative (Ver n) where
  pure = Ver
  Ver f <*> Ver a = Ver (f a)
Monad instance: 


instance Monad (Ver n) where
  return = pure
  Ver x >>= f = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/http-kinder-0.2.0.0/src/Network/HTTP/Kinder/Query.hs
Applicative instance: 


instance Applicative QueryKeyState where
  pure = QueryKeyValued
  (<*>) = ap
Monad instance: 


-- | Monad instance equivalent to @Either Bool@
instance Monad QueryKeyState where
  return = pure
  m >>= f =
    case m of
      QueryKeyValued a -> f a
      QueryKeyPresent -> QueryKeyPresent
      QueryKeyAbsent -> QueryKeyAbsent
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Distribution/Client/Tar.hs
Monad instance: 


instance Monad Partial where
    return        = Ok
    Error m >>= _ = Error m
    Ok    x >>= k = k x
    fail          = Error
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Distribution/Client/Dependency/Types.hs
Monad instance: 


instance Monad (Progress step fail) where
  return a = Done a
  p >>= f  = foldProgress Step Fail f p
Applicative instance: 


instance Applicative (Progress step fail) where
  pure a  = Done a
  p <*> x = foldProgress Step Fail (flip fmap x) p
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Applicative/Backwards.hs
Applicative instance: 


-- | Apply @f@-actions in the reverse order.
instance (Applicative f) => Applicative (Backwards f) where
    pure a = Backwards (pure a)
    Backwards f <*> Backwards a = Backwards (a <**> f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Applicative/Lift.hs
Applicative instance: 


-- | A combination is 'Pure' only if both parts are.
instance (Applicative f) => Applicative (Lift f) where
    pure = Pure
    Pure f <*> Pure x = Pure (f x)
    Pure f <*> Other y = Other (f <$> y)
    Other f <*> Pure x = Other (($ x) <$> f)
    Other f <*> Other y = Other (f <*> y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/Cont.hs
Applicative instance: 


instance Applicative (ContT r m) where
    pure a  = ContT ($ a)
    f <*> v = ContT $ \ k -> runContT f $ \ g -> runContT v (k . g)
Monad instance: 


instance Monad (ContT r m) where
    return a = ContT ($ a)
    m >>= k  = ContT $ \c -> runContT m (\a -> runContT (k a) c)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/Identity.hs
Applicative instance: 


instance (Applicative m) => Applicative (IdentityT m) where
    pure x = IdentityT (pure x)
    (<*>) = lift2IdentityT (<*>)
Monad instance: 


instance (Monad m) => Monad (IdentityT m) where
    return = IdentityT . return
    m >>= k = IdentityT $ runIdentityT . k =<< runIdentityT m
    fail msg = IdentityT $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/State/Strict.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (StateT s m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance (Monad m) => Monad (StateT s m) where
    return a = state $ \s -> (a, s)
    m >>= k  = StateT $ \s -> do
        (a, s') <- runStateT m s
        runStateT (k a) s'
    fail str = StateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/State/Lazy.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (StateT s m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance (Monad m) => Monad (StateT s m) where
    return a = state $ \s -> (a, s)
    m >>= k  = StateT $ \s -> do
        ~(a, s') <- runStateT m s
        runStateT (k a) s'
    fail str = StateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/RWS/Strict.hs
Applicative instance: 


instance (Monoid w, Functor m, Monad m) => Applicative (RWST r w s m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance (Monoid w, Monad m) => Monad (RWST r w s m) where
    return a = RWST $ \_ s -> return (a, s, mempty)
    m >>= k  = RWST $ \r s -> do
        (a, s', w)  <- runRWST m r s
        (b, s'',w') <- runRWST (k a) r s'
        return (b, s'', w `mappend` w')
    fail msg = RWST $ \_ _ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/RWS/Lazy.hs
Applicative instance: 


instance (Monoid w, Functor m, Monad m) => Applicative (RWST r w s m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance (Monoid w, Monad m) => Monad (RWST r w s m) where
    return a = RWST $ \_ s -> return (a, s, mempty)
    m >>= k  = RWST $ \r s -> do
        ~(a, s', w)  <- runRWST m r s
        ~(b, s'',w') <- runRWST (k a) r s'
        return (b, s'', w `mappend` w')
    fail msg = RWST $ \_ _ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/Reader.hs
Applicative instance: 


instance (Applicative m) => Applicative (ReaderT r m) where
    pure    = liftReaderT . pure
    f <*> v = ReaderT $ \ r -> runReaderT f r <*> runReaderT v r
Monad instance: 


instance (Monad m) => Monad (ReaderT r m) where
    return   = lift . return
    m >>= k  = ReaderT $ \ r -> do
        a <- runReaderT m r
        runReaderT (k a) r
    fail msg = lift (fail msg)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/List.hs
Applicative instance: 


instance (Applicative m) => Applicative (ListT m) where
    pure a  = ListT $ pure [a]
    f <*> v = ListT $ (<*>) <$> runListT f <*> runListT v
Monad instance: 


instance (Monad m) => Monad (ListT m) where
    return a = ListT $ return [a]
    m >>= k  = ListT $ do
        a <- runListT m
        b <- mapM (runListT . k) a
        return (concat b)
    fail _ = ListT $ return []
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/Maybe.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (MaybeT m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance (Monad m) => Monad (MaybeT m) where
    fail _ = MaybeT (return Nothing)
    return = lift . return
    x >>= f = MaybeT $ do
        v <- runMaybeT x
        case v of
            Nothing -> return Nothing
            Just y  -> runMaybeT (f y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/Writer/Strict.hs
Applicative instance: 


instance (Monoid w, Applicative m) => Applicative (WriterT w m) where
    pure a  = WriterT $ pure (a, mempty)
    f <*> v = WriterT $ liftA2 k (runWriterT f) (runWriterT v)
      where k (a, w) (b, w') = (a b, w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (WriterT w m) where
    return a = WriterT $ return (a, mempty)
    m >>= k  = WriterT $ do
        (a, w)  <- runWriterT m
        (b, w') <- runWriterT (k a)
        return (b, w `mappend` w')
    fail msg = WriterT $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Control/Monad/Trans/Writer/Lazy.hs
Applicative instance: 


instance (Monoid w, Applicative m) => Applicative (WriterT w m) where
    pure a  = WriterT $ pure (a, mempty)
    f <*> v = WriterT $ liftA2 k (runWriterT f) (runWriterT v)
      where k ~(a, w) ~(b, w') = (a b, w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (WriterT w m) where
    return a = writer (a, mempty)
    m >>= k  = WriterT $ do
        ~(a, w)  <- runWriterT m
        ~(b, w') <- runWriterT (k a)
        return (b, w `mappend` w')
    fail msg = WriterT $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Data/Functor/Reverse.hs
Applicative instance: 


-- | Derived instance.
instance (Applicative f) => Applicative (Reverse f) where
    pure a = Reverse (pure a)
    Reverse f <*> Reverse a = Reverse (f <*> a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Data/Functor/Identity.hs
Applicative instance: 


instance Applicative Identity where
    pure a = Identity a
    Identity f <*> Identity x = Identity (f x)
Monad instance: 


instance Monad Identity where
    return a = Identity a
    m >>= k  = k (runIdentity m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Data/Functor/Compose.hs
Applicative instance: 


instance (Applicative f, Applicative g) => Applicative (Compose f g) where
    pure x = Compose (pure (pure x))
    Compose f <*> Compose x = Compose ((<*>) <$> f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Data/Functor/Product.hs
Applicative instance: 


instance (Applicative f, Applicative g) => Applicative (Product f g) where
    pure x = Pair (pure x) (pure x)
    Pair f g <*> Pair x y = Pair (f <*> x) (g <*> y)
Monad instance: 


instance (Monad f, Monad g) => Monad (Product f g) where
    return x = Pair (return x) (return x)
    Pair m n >>= f = Pair (m >>= fstP . f) (n >>= sndP . f)
      where
        fstP (Pair a _) = a
        sndP (Pair _ b) = b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-bundle-1.18.0.2.1/Data/Functor/Constant.hs
Applicative instance: 


instance (Monoid a) => Applicative (Constant a) where
    pure _ = Constant mempty
    Constant x <*> Constant y = Constant (x `mappend` y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/resource-simple-0.2/src/Control/Monad/Resource.hs
Applicative instance: 



------------------------------------------------------------------------------
instance Monad m => Applicative (ResourceT m) where
    pure = return
    (<*>) = ap
Monad instance: 



------------------------------------------------------------------------------
instance Monad m => Monad (ResourceT m) where
    return = ResourceT . const . return
    ResourceT m >>= f = ResourceT $ \r -> m r >>= \a ->
        let ResourceT m' = f a in m' r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sqlite-simple-0.4.9.0/Database/SQLite/Simple/Ok.hs
Applicative instance: 


instance Applicative Ok where
    pure = Ok

    Errors es <*> _ = Errors es
    _ <*> Errors es = Errors es
    Ok f <*> Ok a   = Ok (f a)
Monad instance: 


instance Monad Ok where
    return = Ok

    Errors es >>= _ = Errors es
    Ok a      >>= f = f a

    fail str = Errors [SomeException (ErrorCall str)]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/probability-0.2.5/src/Numeric/Probability/Distribution.hs
Monad instance: 


instance Num prob => Monad (T prob) where
  return   = certainly
  d >>= f  = Cons [(y,q*p) | (x,p) <- decons d, (y,q) <- decons (f x)]
  fail _   = Cons []
Applicative instance: 


instance Num prob => Applicative (T prob) where
  pure     = certainly
  fm <*> m = Cons [(f x,q*p) | (f,p) <- decons fm, (x,q) <- decons m]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/probability-0.2.5/src/Numeric/Probability/Either.hs
Applicative instance: 


instance Applicative m => Applicative (EitherT a m) where
   pure a = EitherT $ pure $ Right a
   EitherT af <*> EitherT am =
      EitherT $
      liftA2 (\ef em ->
         case ef of
            Left b -> Left b
            Right f ->
               case em of
                  Left b -> Left b
                  Right m -> Right $ f m) af am
Monad instance: 


instance Monad m => Monad (EitherT a m) where
   return a = EitherT $ return $ Right a
   EitherT m >>= f  =  EitherT $ do
      e <- m
      case e of
         Left b -> return $ Left b
         Right a ->
            case f a of
               EitherT n -> n
   fail s = EitherT $ fail s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/probability-0.2.5/src/Numeric/Probability/Random.hs
Monad instance: 


instance Monad T where
   return x = Cons (return x)
   Cons x >>= y =
      Cons (decons . y =<< x)
Applicative instance: 


instance Applicative T where
   pure x = Cons (pure x)
   fm <*> m = Cons (decons fm <*> decons m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/memory-0.9/Data/ByteArray/Pack/Internal.hs
Applicative instance: 


instance Applicative Packer where
    pure  = returnPacker
    (<*>) = appendPacker
Monad instance: 


instance Monad Packer where
    return = returnPacker
    (>>=)  = bindPacker
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/memory-0.9/Data/ByteArray/Parse.hs
Monad instance: 


instance Monad (Parser byteArray) where
    fail errorMsg = Parser $ \buf err _ -> err buf ("failed: " ++ errorMsg)
    return v = Parser $ \buf _ ok -> ok buf v
    m >>= k = Parser $ \buf err ok ->
         runParser m buf err (\buf' a -> runParser (k a) buf' err ok)
Applicative instance: 

instance Applicative (Parser byteArray) where
    pure      = return
    (<*>) d e = d >>= \b -> e >>= \a -> return (b a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hindley-milner-0.1.0.0/src/Language/HM/AlgorithmW.hs
Applicative instance: 


instance Applicative W where
    pure x = W $ \_ n -> return (x, n)

    (W m) <*> (W m') = W $ \ctx n -> do
        (f, n')  <- m ctx n
        (x, n'') <- m' ctx n'
        return (f x, n'')
Monad instance: 


instance Monad W where
    W m >>= f = W $ \ctx n -> do
        (r, n') <- m ctx n
        let W m' = f r in m' ctx n'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/nntp-0.0.4/src/Network/NNTP/Internal.hs
Applicative instance: 

instance (Functor m, Monad m) => Applicative (NntpT m) where
    pure = return
    (<*>) = ap
Monad instance: 

instance Monad m => Monad (NntpT m) where
    m >>= f  = NntpT $ \s -> do (s', v) <- runNntpT m s
                                case v of
                                  Left e -> return $! (s, Left e)
                                  Right a -> runNntpT (f a) s'
    return x = NntpT $ \s -> return $! (s, Right x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/packer-0.1.9/Data/Packer/Internal.hs
Monad instance: 


instance Monad Packing where
    return = returnPacking
    (>>=)  = bindPacking
Applicative instance: 


instance Applicative Packing where
    pure  = returnPacking
    (<*>) = apPacking
Monad instance: 


instance Monad Unpacking where
    return = returnUnpacking
    (>>=)  = bindUnpacking
Applicative instance: 


instance Applicative Unpacking where
    pure  = returnUnpacking
    (<*>) = apUnpacking
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/asn1-encoding-0.9.4/Data/ASN1/Get.hs
Applicative instance: 


instance Applicative Get where
    pure  = return
    (<*>) = ap
Monad instance: 


-- Definition directly from Control.Monad.State.Strict
instance Monad Get where
    return a = Get $ \ s0 b0 m0 p0 _ ks -> ks s0 b0 m0 p0 a

    m >>= g  = Get $ \s0 b0 m0 p0 kf ks ->
        let ks' s1 b1 m1 p1 a = unGet (g a) s1 b1 m1 p1 kf ks
         in unGet m s0 b0 m0 p0 kf ks'

    fail     = failDesc
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/polyseq-0.1.2.1/src/Language/Haskell/FreeTheorems/Variations/PolySeq/M.hs
Monad instance: 


instance Monad M where
    return a = M (\s -> [(a,s)])
    M m >>= k = M (\s -> concatMap (\(a,s') -> case k a of M l -> l s') (m s))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sneathlane-haste-2/SneathLane/Widget.hs
Applicative instance: 


instance (Functor f) => Applicative (Widget f) where
  pure = Finish

  (<*>) wf w = bindW (\fn -> bindW (Finish . fn) w) wf
Monad instance: 


instance (Functor f) => Monad (Widget f) where
  return = Finish

  (>>=) = flip bindW
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/generic-random-0.3.0.0/src/Generic/Random/Boltzmann.hs
Applicative instance: 


instance Num r => Applicative (ConstModule r) where
  pure _ = ConstModule 1
  ConstModule x <*> ConstModule y = ConstModule (x * y)
Applicative instance: 


instance MonadRandomLike m => Applicative (Weighted m) where
  pure a = Weighted [(1, pure a)]
  f' <*> a' = Weighted [(u * v, f <*> a)]
    where
      (u, f) = runWeighted f'
      (v, a) = runWeighted a'
Applicative instance: 


instance Module f => Applicative (Pointiful f) where
  pure a = Zero (pure a)
  Zero f <*> Zero x = Zero (f <*> x)
  Zero f <*> Pointiful xs = Pointiful (fmap (f <*>) xs)
  Pointiful fs <*> Zero x = Pointiful (fmap (<*> x) fs)
  Pointiful fs <*> Pointiful xs = Pointiful (convolute fs xs)
    where
      convolute fs xs = zipWith3 sumOfProducts [0 ..] (inits' fs) (inits' xs)
      inits' = tail . inits
      sumOfProducts k f x = asum (zipWith3 (times k) [0 ..] f (reverse x))
      times k k1 f x = fromInteger (binomial k k1) <.> f <*> x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/generic-random-0.3.0.0/src/Generic/Random/Internal/Types.hs
Applicative instance: 


instance Applicative (RejectT m) where
  pure a = RejectT $ \_maxSize size _retry cont ->
    cont size a
  RejectT f <*> RejectT x = RejectT $ \maxSize size retry cont ->
    f maxSize size retry $ \size f_ ->
      x maxSize size retry $ \size x_ ->
        cont size (f_ x_)
Monad instance: 


instance Monad (RejectT m) where
  RejectT x >>= f = RejectT $ \maxSize size retry cont ->
    x maxSize size retry $ \size x_ ->
      unRejectT (f x_) maxSize size retry cont
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/generic-random-0.3.0.0/src/Generic/Random/Internal/Generic.hs
Applicative instance: 


instance Applicative (Freq sized) where
  pure = Freq . pure . pure
  Freq f <*> Freq x = Freq (liftA2 (<*>) f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Adaptive-0.23/Control/Monad/Adaptive/OrderedList.hs
Monad instance: 


instance Ref m r => Monad (OrderedList m r a) where
  return a = inM (return a)
  (OL m) >>= f = OL $ \e -> m e >>= \a -> deOL (f a) e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Adaptive-0.23/Control/Monad/Adaptive.hs
Monad instance: 


instance Ref m r => Monad (Changeable m r) where
  return a   = Ch $ \k -> k a
  Ch m >>= f = Ch $ \k -> m $ \a -> deCh (f a) k
Monad instance: 


instance Ref m r => Monad (Adaptive m r) where
  return a   = Ad $ \e -> return a
  Ad m >>= f = Ad $ \e -> m e >>= \a -> deAd (f a) e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/Test/QuickCheck.hs
Applicative instance: 


instance Applicative QueryDenotation where
  pure    = QueryDenotation . pure . pure . pure
  f <*> x = QueryDenotation ((liftA2 . liftA2 . liftA2) ($)
                                (unQueryDenotation f) (unQueryDenotation x))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Constant.hs
Applicative instance: 


instance Applicative (Constant a) where
  pure = Constant . pure
  Constant f <*> Constant x = Constant (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/Distinct.hs
Applicative instance: 


instance Applicative (Distinctspec a) where
  pure = Distinctspec . pure
  Distinctspec f <*> Distinctspec x = Distinctspec (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/RunQuery.hs
Applicative instance: 


-- TODO: Seems like this one should be simpler!
instance Applicative (QueryRunner c) where
  pure = flip (QueryRunner (P.lmap (const ()) PP.empty)) (const False)
         . pure
         . pure
  QueryRunner uf rf bf <*> QueryRunner ux rx bx =
    QueryRunner (P.dimap (\x -> (x,x)) (const ()) (uf PP.***! ux)) ((<*>) <$> rf <*> rx) (liftA2 (||) bf bx)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/TableMaker.hs
Applicative instance: 


instance Applicative (ViewColumnMaker a) where
  pure = ViewColumnMaker . pure
  ViewColumnMaker f <*> ViewColumnMaker x = ViewColumnMaker (f <*> x)
Applicative instance: 


instance Applicative (ColumnMaker a) where
  pure = ColumnMaker . pure
  ColumnMaker f <*> ColumnMaker x = ColumnMaker (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/Values.hs
Applicative instance: 


instance Applicative (Valuesspec a) where
  pure = Valuesspec . pure
  Valuesspec f <*> Valuesspec x = Valuesspec (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/Aggregate.hs
Applicative instance: 


instance Applicative (Aggregator a) where
  pure = Aggregator . pure
  Aggregator f <*> Aggregator x = Aggregator (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/Unpackspec.hs
Applicative instance: 


instance Applicative (Unpackspec a) where
  pure = Unpackspec . pure
  Unpackspec f <*> Unpackspec x = Unpackspec (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/QueryArr.hs
Applicative instance: 


instance Applicative (QueryArr a) where
  pure = arr . const
  f <*> g = arr (uncurry ($)) <<< (f &&& g)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/PackMap.hs
Applicative instance: 


instance Applicative (PackMap a b s) where
  pure x = PackMap (pure (pure (pure x)))
  PackMap f <*> PackMap x = PackMap (liftA2 (liftA2 (<*>)) f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/Binary.hs
Applicative instance: 


instance Applicative (Binaryspec a) where
  pure = Binaryspec . pure
  Binaryspec f <*> Binaryspec x = Binaryspec (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-sqlite-0.0.1.0/src/Opaleye/SQLite/Internal/Table.hs
Applicative instance: 


instance Applicative (Writer a) where
  pure x = Writer (fmap (const ()) (pure x))
  Writer f <*> Writer x = Writer (liftA2 (\_ _ -> ()) f x)
Applicative instance: 


instance Applicative (TableProperties a) where
  pure x = TableProperties (pure x) (View x)
  TableProperties fw (View fv) <*> TableProperties xw (View xv) =
    TableProperties (fw <*> xw) (View (fv xv))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lazy-search-0.1.1.0/src/Control/Search.hs
Applicative instance: 


instance Applicative Minimal where
  pure a = Value (Unit a)
  sf <*> sa = fmap (uncurry ($)) (pair sf sa)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aeson-native-0.3.3.2/Data/Aeson/Types.hs
Monad instance: 


instance Monad Result where
    return = Success
    {-# INLINE return #-}
    Success a >>= k = k a
    Error err >>= _ = Error err
    {-# INLINE (>>=) #-}
Applicative instance: 


instance Applicative Result where
    pure  = return
    {-# INLINE pure #-}
    (<*>) = ap
    {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Parser where
    m >>= g = Parser $ \kf ks -> let ks' a = runParser (g a) kf ks
                                 in runParser m kf ks'
    {-# INLINE (>>=) #-}
    return a = Parser $ \_kf ks -> ks a
    {-# INLINE return #-}
    fail msg = Parser $ \kf _ks -> kf msg
    {-# INLINE fail #-}
Applicative instance: 


instance Applicative Parser where
    pure  = return
    {-# INLINE pure #-}
    (<*>) = apP
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/union-find-array-0.1.0.2/src/Control/Monad/Union.hs
Monad instance: 


instance Monad (UnionM l) where
    return x =  U (return x)
    f >>= b = U (runU f >>= runU . b)
Applicative instance: 


instance Applicative (UnionM l) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hxt-9.3.1.9/src/Text/XML/HXT/Arrow/Pickle/Xml.hs
Applicative instance: 


instance Applicative Unpickler where
    pure a      = UP $ \ st -> (Right a, st)
    uf <*> ua   = UP $ \ st ->
                  let (f, st') = runUP uf st in
                  case f of
                    Left err -> (Left err, st')
                    Right f' -> runUP (fmap f' ua) st'
Monad instance: 


instance Monad Unpickler where
    return      = pure
    u >>= f     = UP $ \ st ->
                  let (r, st') = runUP u st in
                  case r of
                    Left err -> (Left err, st')
                    Right v  -> runUP (f v) st'
    fail        = throwMsg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hermit-1.0.1/src/HERMIT/Plugin/Types.hs
Monad instance: 


instance Monad m => Monad (PluginT m) where
    return = PluginT . return
    PluginT m >>= k = PluginT (m >>= unPluginT . k)
    fail = Fail.fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hermit-1.0.1/src/HERMIT/Shell/Types.hs
Monad instance: 


-- TODO: type CLM = CLT IO

-- | Our own custom instance of Monad for CLT so we don't have to depend on
-- newtype deriving to do the right thing for fail.
instance Monad m => Monad (CLT m) where
    return = CLT . return
    (CLT m) >>= k = CLT (m >>= unCLT . k)
    fail = Fail.fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hermit-1.0.1/src/HERMIT/Monad.hs
Applicative instance: 


instance Applicative HermitM where
  pure :: a -> HermitM a
  pure = return

  (<*>) :: HermitM (a -> b) -> HermitM a -> HermitM b
  (<*>) = ap
Monad instance: 


instance Monad HermitM where
  return :: a -> HermitM a
  return a = HermitM $ \ env -> return (return (mkResult env a))

  (>>=) :: HermitM a -> (a -> HermitM b) -> HermitM b
  (HermitM gcm) >>= f =
        HermitM $ \ env -> gcm env >>= runKureM (\ (HermitMResult c ls a) ->
                                                        let env' = env { hEnvChanged = c, hEnvLemmas = ls }
                                                        in  runHermitM (f a) env')
                                                (return . fail)

  fail :: String -> HermitM a
  fail = Fail.fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/codec-0.1.1/Data/Codec/Codec.hs
Applicative instance: 


-- Build up a serializer in parallel to a deserializer.
instance (Applicative fw, Applicative fr) => Applicative (Codec' fr fw w) where
  pure x = Codec (pure x) (const $ pure ())
  Codec f fw <*> Codec x xw
    = Codec (f <*> x) (\w -> fw w *> xw w)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unagi-chan-0.4.0.0/src/Control/Concurrent/Chan/Unagi/NoBlocking/Types.hs
Applicative instance: 


instance  Applicative Element where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad Element where
    fail _ = Element (return Nothing)
    return = Element . return . return
    x >>= f = Element $ do
        v <- tryRead x
        case v of
            Nothing -> return Nothing
            Just y  -> tryRead (f y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Nomyx-Language-0.7.6/src/Language/Nomyx/Expression.hs
Monad instance: 


#else
instance Typeable1 (Exp NoEffect) where
    typeOf1 _ = mkTyConApp (mkTyCon3 "main" "Language.Nomyx.Expression" "Exp NoEffect") []

instance Typeable1 (Exp Effect) where
    typeOf1 _ = mkTyConApp (mkTyCon3 "main" "Language.Nomyx.Expression" "Exp Effect") []

instance Typeable a => Show (Exp NoEffect a) where
   show e = "<" ++ (show $ typeOf e) ++ ">"

instance Typeable a => Show (Exp Effect a) where
   show e = "<" ++ (show $ typeOf e) ++ ">"
#endif

instance Monad (Exp a) where
   return = Return
   (>>=) = Bind
Applicative instance: 


instance Applicative (Exp a) where
   pure = Return
   f <*> a = do
      f' <- f
      a' <- a
      return $ f' a'
Applicative instance: 


instance Applicative Event where
   pure = PureEvent
   (<*>) = AppEvent
Monad instance: 


instance Monad Event where
   (>>=) = BindEvent
   return = PureEvent
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/json-sop-0.2.0.1/src/Generics/SOP/Util/PartialResult.hs
Monad instance: 


instance Functor f => Monad (Partial f) where
  return = PZero
  fail   = Fail . return

  Fail e   >>= _ = Fail e
  PZero a  >>= f = f a
  PSucc fa >>= f = PSucc (fmap (>>= f) fa)
Applicative instance: 


instance Functor f => Applicative (Partial f) where
  pure = return
  f <*> a = do f' <- f ; a' <- a ; return (f' a')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hsc3-lang-0.9/Sound/SC3/Lang/Pattern/Step.hs
Monad instance: 


instance M.Monad (P s) where
    (>>=) p f = Continue p (\x q -> f x `M.mappend` (>>=) q f)
    return = Value
Applicative instance: 


instance A.Applicative (P s) where
    pure = prepeat
    (<*>) = Apply
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hsc3-lang-0.9/Sound/SC3/Lang/Pattern/List.hs
Applicative instance: 


instance A.Applicative P where
    pure = M.return
    (<*>) = M.ap
Monad instance: 


instance Monad P where
    m >>= f = pconcatMap f m
    return x = P [x]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haste-perch-0.1.0.9/Haste/Perch.hs
Applicative instance: 

instance Applicative PerchM
Monad instance: 


instance Monad PerchM where
   (>>) x y= mappend (unsafeCoerce x) y
   (>>=) = error "bind (>>=) invocation in the Perch monad creating DOM elements"
   return  = mempty
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haste-perch-0.1.0.9/Haste/App/Perch.hs
Applicative instance: 

instance Applicative PerchM
Monad instance: 


instance Monad PerchM where
   (>>) x y= mappend (unsafeCoerce x) y
   (>>=) = error "bind (>>=) invocation in the Perch monad creating DOM elements"
   return  = mempty
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/glpk-hs-0.3.5/Data/LinearProgram/GLPK/Types.hs
Monad instance: 


instance Monad GLPK where
        {-# INLINE return #-}
        {-# INLINE (>>=) #-}
        return x = GLP $ \ _ -> return x
        m >>= k = GLP $ \ lp -> do      x <- execGLPK m lp
                                        execGLPK (k x) lp
Applicative instance: 


instance Applicative GLPK where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/EitherT-0.2.0/src/Control/Monad/Trans/Either.hs
Monad instance: 


instance Monad m => Monad (EitherT l m) where
  -- We can't support "fail" because we don't have a
  -- (String -> l). But we can at least make it a Left, with the error inside
  -- it as a pure exception.
  fail = EitherT . return . Left . error
  return = EitherT . return . Right
  EitherT x >>= f = EitherT $ do
    res <- x
    case res of
      Right r -> runEitherT . f $ r
      Left l -> return (Left l)
Applicative instance: 

instance Applicative f => Applicative (EitherT l f) where
  pure = inEitherT0 . pure . pure
  (<*>) = inEitherT2 . liftA2 . liftA2 $ id
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cryptonite-0.9/Crypto/Random/Types.hs
Applicative instance: 


instance DRG gen => Applicative (MonadPseudoRandom gen) where
    pure a     = MonadPseudoRandom $ \g -> (a, g)
    (<*>) fm m = MonadPseudoRandom $ \g1 ->
        let (f, g2) = runPseudoRandom fm g1
            (a, g3) = runPseudoRandom m g2
         in (f a, g3)
Monad instance: 


instance DRG gen => Monad (MonadPseudoRandom gen) where
    return a    = MonadPseudoRandom $ \g -> (a, g)
    (>>=) m1 m2 = MonadPseudoRandom $ \g1 ->
        let (a, g2) = runPseudoRandom m1 g1
         in runPseudoRandom (m2 a) g2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cryptonite-0.9/Crypto/Error/Types.hs
Applicative instance: 


instance Applicative CryptoFailable where
    pure a     = CryptoPassed a
    (<*>) fm m = fm >>= \p -> m >>= \r2 -> return (p r2)
Monad instance: 

instance Monad CryptoFailable where
    return a = CryptoPassed a
    (>>=) m1 m2 = do
        case m1 of
            CryptoPassed a -> m2 a
            CryptoFailed e -> CryptoFailed e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/loops-0.2.0.2/src/Control/Monad/Loop/Internal.hs
Applicative instance: 


instance Applicative (LoopT m) where
    {-# INLINE pure #-}
    pure a = LoopT $ \yield -> yield a
    {-# INLINE (<*>) #-}
    fs <*> as = LoopT $ \yield next ->
        runLoopT fs (\f -> runLoopT (fmap f as) yield) next
Monad instance: 


instance Monad (LoopT m) where
    {-# INLINE return #-}
    return = pure
    {-# INLINE (>>=) #-}
    as >>= f = LoopT $ \yield next ->
        runLoopT as (\a -> runLoopT (f a) yield) next
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/DysFRP-0.1/Control/DysFRP/Internal.hs
Applicative instance: 


instance Applicative Behavior where
    pure x = Behavior $ pure x
    b1 <*> b2 = Behavior $ openBehavior b1 <*> openBehavior b2
Monad instance: 


instance Monad Behavior where
    return = pure
    b >>= bf = Behavior $ openBehavior b >>= openBehavior . bf
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/thih-1.0/src/TIMonad.hs
Monad instance: 


instance Monad TI where
  return x   = TI (\s n -> (s,n,x))
  TI f >>= g = TI (\s n -> case f s n of
                            (s',m,x) -> let TI gx = g x
                                        in  gx s' m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/spatial-math-0.3.1.0/src/Types.hs
Applicative instance: 

#endif

instance Applicative Euler where
  pure x = Euler x x x
  Euler f0 f1 f2 <*> Euler x0 x1 x2 = Euler (f0 x0) (f1 x1) (f2 x2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ncurses-0.2.9/lib/UI/NCurses/Types.hs
Monad instance: 


instance Monad Curses where
        return = Curses . return
        m >>= f = Curses (unCurses m >>= unCurses . f)
Applicative instance: 


instance A.Applicative Curses where
        pure = return
        (<*>) = ap
Monad instance: 


instance Monad Update where
        return = Update . return
        m >>= f = Update (unUpdate m >>= unUpdate . f)
Applicative instance: 


instance A.Applicative Update where
        pure = return
        (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/loop-while-1.0.0/Control/Monad/LoopWhile.hs
Monad instance: 


instance Monad m => Monad (LoopWhileT m) where
  m >>= f = LWT $ getLoop m >>= maybe (return Nothing) (getLoop . f)
  return = LWT . return . Just
Applicative instance: 


instance Monad m => Applicative (LoopWhileT m) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ggtsTC-0.5/src/ErrMsg.hs
Monad instance: 


instance Monad ErrMsg where
    Err x >>= _ = Err x
    OK x  >>= f = f x
    return x    = OK x
    fail x      = Err x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uu-cco-0.1.0.5/src/CCO/Tree/Parser.hs
Applicative instance: 


instance Applicative ArgumentParser where
  pure x = A 0 $ \aterms -> return (x, aterms)

  A m parse <*> A n parse' = A (m + n) $ \aterms -> do
                               (f, aterms')  <- parse aterms
                               (x, aterms'') <- parse' aterms'
                               return (f x, aterms'')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uu-cco-0.1.0.5/src/CCO/Lexing.hs
Applicative instance: 


instance Applicative Steps where
  pure x = Return x

  (Fail msg) <*> _          = Fail msg
  _          <*> (Fail msg) = Fail msg
  None       <*> _          = None
  _          <*> None       = None
  Return f   <*> Return x   = Return (f x)
  _          <*> _          = Ignore
Applicative instance: 


instance Applicative Lexer where
  pure x = Trie (pure x) []

  Trie None edges <*> lexer = Trie None
    [(p, flip <$> next <*> lexer) | (p, next) <- edges]
  Trie (Fail msg) edges <*> lexer = Trie (Fail msg)
    [(p, flip <$> next <*> lexer) | (p, next) <- edges]
  Trie steps edges <*> lexer@(Trie steps' edges') = Trie (steps <*> steps') $
    [(p, smap ((.) <$> steps) next) | (p, next) <- edges'] ++
    [(p, flip <$> next <*> lexer) | (p, next) <- edges]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uu-cco-0.1.0.5/src/CCO/Parsing.hs
Applicative instance: 


instance Applicative (Parser s) where
  pure x      = P (\k h -> k (h, x))
  P p <*> P q = P (\k -> p (q (\((h, f), x) -> k (h, f x))))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uu-cco-0.1.0.5/src/CCO/Feedback.hs
Monad instance: 


instance Monad Feedback where
  return x = Succeed [] x

  Succeed msgs x >>= f = case f x of
                           Succeed msgs' y -> Succeed (msgs ++ msgs') y
                           Fail msgs'      -> Fail (msgs ++ msgs')
  Fail msgs      >>= _ = Fail msgs

  fail msg             = Fail [Error (text msg)]
Applicative instance: 


instance Applicative Feedback where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/spice-0.5.0.0/src/FRP/Spice/Internal/Types.hs
Applicative instance: 


{-|
  An Applicative instance to satisfy the Monad's requirements in the future.
-}
instance Monoid a => Applicative (DoListT a) where
  pure b = DoListT mempty b
  (DoListT a' bfn) <*> (DoListT a b) =
    DoListT (a `mappend` a') $ bfn b
Monad instance: 


{-|
  The Monad instance to allow the DoList to compose through do-notation.
-}
instance Monoid a => Monad (DoListT a) where
  return = pure
  (DoListT a b) >>= fn =
    let (DoListT a' b') = fn b in
      DoListT (mappend a a') b'
Applicative instance: 


{-|
  An applicative instance to allow one to write functions on @'Vector'@s that
  have separate functions for both values.
-}
instance Applicative Vector where
  pure a = Vector a a
  (Vector fnx fny) <*> (Vector x y) =
    Vector (fnx x) (fny y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/yi-0.8.2/src/library/Parser/Incremental.hs
Applicative instance: 


instance Applicative (Parser s) where
    (<*>) = Appl
    pure = Pure
Monad instance: 


instance Monad (Parser s) where
    (>>=) = Bind
    return = pure
    fail _message = Empt
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/yi-0.8.2/src/library/Yi/Editor.hs
Applicative instance: 


instance Applicative EditorM where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/yi-0.8.2/src/library/Yi/Buffer/Misc.hs
Applicative instance: 


-- deriving instance Typeable4 RWS

instance Applicative BufferM where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/yi-0.8.2/src/library/Yi/Interact.hs
Applicative instance: 


instance Applicative (I ev w) where
    pure = return
    a <*> b = do f <- a; x <- b; return (f x)
Monad instance: 


instance Monad (I event w) where
  return  = Returns
  fail _  = Fails
  (>>=)   = Binds
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/yi-0.8.2/src/library/Yi/Keymap/Vim2/MatchResult.hs
Applicative instance: 


instance Applicative MatchResult where
    pure = WholeMatch
    WholeMatch f <*> WholeMatch x = WholeMatch (f x)
    _ <*> _ = NoMatch
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CC-delcont-0.2.1.0/Control/Monad/CC.hs
Applicative instance: 


instance (Monad m) => Applicative (CCT ans m) where
    pure  = return
    (<*>) = ap
Monad instance: 


instance (Monad m) => Monad (CCT ans m) where
    return v = CCT $ \k -> appk k v
    (CCT e1) >>= e2 = CCT $ \k -> e1 (PushSeg (MFrame e2) k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/data-named-0.6.1/src/Data/Named/Graph.hs
Applicative instance: 


instance Applicative (RanM w) where
  pure x = RanM $ \s -> (x, s)
  RanM v <*> RanM w = RanM $
    \s -> case v s of
      (f, s') -> case w s' of
        (x, s'') -> (f x, s'')
Monad instance: 


instance Monad (RanM w) where
    return x     = RanM $ \s -> (x, s)
    RanM v >>= f = RanM $ \s -> case v s of (x, s') -> runRanM (f x) s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/precis-0.5.0/src/Precis/ReportMonad.hs
Monad instance: 



instance Monad ReportM where
  return a  = ReportM $ \_ w -> returnIO (a,w)
  ma >>= mf = ReportM $ \e w -> (getReportM ma e w) `bindIO` \(a,w') ->
                                (getReportM . mf) a e w'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/precis-0.5.0/src/Precis/Cabal/ResolveM.hs
Applicative instance: 



instance Applicative ResolveM where
  pure a   = ResolveM $ \_   st -> return (a,st)
  af <*> a = ResolveM $ \env st -> getResolveM af env st  >>= \(f,st')  ->
                                   getResolveM a  env st' >>= \(b,st'') ->
                                   return (f b, st'')
Monad instance: 



instance Monad ResolveM where
  return a = ResolveM $ \_   st -> return (a,st)
  m >>= k  = ResolveM $ \env st -> getResolveM m env st >>= \(a,st') ->
                                   getResolveM (k a) env st'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uu-parsinglib-2.9.1.1/src/Text/ParserCombinators/UU/Core.hs
Applicative instance: 


instance   Applicative (T  state) where
  T ph pf pr  <*> ~(T qh qf qr)  =  T ( \  k -> ph (\ pr -> qh (\ qr -> k (pr qr))))
                                      ((apply .) . (pf .qf))
                                      ( pr . qr)
  T ph pf pr  <*  ~(T _  _  qr)   = T ( ph. (qr.))  (pf. qr)   (pr . qr)
  T _  _  pr  *>  ~(T qh qf qr )  = T ( pr . qh  )  (pr. qf)    (pr . qr)
  pure a                          = T ($a) ((push a).) id
Applicative instance: 


instance   Applicative (P  state) where
  P ap np pe pl  <*> ~(P aq nq  qe ql)  = trace'' "<*>"  (mkParser (combine np pe aq nq (<*>) (<$>))       (pe <*> qe)  (nat_add pl ql))
  P ap np pe pl  <*  ~(P aq nq  qe ql)  = trace'' "<* "  (mkParser (combine np pe aq nq (<*)  (<$))        (pe <* qe )  (nat_add pl ql))
  P ap np pe pl  *>  ~(P aq nq  qe ql)  = trace'' " *>"  (mkParser (combine np pe aq nq (*>) (flip const)) (pe *> qe )  (nat_add pl ql))
  pure a                                = trace'' "pure" (mkParser Nothing (Just a)  Zero)
Monad instance: 


-- !! do not move the P constructor behind choices/patern matches
instance  Monad (P st) where
       p@(P  ap np pe pl ) >>=  a2q =
          (P newap newnp  newep (nat_add pl Hole))
          where (newep, newnp, newap) = case pe of
                                 Nothing -> (Nothing, t, maybe empty id t)
                                 Just a  -> let  P aq nq  eq lq = a2q a
                                            in  (eq, combine t nq , t `alt` aq)
                Nothing  `alt` q    = q
                Just p   `alt` q    = p <|> q
                t = fmap (\  (T h _ _  ) ->      (T  (  \k -> h (\ a -> unParser_h (a2q a) k))
                                                     (  \k -> h (\ a -> unParser_f (a2q a) k))
                                                     (  \k -> h (\ a -> unParser_r (a2q a) k))) ) np
                combine Nothing     Nothing     = Nothing
                combine l@(Just _ ) Nothing     =  l
                combine Nothing     r@(Just _ ) =  r
                combine (Just l)    (Just r)    = Just (l <|> r)
                -- | `unParser_h` retreives the history parser from the descriptor
                unParser_h :: P b a -> (a -> b -> Steps r) -> b -> Steps r
                unParser_h (P (T  h   _  _ ) _ _ _ )  =  h
                -- | `unParser_f` retreives the future parser from the descriptor
                unParser_f :: P b a -> (b -> Steps r) -> b -> Steps (a, r)
                unParser_f (P (T  _   f  _ ) _ _ _ )  =  f
                -- | `unParser_r` retreives therecogniser from the descriptor
                unParser_r :: P b a -> (b -> Steps r) -> b -> Steps r
                unParser_r (P (T  _   _  r ) _ _ _ )  =  r
       return  = pure
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CC-delcont-ref-0.1.0.0/Bench_nondet.hs
Monad instance: 


instance Monad CPS where
    return x = CPS $ \k -> k x
    m >>= f  = CPS $ \k -> unCPS m (\a -> unCPS (f a) k)
Monad instance: 


instance Monad m => Monad (CCR m) where
    return x = CCR $ \_ -> return x
    m >>= f  = CCR $ \p -> unCCR m p >>= \v -> unCCR (f v) p
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CC-delcont-ref-0.1.0.0/Control/Monad/CC/CCRef.hs
Monad instance: 

-- hence, the rest of scAPI is irrelevant:
-- copy_stack_fragment and push_stack_fragment do nothing at all

-- --------------------------------------------------------------------
-- | CC monad: general monadic operations

instance Monad m => Monad (CC m) where
    return x = CC $ \k _ -> k x
    m >>= f  = CC $ \k ptop -> unCC m (\v -> unCC (f v) k ptop) ptop
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hgom-0.6/Gom/CodeGen/Common/GenMonad.hs
Applicative instance: 


instance Applicative Gen where
  (<*>) = ap
  pure  = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monadplus-1.4.2/src/Control/Monad/Plus.hs
Monad instance: 


instance Monad (Partial r) where
    return x = Partial (\_ -> Just x)
    Partial f >>= k = Partial $ \r -> do { x <- f r; getPartial (k x) r }
Applicative instance: 


instance Applicative (Partial r) where
    pure x = Partial (\_ -> Just x)
    Partial f <*> Partial g = Partial $ \x -> f x <*> g x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/visual-prof-0.5/Pretty.hs
Monad instance: 


instance Monad (DocM s) where
        (>>=) = thenDocM
        (>>) = then_DocM
        return = retDocM
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/transformers-supply-0.1.0/Control/Applicative/Supply.hs
Applicative instance: 


instance Applicative f => Applicative (SupplyT s f) where
    pure = Done . pure
    (Done f) <*> (Done x) = Done (f <*> x)
    (More f) <*> x = More $ \s -> f s <*> x
    f <*> (More g) = More $ \s -> f <*> g s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/transformers-supply-0.1.0/Control/Monad/Trans/Supply.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (SupplyT s m) where
    pure = SupplyT . return . Done
    (<*>) = ap
Monad instance: 


instance (Functor m, Monad m) => Monad (SupplyT s m) where
    return = pure
    SupplyT m >>= f = SupplyT $ m >>= \v -> case v of
        Done a -> unwrapSupplyT (f a)
        More g -> return . More $ g >=> f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fixed-vector-hetero-0.3.1.1/Data/Vector/HFixed/Class.hs
Applicative instance: 


instance Arity xs => Applicative (Fun xs) where
  pure r = Fun $ accum (\T_pure _ -> T_pure)
                       (\T_pure   -> r)
                       (T_pure :: T_pure xs)
  (Fun f0 :: Fun xs (a -> b)) <*> (Fun g0 :: Fun xs a)
    = Fun $ accum (\(T_ap f g) a -> T_ap (f a) (g a))
                  (\(T_ap f g)   -> f g)
                  ( T_ap f0 g0 :: T_ap (a -> b) a xs)
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
Monad instance: 


instance Arity xs => Monad (Fun xs) where
  return  = pure
  f >>= g = shuffleF g <*> f
  {-# INLINE return #-}
  {-# INLINE (>>=)  #-}
Applicative instance: 


instance (Arity xs) => Applicative (TFun f xs) where
  pure r = TFun $ accumTy step
                          (\TF_pure   -> r)
                          (TF_pure :: TF_pure f xs)
    where
      step :: forall a as. TF_pure f (a ': as) -> f a -> TF_pure f as
      step _ _ = TF_pure
  {-# INLINE pure  #-}
  (TFun f0 :: TFun f xs (a -> b)) <*> (TFun g0 :: TFun f xs a)
    = TFun $ accumTy (\(TF_ap f g) a -> TF_ap (f a) (g a))
                  (\(TF_ap f g)   -> f g)
                  ( TF_ap f0 g0 :: TF_ap f (a -> b) a xs)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Arity xs => Monad (TFun f xs) where
  return  = pure
  f >>= g = shuffleTF g <*> f
  {-# INLINE return #-}
  {-# INLINE (>>=)  #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/jdi-0.0.3/src/Language/Java/Jdi.hs
Applicative instance: 


instance Monad m => Applicative (VirtualMachine m) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lens-action-0.2.0.2/src/Control/Lens/Action/Internal.hs
Applicative instance: 


instance (Monad m, Monoid r) => Applicative (Effect m r) where
  pure _ = Effect (return mempty)
  {-# INLINE pure #-}
  Effect ma <*> Effect mb = Effect (liftM2 mappend ma mb)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lens-action-0.2.0.2/src/Control/Lens/Action/Reified.hs
Applicative instance: 


instance Applicative (ReifiedMonadicFold m s) where
  pure a = MonadicFold $ folding $ \_ -> [a]
  {-# INLINE pure #-}
  mf <*> ma = mf <.> ma
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad (ReifiedMonadicFold m s) where
  return a = MonadicFold $ folding $ \_ -> [a]
  {-# INLINE return #-}
  ma >>= f = ((ma >>^ f) &&& returnA) >>> app
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/frag-1.1.2/src/AFRPTask.hs
Monad instance: 



------------------------------------------------------------------------------
-- Monad instance
------------------------------------------------------------------------------

instance Monad (Task a b) where
    tk >>= f = Task (\k -> (unTask tk) (\c -> unTask (f c) k))
    return x = Task (\k -> k x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/large-hashable-0.1.0.1/src/Data/LargeHashable/Intern.hs
Applicative instance: 


instance Applicative LH where
    pure = lhReturn
    (<*>) = lhApp
Monad instance: 


instance Monad LH where
    return = lhReturn
    (>>=) = lhBind
    (>>) = lhBind'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/plat-0.1.0.1/Plat/Context.hs
Monad instance: 

instance Monad Context where
    return = Context . return
    Context w >>= f = Context (w >>= \x -> let Context w' = f x in w')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/plat-0.1.0.1/Plat/Errors.hs
Monad instance: 

instance Monad (Errors e) where
  return = Result
  Result x >>= f = f x
  Errors e >>= _ = Errors e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/parsec2-1.0.1/Text/ParserCombinators/Parsec/Prim.hs
Monad instance: 


-----------------------------------------------------------
-- Monad: return, sequence (>>=) and fail
-----------------------------------------------------------    
instance Monad (GenParser tok st) where
  return x   = parsecReturn x
  p >>= f    = parsecBind p f
  fail msg   = parsecFail msg
Applicative instance: 


{- 
-- variant that favors a consumed reply over an empty one, even it is not the first alternative.
          empty@(Empty reply) -> case reply of
                                   Error err ->
                                     case (p2 state) of
                                       Empty reply -> Empty (mergeErrorReply err reply)
                                       consumed    -> consumed
                                   ok ->
                                     case (p2 state) of
                                       Empty reply -> empty
                                       consumed    -> consumed
          consumed  -> consumed
-}

-----------------------------------------------------------
-- Bonus instances
-----------------------------------------------------------

instance A.Applicative (GenParser tok st) where
  pure x = return x
  mf <*> mx = mf `ap` mx
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/acme-timemachine-0.0.1.0/src/Acme/TimeMachine/Undoable.hs
Applicative instance: 


instance Applicative (Undoable s) where
    pure x = Undoable $ \l -> (l, x)
    (Undoable f) <*> (Undoable k) = Undoable $ \l -> case f l of ~(l, f) -> case k l of ~(l, k) -> (l, f k)
Monad instance: 


instance Monad (Undoable s) where
    return x = Undoable $ \l -> (l, x)
    (Undoable k) >>= f = Undoable $ \l -> case k l of ~(l, r) -> getUndoable (f r) l
    (Undoable k) >> (Undoable f) = Undoable $ \l -> case k l of ~(l, _) -> f l
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/appar-0.1.4/Text/Appar/Parser.hs
Applicative instance: 


instance Applicative (MkParser inp) where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad (MkParser inp) where
    return a = P $ \bs -> (Just a, bs)
    p >>= f  = P $ \bs -> case runParser p bs of
        (Nothing, bs') -> (Nothing, bs')
        (Just a,  bs') -> runParser (f a) bs'
    fail _   = P $ \bs -> (Nothing, bs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/event-0.1.4/src/Control/Concurrent/Event.hs
Applicative instance: 


instance Applicative Event where
  pure x = Event $ \k -> k x >> pure mempty
  (<*>) = ap
Monad instance: 


instance Monad Event where
  return = pure
  x >>= f = Event $ \k -> do
    dref <- newIORef mempty
    dx <- on x $ \x' -> do
      dfx <- on (f x') k
      modifyIORef dref (<> dfx)
    modifyIORef dref (<> dx)
    pure . Detach $ readIORef dref >>= detach
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/notzero-0.0.9/src/Data/NotZeroOr.hs
Applicative instance: 


instance Applicative (NotZeroOr a) where
  pure =
    OrNotZero
  (<*>) =
    (<.>)
Monad instance: 


instance Monad (NotZeroOr a) where
  return =
    pure
  (>>=) =
    (>>-)
Applicative instance: 


instance Applicative f => Applicative (NotZeroOrT a f) where
  pure =
    NotZeroOrT . pure . pure
  NotZeroOrT f <*> NotZeroOrT a =
    NotZeroOrT (liftA2 (<*>) f a)
Monad instance: 


instance Monad f => Monad (NotZeroOrT a f) where
  return =
    NotZeroOrT . return . return
  (>>=) =
    bind
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/notzero-0.0.9/src/Data/AccNotZeroOr.hs
Applicative instance: 


instance Alt f => Applicative (AccNotZeroOr f a) where
  pure =
    OrAccNotZero
  (<*>) =
    (<.>)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gulcii-0.2.0.3/src/Parse.hs
Applicative instance: 


instance Applicative (Parser s) where
  pure f = P (\q -> [(f, q)])
  P p1 <*> P p2 = P (\q -> [ (u v, t) | (u, s) <- p1 q, (v, t) <- p2 s ])
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/MissingH-1.4.0.1/src/Data/Compression/Inflate.hs
Monad instance: 


instance Monad InfM where
 -- (>>=)  :: InfM a -> (a -> InfM b) -> InfM b
    InfM v >>= f = InfM $ \s -> let (x, s') = v s
                                    InfM y = f x
                                in y s'
 -- return :: a -> InfM a
    return x = InfM $ \s -> (x, s)
Applicative instance: 


instance Applicative InfM where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-lrs-0.0.2.1/Math/LinearRecursive/Monad.hs
Monad instance: 


instance Num a => Monad (LinearRecursive a) where
    return a = LR (const (a, 0, id))
    a >>= b = LR $ \v -> let (ra, nva, ma) = unLR a v
                             (rb, nvb, mb) = unLR (b ra) (v + nva)
                         in
                             (rb, nva + nvb, mb . ma)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/funcons-tools-0.1.0.0/src/Funcons/MSOS.hs
Applicative instance: 


instance Applicative Rewrite where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Rewrite  where
  return a = Rewrite (\_ st -> (Right a, st, mempty))

  (Rewrite f) >>= k = Rewrite (\ctxt st ->
                    let res1@(e_a1,st1,cs1) = f ctxt st
                     in case e_a1 of
                          Left err  -> (Left err, st1, cs1)
                          Right a1  -> let (Rewrite h) = k a1
                                           (a2,st2,cs2) = h ctxt st1
                                        in (a2,st2,cs1 <> cs2))
Applicative instance: 


instance Applicative MSOS where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad MSOS  where
  return a = MSOS (\_ mut -> return (Right a,mut,mempty))

  (MSOS f) >>= k = MSOS (\ctxt mut -> do
                    res1@(e_a1,mut1,wr1) <- f ctxt mut
                    case e_a1 of
                      Left err  -> return (Left err, mut1, wr1)
                      Right a1  -> do
                            let (MSOS h) = k a1
                            (a2,mut2,wr2) <- h ctxt mut1
                            return (a2,mut2,wr1 <> wr2))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Validation-0.2.0/src/Data/Validation.hs
Applicative instance: 


instance Semigroup err => Applicative (AccValidation err) where
  pure =
    AccSuccess
  (<*>) =
    (<.>)
Applicative instance: 


instance Applicative (Validation err) where
  pure =
    Success
  (<*>) =
    (<.>)
Monad instance: 


instance Monad (Validation err) where
  return =
    Success
  (>>=) =
    (>>-)
Applicative instance: 


instance Applicative m => Applicative (ValidationT m err) where
  pure =
    ValidationT . pure . pure
  ValidationT f <*> ValidationT a =
    ValidationT (liftA2 (<*>) f a)
Monad instance: 


instance Monad m => Monad (ValidationT m err) where
  return =
    ValidationT . return . pure
  ValidationT v >>= f =
    ValidationT (v >>= \w -> case w of
                               Failure e -> return (Failure e)
                               Success a -> runValidationT (f a))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/functor-apply-0.9.3/Data/Functor/Bind.hs
Applicative instance: 


instance Applicative f => Applicative (WrappedApplicative f) where
  pure = WrapApplicative . pure
  WrapApplicative f <*> WrapApplicative a = WrapApplicative (f <*> a)
  WrapApplicative a <*  WrapApplicative b = WrapApplicative (a <*  b)
  WrapApplicative a  *> WrapApplicative b = WrapApplicative (a  *> b)
Applicative instance: 


instance Apply f => Applicative (MaybeApply f) where
  pure a = MaybeApply (Right a)
  (<*>) = (<.>)
  (<* ) = (<. )
  ( *>) = ( .>)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/improve-0.4.0/Language/ImProve.hs
Monad instance: 


instance Monad Stmt where
  return a = Stmt $ \ s -> (a, s)
  (Stmt f1) >>= f2 = Stmt f3
    where
    f3 s1 = f4 s2
      where
      (a, s2) = f1 s1
      Stmt f4 = f2 a
Monad instance: 

instance Monad Case where
  return _ = Case id
  (>>=) = undefined
  (Case f1) >> (Case f2) = Case $ f1 . f2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mstate-0.2.7/src/Control/Concurrent/MState.hs
Monad instance: 
 -- clean up again for "waitForTermination"

--------------------------------------------------------------------------------
-- Monad instances
--------------------------------------------------------------------------------

instance (Monad m) => Monad (MState t m) where
    return a = MState $ \_ -> return a
    m >>= k  = MState $ \t -> do
        a <- runMState' m t
        runMState' (k a) t
    fail str = MState $ \_ -> fail str
Applicative instance: 


instance (Applicative m, Monad m) => Applicative (MState t m) where
    pure  = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/language-boogie-0.2/Language/Boogie/ErrorAccum.hs
Monad instance: 


instance (ErrorList e, Monad m) => Monad (ErrorAccumT e m) where
  -- | Attach an empty list of errors to a succesful computation
  return x  = ErrorAccumT $ return ([], x)
  -- | The bind strategy is to concatenate error lists
  m >>= k   = ErrorAccumT $ do
    (errs, res) <- runErrorAccumT m
    (errs', res') <- runErrorAccumT $ k res
    return (errs ++ errs', res')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/shell-monad-0.6.4/Control/Monad/Shell.hs
Applicative instance: 


instance Applicative Script where
        pure a = Script $ \env -> ([], env, a)
        Script f <*> Script a = Script $ \env0 ->
                let (expr1, env1, f') = f env0
                    (expr2, env2, a') = a env1
                in  (expr1 <> expr2, env2, f' a')
Monad instance: 


instance Monad Script where
        return ret = Script $ \env -> ([], env, ret)
        a >>= b = Script $ \start -> let
                (left, mid, v) = call a start
                (right, end, ret) = call (b v) mid
                in (left ++ right, end, ret)
          where
                call :: Script f -> Env -> ([Expr], Env, f)
                call (Script f) = f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-stlike-io-0.2.2/Control/Monad/STLike/Internal.hs
Monad instance: 


instance Monad (Regioned s) where
    return      = R
    _     >>  b = b
    (R v) >>= f = f v
Monad instance: 


instance STLikeImpl m => Monad (STLike m s) where
    (STLike a) >> (STLike b)   = STLike (a >> b)
    (STLike a) >>= b  = STLike $ do v <- a
                                    let STLike r = b v
                                    r
    return x = STLike (return x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CC-delcont-exc-0.1.0.0/Generator2.hs
Monad instance: 


instance Monad Identity where
    return = Identity
    m >>= f = f $ runIdentity m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CC-delcont-exc-0.1.0.0/Bench_nondet.hs
Monad instance: 


instance Monad CPS where
    return x = CPS $ \k -> k x
    m >>= f  = CPS $ \k -> unCPS m (\a -> unCPS (f a) k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CC-delcont-exc-0.1.0.0/Control/Monad/CC/CCExc.hs
Monad instance: 



-- --------------------------------------------------------------------
-- | CC monad: general monadic operations

instance Monad m => Monad (CC p m) where
    return = CC . return . Iru

    m >>= f = CC $ unCC m >>= check
        where check (Iru a)         = unCC $ f a
              check (Deru ctx body) = return $ Deru (\x -> ctx x >>= f) body
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/coverage-0.1.0.4/src/Control/Coverage/Internal.hs
Applicative instance: 


-- | Applicative instance for Redundant.
instance Applicative Redundant where
  pure = Redundant

  DontKnow <*> _      = DontKnow
  NotRedundant <*> _  = NotRedundant
  (Redundant f) <*> m = fmap f m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fixed-vector-0.8.1.0/Data/Vector/Fixed/Cont.hs
Applicative instance: 


instance Arity n => Applicative (Fun n a) where
  pure (x :: x) = Fun $ accum (\(T_pure r) (_::a) -> T_pure r)
                              (\(T_pure r)        -> r)
                              (T_pure x :: T_pure x n)
  (Fun f0 :: Fun n a (p -> q)) <*> (Fun g0 :: Fun n a p)
    = Fun $ accum (\(T_ap f g) a -> T_ap (f a) (g a))
                  (\(T_ap f g)   -> f g)
                  (T_ap f0 g0 :: T_ap a (p -> q) p n)
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
Monad instance: 


instance Arity n => Monad (Fun n a) where
  return  = pure
  f >>= g = shuffleFun g <*> f
  {-# INLINE return #-}
  {-# INLINE (>>=)  #-}
Applicative instance: 


instance (Arity n) => Applicative (ContVec n) where
  pure  = replicate
  (<*>) = zipWith ($)
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fixed-vector-0.8.1.0/Data/Vector/Fixed/Boxed.hs
Applicative instance: 


instance Arity n => Applicative (Vec n) where
  pure  = replicate
  (<*>) = zipWith ($)
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fixed-vector-0.8.1.0/Data/Vector/Fixed.hs
Applicative instance: 

instance Arity n => Applicative (VecList n) where
  pure  = replicate
  (<*>) = zipWith ($)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactive-banana-threepenny-0.7.1.3/src/Tidings.hs
Applicative instance: 


-- | The applicative instance combines 'rumors'
-- and uses 'facts' when some of the 'rumors' are not available.
instance Applicative (Tidings t) where
    pure x  = T (pure x) never
    f <*> x = uncurry ($) <$> pair f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hsqml-0.3.4.1/test/Graphics/QML/Test/MayGen.hs
Applicative instance: 


instance Applicative MayGen where
    pure = MayGen . Just . return
    (MayGen mf) <*> (MayGen v) = MayGen $ liftA2 (<*>) mf v
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/artery-0.1.1/Control/Artery.hs
Applicative instance: 


instance Applicative (Artery m i) where
    pure x = go where
        go = Artery $ \_ cont -> cont x go
    {-# INLINE pure #-}
    Artery ff <*> Artery fx = Artery $ \i cont -> ff i $ \f ff' -> fx i $ \x fx' -> cont (f x) (ff' <*> fx')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Lucu-0.7.0.3/Network/HTTP/Lucu/Parser.hs
Monad instance: 



--  (>>=) :: Parser a -> (a -> Parser b) -> Parser b
instance Monad Parser where
    p >>= f = Parser $! do saved <- get -- 失敗した時の爲に状態を保存
                           result <- runParser p
                           case result of
                             Success a    -> runParser (f a)
                             IllegalInput -> do put saved -- 状態を復歸
                                                return IllegalInput
                             ReachedEOF   -> do put saved -- 状態を復歸
                                                return ReachedEOF
    return !x = Parser $! return $! Success x
    fail _    = Parser $! return $! IllegalInput
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Lucu-0.7.0.3/Network/HTTP/Lucu/Resource.hs
Monad instance: 


instance Monad Resource where
    c >>= f = Resource (unRes c >>= unRes . f)
    return  = Resource . return
    fail    = Resource . fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-base-2.3/Algebra/Applicative.hs
Applicative instance: 


instance Applicative (Either a)
Monad instance: 

instance Monad (Either a) where join (Right a) = a
                                join (Left a) = Left a
Applicative instance: 

instance Applicative ((->) a)
Monad instance: 

instance Monad ((->) a) where join f x = f x x
Applicative instance: 

instance Monoid w => Applicative ((,) w)
Monad instance: 

instance Monoid w => Monad ((,) w) where
  join ~(w,~(w',a)) = (w+w',a)
Applicative instance: 

instance (Monoid k,Ord k) => Applicative (Increasing k)
Monad instance: 

instance (Monoid k,Ord k) => Monad (Increasing k) where
  join l = Increasing (Compose (OrdList (join' $ fromAscList (map fromAscList l))))
    where join' (Assoc k (Assoc k' a:as):ass) = Assoc (k+k') a:join' (insert (Assoc k' as) ass)
          join' (Assoc _ []:ass) = join' ass
          join' [] = []
          insert x [] = [x]
          insert x (a:as) | x<=a = x:a:as
                          | otherwise = a:insert x as
          fromAscList (Increasing (Compose (OrdList l'))) = l'
Applicative instance: 

instance (Applicative f,Applicative g) => Applicative (f:**:g) where
  ff:**:fg <*> xf:**:xg = (ff<*>xf) :**: (fg<*>xg)
Applicative instance: 


instance Applicative Tree
Monad instance: 

instance Monad Tree where
  join (Node (Node a subs) subs') = Node a (subs + map join subs')
Applicative instance: 


instance (Applicative f,Applicative g) => Applicative (f:.:g) where
  Compose fs <*> Compose xs = Compose ((<*>)<$>fs<*>xs)
Applicative instance: 

instance Applicative (Zip []) where
  Zip zf <*> Zip zx = Zip (zip_ zf zx)
    where zip_ (f:fs) (x:xs) = f x:zip_ fs xs
          zip_ _ _ = []
Applicative instance: 

instance Applicative (Zip Tree) where
  Zip (Node f fs) <*> Zip (Node x xs) =
    Zip (Node (f x) (deZip ((<*>)<$>Zip fs<*>Zip xs)))
Applicative instance: 

instance Applicative f => Applicative (Backwards f) where
  Backwards fs <*> Backwards xs = Backwards (fs<**>xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-base-2.3/Algebra/Foldable.hs
Applicative instance: 


instance Applicative []
Monad instance: 

instance Monad [] where join = fold
Applicative instance: 

instance Applicative Maybe
Monad instance: 

instance Monad Maybe where join = fold
Applicative instance: 

instance Applicative Interleave
Monad instance: 

instance Monad Interleave where join = fold
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-base-2.3/Algebra/Functor.hs
Applicative instance: 

instance Applicative Id
Monad instance: 

instance Monad Id where join (Id a) = a
Applicative instance: 

instance Applicative Strict
Monad instance: 

instance Monad Strict where join = lazy
Applicative instance: 

instance Monoid a => Applicative (Const a) where
  Const a <*> Const b = Const (a+b)
Applicative instance: 

instance Applicative IO
Monad instance: 

instance Monad IO where (>>=) = (P.>>=)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-base-2.3/Algebra/Monad/State.hs
Monad instance: 

instance Monad m => Monad (StateT s m) where join = coerceJoin StateT
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-base-2.3/Algebra/Monad/Error.hs
Monad instance: 

instance Monad m => Monad (EitherT e m) where join = coerceJoin EitherT
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-base-2.3/Algebra/Monad/Writer.hs
Monad instance: 

instance (Monoid w,Monad m) => Monad (WriterT w m) where join = coerceJoin WriterT
Monad instance: 

instance (Monoid w,SubSemi a w,Monad m) => Monad (CounterT w a m) where join = coerceJoin WA
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-base-2.3/Algebra/Monad/Foldable.hs
Monad instance: 

instance Monad m => Monad (ListT m) where join = coerceJoin ListT
Monad instance: 

instance Monad m => Monad (TreeT m) where join = coerceJoin TreeT
Monad instance: 

instance Monad m => Monad (MaybeT m) where join = coerceJoin MaybeT
Monad instance: 

instance Monad m => Monad (StrictT m) where join = coerceJoin StrictT
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-base-2.3/Algebra/Monad/Reader.hs
Monad instance: 

instance Monad m => Monad (ReaderT r m) where join = coerceJoin ReaderT
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-base-2.3/Algebra/Monad/Free.hs
Applicative instance: 

instance Functor f => Applicative (Free f)
Monad instance: 

instance Functor f => Monad (Free f) where
  join (Join f) = Join (map join f)
  join (Pure f) = f
Applicative instance: 

instance Applicative m => Applicative (Cofree m) where
Monad instance: 

instance Applicative m => Monad (Cofree m) where
  join (Step (Step a _) ww) = Step a (map join ww)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-base-2.3/Algebra/Monad/Base.hs
Monad instance: 


instance (Traversable g,Monad f,Monad g) => Monad (f:.:g) where
  join = Compose .map join.join.map sequence.getCompose.map getCompose
Monad instance: 


instance MonadFix m => Monad (Backwards m) where
  join (Backwards ma) = Backwards$mfixing (\a -> liftA2 (,) (forwards a) ma)
Monad instance: 

instance (Monad f,Monad g,Traversable f) => Monad (Compose' f g) where join = coerceJoin Compose'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-base-2.3/Data/Containers.hs
Applicative instance: 

instance Ord k => Applicative (Zip (Map k)) where
  Zip fs <*> Zip xs = Zip (M.intersectionWith ($) fs xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-base-2.3/Data/Containers/Sequence.hs
Monad instance: 

instance Monad m => P.Monad (PMonad m) where
  PMonad m >>= k = PMonad (m >>= runPMonad . k)
  return = PMonad . pure
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-base-2.3/Data/TimeVal.hs
Applicative instance: 

instance Applicative TimeVal
Monad instance: 

instance Monad TimeVal where
  join (Since b) = b
  join Always = Always
  join Never = Never
Monad instance: 

instance Monad Boolean where join = coerceJoin Boolean
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-base-2.3/Data/Probability.hs
Monad instance: 

instance (Ring t,Monad m) => Monad (ProbT t m) where join = coerceJoin ProbT
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/acme-all-monad-0.1.0.0/src/Control/Monad/All/Trans.hs
Applicative instance: 


instance Applicative (AllT m) where
  pure _ = AllT
  _ <*> _ = AllT
Monad instance: 


instance Monad (AllT m) where
  return _ = AllT
  _ >>= _ = AllT
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unicode-0.0/src/Data/Char/Block.hs
Applicative instance: 



instance Applicative Row where
   pure a = Row a a
   Row fa fb <*> Row a b = Row (fa a) (fb b)
Applicative instance: 


instance Applicative Block where
   pure a = Block (pure a) (pure a)
   Block fa fb <*> Block a b =
      Block (fa <*> a) (fb <*> b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unicode-0.0/src/Data/Char/Frame.hs
Applicative instance: 



instance Applicative Horizontal where
   pure a = Horizontal a a
   Horizontal fa fb <*> Horizontal a b =
      Horizontal (fa a) (fb b)
Applicative instance: 


instance Applicative Vertical where
   pure a = Vertical a a
   Vertical fa fb <*> Vertical a b =
      Vertical (fa a) (fb b)
Applicative instance: 


instance Applicative Parts where
   pure a = Parts (pure a) (pure a)
   Parts fa fb <*> Parts a b =
      Parts (fa <*> a) (fb <*> b)
Applicative instance: 


instance Applicative Directions where
   pure a = Directions a a
   Directions fa fb <*> Directions a b =
      Directions (fa a) (fb b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/contstuff-1.2.6/Control/ContStuff/Trans.hs
Applicative instance: 


instance Applicative (ChoiceT r i m) where
    pure x = ChoiceT $ \fold z k -> fold z x k
    ChoiceT cf <*> ChoiceT cx =
        ChoiceT $ \fold z k ->
            cx (\xx yx kx -> cf (\xf yf kf -> fold xf (yf yx) kf) xx kx) z k
Monad instance: 


instance Monad (ChoiceT r i m) where
    return x = ChoiceT $ \fold z k -> fold z x k
    ChoiceT c >>= f =
        ChoiceT $ \fold z k ->
            c (\x y kc -> getChoiceT (f y) fold x kc) z k
Applicative instance: 


instance Applicative (ContT r m) where
    pure = return
    ContT cf <*> ContT cx =
        ContT $ \k -> cf (\f -> cx (\x -> k (f x)))
Monad instance: 


instance Monad (ContT r m) where
    return x = ContT $ \k -> k x
    ContT c >>= f =
        ContT $ \k -> c (\x -> getContT (f x) k)
Applicative instance: 


instance Applicative (EitherT r e m) where
    pure x = EitherT $ \k _ -> k x
    EitherT cf <*> EitherT cx =
        EitherT $ \k expk -> cf (\f -> cx (\x -> k (f x)) expk) expk
Monad instance: 


instance Monad (EitherT r e m) where
    return x = EitherT $ \k _ -> k x
    EitherT c >>= f =
        EitherT $ \k expk ->
            c (\x -> getEitherT (f x) k expk) expk
Applicative instance: 


instance Applicative (MaybeT r m) where
    pure x = MaybeT $ \just _ -> just x
    MaybeT cf <*> MaybeT cx =
        MaybeT $ \just noth -> cf (\f -> cx (\x -> just (f x)) noth) noth
Monad instance: 


instance Monad (MaybeT r m) where
    return x = MaybeT $ \just _ -> just x
    MaybeT c >>= f =
        MaybeT $ \just noth ->
            c (\x -> getMaybeT (f x) just noth) noth
Applicative instance: 


instance Applicative (ReaderT e m) where
    pure = return
    ReaderT cf <*> ReaderT cx = ReaderT (cf <*> cx)
Monad instance: 


instance Monad (ReaderT e m) where
    return x = ReaderT (return x)
    ReaderT c >>= f =
        ReaderT (c >>= getReaderT . f)
Applicative instance: 


instance Applicative (StateT r s m) where
    pure = return
    StateT cf <*> StateT cx = StateT $ \k -> cf (\f -> cx (k . f))
Monad instance: 


instance Monad (StateT r s m) where
    return x = StateT ($ x)
    StateT c >>= f = StateT $ \k -> c (\x -> getStateT (f x) k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cognimeta-utils-0.1.2/src/Cgm/Control/Monad/State.hs
Applicative instance: 

instance (Functor m, Monad m) => Applicative (StateT s m) where
  pure = return
  (<*>) = ap
Monad instance: 

instance Monad m => Monad (StateT s m) where
  return = lift . return
  (StateT c) >>= fd = StateT $ \s ->
    c s >>= \(a, ms) ->   -- We are strict in the state. We do as in Control.Monad.Trans.State.Strict (not .Lazy)
    let d = runStateT (fd a)
    in maybe (d s) (\s' -> liftM (second $ Just . fromMaybe s') $ d s') ms
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/llvm-general-3.5.1.2/src/Control/Monad/Trans/AnyCont.hs
Applicative instance: 


instance Applicative (AnyContT m) where
  pure a = AnyContT $ pure a
  f <*> v = AnyContT $ unAnyContT f <*> unAnyContT v
Monad instance: 


instance Monad m => Monad (AnyContT m) where
  AnyContT f >>= k = AnyContT $ f >>= unAnyContT . k
  return a = AnyContT $ return a
  fail s = AnyContT (ContT (\_ -> fail s))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fgl-5.5.3.0/Data/Graph/Inductive/Query/Monad.hs
Applicative instance: 


instance (Monad m) => Applicative (GT m g) where
    pure  = return
    (<*>) = ap
Monad instance: 


instance (Monad m) => Monad (GT m g) where
  return x = MGT (\mg->do {g<-mg; return (x,g)})
  f >>= h  = MGT (\mg->do {(x,g)<-apply f mg; apply' (h x) g})
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/compact-string-fix-0.3.2/test/QuickCheckUtils.hs
Monad instance: 


instance Monad ((->) r) where
    return = const
    f >>= k = \ r -> k (f r) r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/size-based-0.1.0.0/Control/Enumerable/Count.hs
Applicative instance: 


instance Applicative Count where
  pure _ = Count [1]

  (Count [])  <*> (Count _)      = empty
  (Count _)  <*> (Count [])      = empty
  (Count (0:xs)) <*> ys             = pay $ Count xs <*> ys
  xs <*> (Count (0:ys))             = pay $ xs <*> Count ys
  (Count xs0@(_:xs0'))  <*> (Count ys)  = Count $ run (drop 1 $ reversals' ys) where
    mult = conv xs0
    run []     = []
    run (r:rs) = go r rs
    go r rs  = mult r :  case rs of
                           [] -> go' r xs0'
                           (r':rs') -> go r' rs'
    go' r []         = []
    go' r xs@(_:xs') = conv r xs : go' r xs'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/size-based-0.1.0.0/Control/Enumerable/Values.hs
Applicative instance: 


instance Applicative Values where
  pure x     = Values $ \i -> if i == 0 then [x] else []
  fs <*> xs  = fmap (uncurry ($)) (pair fs xs)
Applicative instance: 


instance Applicative MaxSize where
  pure _ = MaxSize [()]
  MaxSize [] <*> _  = empty
  _ <*> MaxSize []  = empty
  f <*> x = MaxSize $ tail (runMaxSize f ++ runMaxSize x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/joinlist-0.3.0/src/Data/JoinList.hs
Monad instance: 


instance Monad JoinList where
  return = Single
  Empty      >>= _ = Empty
  Single a   >>= k = k a
  (t :++: u) >>= k = (concat $ fmap k t) :++: (concat $ fmap k u)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chp-2.2.0.1/Control/Concurrent/CHP/Poison.hs
Monad instance: 


instance Monad WithPoison where
  return = NoPoison
  PoisonItem >>= _ = PoisonItem
  NoPoison x >>= f = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chp-2.2.0.1/Control/Concurrent/CHP/Parallel.hs
Monad instance: 


instance Monad m => Monad (ForkingT m) where
  return = liftForking . return
  m >>= k = Forking $ \tv -> runForkingT m tv >>= (flip runForkingT tv . k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dag-0.1.0.2/src/Data/Graph/DAG/Edge/Utils.hs
Applicative instance: 


instance Applicative RTree where
  pure a = a :@-> []
  (f :@-> fs) <*> (x :@-> xs) = (f x) :@->
    (zipWith (<*>) fs xs)
Monad instance: 


instance Monad RTree where
  return = pure
  (x :@-> xs) >>= f = case f x of -- Substitution based instance.
    (y :@-> ys) -> y :@-> (fmap (>>= f) xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mysnapsession-0.4.1/src/Snap/Dialogues.hs
Monad instance: 


{-
    Dlg is a monad in the obvious way: return represents a dialogue that has no
    steps; and (>>=) combines dialogues by doing the first part of the first
    dialogue, and then continuing with the rest.
-}
instance Monad m => Monad (Dlg m) where
    return         = Done
    Done x   >>= y = y x
    Action x >>= y = Action (x >>= return . (>>= y))
    Step p f >>= y = Step p (f >>= y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/diagrams-hsqml-0.2.0.0/src/Diagrams/Backend/HsQML/DiagramObj/Type.hs
Applicative instance: 


instance Applicative DiagramObj where
   pure a = DiagramObj $ \_ -> return a
   (DiagramObj f') <*> (DiagramObj x') =
     DiagramObj $ \this -> do
        f <- f' this
        x <- x' this
        return $ f x
Monad instance: 


instance Monad DiagramObj where
   return a = DiagramObj $ \_ -> return a
   (DiagramObj a') >>= f' =
      DiagramObj $ \this -> do
        a <- a' this
        let DiagramObj f = f' a
        f this
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-theorems-counterexamples-0.3.1.0/Language/Haskell/FreeTheorems/Variations/CounterExamples/Internal/M.hs
Monad instance: 


instance Monad (M s) where
    return a = M (\s -> [(a,s)])
    M m >>= k = M (\s -> concatMap (\(a,s') -> case k a of M l -> l s') (m s))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/VecN-0.0.2/Data/VecN.hs
Applicative instance: 


instance Applicative (VecN Zero) where
    pure _ = VecZero
    _ <*> _ = VecZero
Applicative instance: 

instance (Applicative (VecN p)) => Applicative (VecN (Succ p)) where
    pure a = a :> pure a
    (f :> fs) <*> (a :> as) = f a :> (fs <*> as)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/niagra-0.2.3/src/Data/Niagra/AccumulatorT.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (AccumulatorT s i m) where
  pure a = AccumulatorT $ \fin fi st i -> return (a, st, i)
  (<*>) = ap
Monad instance: 


instance (Monad m) => Monad (AccumulatorT s i m) where
  fail msg = AccumulatorT $ \_ _ _ _ -> fail msg
  m >>= k = AccumulatorT $ \fin fi st i -> do
    (a, st', i') <- runAccumulatorT m fin fi st i
    runAccumulatorT (k a) fin fi st' i'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wumpus-core-0.52.1/src/Wumpus/Core/OutputSVG.hs
Applicative instance: 


instance Applicative SvgMonad where
  pure a    = SvgMonad $ \_ s -> (a,s)
  mf <*> ma = SvgMonad $ \r s -> let (f,s1) = getSvgMonad mf r s
                                     (a,s2) = getSvgMonad ma r s1
                                 in (f a, s2)
Monad instance: 


instance Monad SvgMonad where
  return a  = SvgMonad $ \_ s -> (a,s)
  m >>= k   = SvgMonad $ \r s -> let (a,s1) = getSvgMonad m r s
                                 in (getSvgMonad . k) a r s1
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wumpus-core-0.52.1/src/Wumpus/Core/OutputPostScript.hs
Applicative instance: 


instance Applicative PsMonad where
  pure a    = PsMonad $ \s -> (a,s)
  mf <*> ma = PsMonad $ \s -> let (f,s1) = getPsMonad mf s
                                  (a,s2) = getPsMonad ma s1
                                in (f a,s2)
Monad instance: 


instance Monad PsMonad where
  return a  = PsMonad $ \s -> (a,s)
  m >>= k   = PsMonad $ \s -> let (a,s1) = getPsMonad m s
                              in (getPsMonad . k) a s1
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/env-parser-0.0.2.1/src/System/Environment/Parser/Miss.hs
Applicative instance: 


instance Monoid e => Applicative (Miss e) where
  pure = Got
  Miss e1 <*> Miss e2 = Miss (e1 <> e2)
  Miss e1 <*> _       = Miss e1
  _       <*> Miss e2 = Miss e2
  Got f   <*> Got x   = Got  (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/env-parser-0.0.2.1/src/System/Environment/Parser.hs
Applicative instance: 


instance Applicative Df where
  pure _ = Df Succeeding
  Df (Branching dfs) <*> Df (Branching dxs) = Df (Branching $ dfs <> dxs)
  Df (Branching dfs) <*> Df dx              = Df (Branching $ dfs |> dx)
  Df df              <*> Df (Branching dxs) = Df (Branching $ df <| dxs)
  Df df              <*> Df dx              = Df (Branching $ Seq.fromList [df, dx])
Applicative instance: 


instance Applicative Parser where
  pure a = Parser (pure a) (pure a) (pure a)
  Parser f1 f2 f3 <*> Parser x1 x2 x3 =
    Parser (f1 <*> x1) (f2 <*> x2) (f3 <*> x3)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/present-4.0.2/src/Control/Monad/Trans/State/Strict.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (StateT s m) where
    pure a = StateT $ \ s -> return (a, s)
    StateT mf <*> StateT mx = StateT $ \ s -> do
        (f, s') <- mf s
        (x, s'') <- mx s'
        return (f x, s'')
    {-# INLINE (<*>) #-}
Monad instance: 


instance (Monad m) => Monad (StateT s m) where
    return a = StateT $ \ s -> return (a, s)
    m >>= k  = StateT $ \ s -> do
        (a, s') <- runStateT m s
        runStateT (k a) s'
    fail str = StateT $ \ _ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/JYU-Utils-0.1.1.2/Utils/Stream.hs
Applicative instance: 


instance (Monad m) => Applicative (Stream m) where
    pure f  = repeatS f
    Terminated <*> _ = Terminated
    _ <*> Terminated = Terminated
    (Value a) <*> (Value b) = Value renext
      where
      renext = do
        (fun,anext) <- a
        (br,bnext)  <- b
        return (fun br,anext<*>bnext)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pontarius-xmpp-0.5.2/source/Network/Xmpp/Lens.hs
Applicative instance: 


instance Applicative (Collect a) where
    pure _ = Collect []
    Collect xs <*> Collect ys = Collect $ xs ++ ys
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rsagl-frp-0.6.0.1/RSAGL/FRP/FRP.hs
Applicative instance: 


instance Applicative (FRP e m j) where
    pure a = proc _ -> returnA -< a
    f <*> s = proc i ->
        do s' <- s -< i
           f' <- f -< i
           returnA -< f' s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hoq-0.3/src/TypeChecking/Monad/Warn.hs
Applicative instance: 


instance (Monoid w, Applicative m) => Applicative (WarnT w m) where
    pure a = WarnT $ pure (mempty, Just a)
    WarnT f <*> WarnT a = WarnT $ (\(w1, mf) (w2, ma) -> (w1 `mappend` w2, mf <*> ma)) <$> f <*> a
Monad instance: 


instance (Monoid w, Monad m) => Monad (WarnT w m) where
    return a      = WarnT $ return (mempty, Just a)
    WarnT m >>= k = WarnT $ m >>= \(w, ma) -> case ma of
        Nothing -> return (w, Nothing)
        Just a  -> do
            (w', mb) <- runWarnT (k a)
            return (w `mappend` w', mb)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hoq-0.3/src/Syntax/Term.hs
Applicative instance: 


instance Applicative (Term p) where
    pure    = cvar
    (<*>)   = ap
Monad instance: 


instance Monad (Term p) where
    return           = cvar
    Var a ts   >>= k = apps (k a) $ map (>>= k) ts
    Apply p ts >>= k = Apply p $ map (>>= k) ts
    Lambda s   >>= k = Lambda $ s >>= \v -> case v of
        Free a -> fmap Free (k a)
        Bound  -> return Bound
Applicative instance: 


instance Applicative Scoped where
    pure = Free
    Bound <*> _ = Bound
    _ <*> Bound = Bound
    Free f <*> Free a = Free (f a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ajhc-0.8.0.9/lib/jhc/Jhc/Maybe.hs
Monad instance: 


instance Monad Maybe where
    return x = Just x
    Nothing >>= _ = Nothing
    Just x >>= y = y x
    fail _ = Nothing
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ajhc-0.8.0.9/lib/applicative/Control/Applicative.hs
Applicative instance: 


-- instances for Prelude types

instance Applicative Maybe where
        pure = return
        (<*>) = ap
Applicative instance: 


instance Applicative [] where
        pure = return
        (<*>) = ap
Applicative instance: 


instance Applicative IO where
        pure = return
        (<*>) = ap
Applicative instance: 


instance Applicative ((->) a) where
        pure = const
        (<*>) f g x = f x (g x)
Applicative instance: 


instance Monoid a => Applicative ((,) a) where
        pure x = (mempty, x)
        (u, f) <*> (v, x) = (u `mappend` v, f x)
Applicative instance: 


instance Monoid m => Applicative (Const m) where
        pure _ = Const mempty
        Const f <*> Const v = Const (f `mappend` v)
Applicative instance: 


instance Monad m => Applicative (WrappedMonad m) where
        pure = WrapMonad . return
        WrapMonad f <*> WrapMonad v = WrapMonad (f `ap` v)
Applicative instance: 


instance Arrow a => Applicative (WrappedArrow a b) where
        pure x = WrapArrow (arr (const x))
        WrapArrow f <*> WrapArrow v = WrapArrow (f &&& v >>> arr (uncurry id))
Applicative instance: 


instance Applicative ZipList where
        pure x = ZipList (repeat x)
        ZipList fs <*> ZipList xs = ZipList (zipWith id fs xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ajhc-0.8.0.9/lib/applicative/Control/Arrow.hs
Monad instance: 


instance ArrowApply a => Monad (ArrowMonad a) where
        return x = ArrowMonad (arr (\z -> x))
        ArrowMonad m >>= f = ArrowMonad (m >>>
                        arr (\x -> let ArrowMonad h = f x in (h, ())) >>>
                        app)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ajhc-0.8.0.9/lib/applicative/Data/Traversable.hs
Applicative instance: 


instance Applicative (StateL s) where
        pure x = StateL (\ s -> (s, x))
        StateL kf <*> StateL kv = StateL $ \ s ->
                let (s', f) = kf s
                    (s'', v) = kv s'
                in (s'', f v)
Applicative instance: 


instance Applicative (StateR s) where
        pure x = StateR (\ s -> (s, x))
        StateR kf <*> StateR kv = StateR $ \ s ->
                let (s', v) = kv s
                    (s'', f) = kf s'
                in (s'', f v)
Applicative instance: 


instance Applicative Id where
        pure = Id
        Id f <*> Id x = Id (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ajhc-0.8.0.9/lib/haskell-extras/Control/Monad/Instances.hs
Monad instance: 


instance Monad ((->) r) where
        return = const
        f >>= k = \ r -> k (f r) r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ajhc-0.8.0.9/src/Stats.hs
Monad instance: 


instance Monad StatM where
    StatM _ s1 >> StatM y s2 = StatM y (s1 `mappend` s2)
    return x = StatM x mempty
    StatM x s1 >>= y = case y x of StatM z s2 -> StatM z (s1 `mappend` s2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ajhc-0.8.0.9/src/FindFixpoint.hs
Monad instance: 


instance Monad (Ms b) where
    return a = Ms' (\_ -> return a)
    Ms' comp >>= fun
        = Ms' (\v  -> comp v >>= \r -> case fun r   of Ms' x -> x v)
    Ms' a >> Ms' b = Ms' $ \v -> a v >> b v
    fail x = Ms' (\_ -> (putErrDie x))
    {-# INLINE (>>) #-}
    {-# INLINE (>>=) #-}
    {-# INLINE return #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ajhc-0.8.0.9/src/FrontEnd/ParseMonad.hs
Applicative instance: 


instance A.Applicative ParseResult where
  pure = ParseOk
  ParseOk f <*> x = f <$> x
  ParseFailed loc msg <*> _ = ParseFailed loc msg
Monad instance: 


instance Monad ParseResult where
  return = A.pure
  ParseOk x         >>= f = f x
  ParseFailed loc msg >>= _ = ParseFailed loc msg
Monad instance: 


instance Monad P where
        return a = P $ \_i _x _y _l s _m -> Ok s a
        P m >>= k = P $ \i x y l s mode ->
                case m i x y l s mode of
                    Failed loc msg -> Failed loc msg
                    Ok s' a -> runP (k a) i x y l s' mode
        fail s = P $ \_r _col _line loc _stk _m -> Failed loc s
Monad instance: 


instance Monad (Lex r) where
        return a = Lex $ \k -> k a
        Lex v >>= f = Lex $ \k -> v (\a -> runL (f a) k)
        Lex v >> Lex w = Lex $ \k -> v (\_ -> w k)
        fail s = Lex $ \_ -> fail s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ajhc-0.8.0.9/src/FrontEnd/HsPretty.hs
Monad instance: 


instance Monad (DocM s) where
        (>>=) = thenDocM
        (>>) = then_DocM
        return = retDocM
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ajhc-0.8.0.9/src/FrontEnd/Rename.hs
Applicative instance: 


instance Applicative RM where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ajhc-0.8.0.9/src/FrontEnd/Tc/Monad.hs
Monad instance: 


{-
elimBox :: MetaVar -> Tc Type
elimBox mv | isBoxyMetaVar mv = do
    t <- readMetaVar mv
    case t of
        Just t -> return t
        Nothing -> newMetaVar Tau (getType mv)

elimBox mv = error $ "elimBox: nonboxy" ++ show mv
-}

----------------------------------------
-- Declaration of instances, boilerplate
----------------------------------------

--pretty :: PPrint Doc a => a -> String
--pretty x = show (pprint x :: Doc)

instance Monad Tc where
    return a = Tc $ return a
    Tc comp >>= fun = Tc $ do x <- comp; case fun x of Tc m -> m
    Tc a >> Tc b = Tc $ a >> b
    fail s = Tc $ do
        st <- ask
        liftIO $ processIOErrors
        Left x <- typeError (Failure s) (tcDiagnostics st)
        liftIO $ fail x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ajhc-0.8.0.9/src/Util/ReaderWriter.hs
Monad instance: 


instance (Monoid w) => Monad (ReaderWriter r w) where
        return a = ReaderWriter $ \_ -> (# a, mempty #)
        (ReaderWriter m) >>= k  = ReaderWriter $ \r -> case m r of
            (# a,w #) -> case k a of
                ReaderWriter g -> case g r of
                    (# b, w' #) -> let w'' = w `mappend` w' in w'' `seq` (# b, w'' #)
        (ReaderWriter f) >> (ReaderWriter g) = ReaderWriter $ \r -> case f r of
            (# _, w #) -> case g r of
                (# a, w' #) -> let w'' = w `mappend` w' in w'' `seq` (# a, w'' #)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ajhc-0.8.0.9/src/Util/Seq.hs
Monad instance: 


instance Monad Util.Seq.Seq where
    --a >>= b  = mconcat ( fmap b (Seq.toList a))
    a >>= b  = Util.Seq.concat (fmap b a)
    return x = Util.Seq.single x
    fail _ = Util.Seq.empty
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ajhc-0.8.0.9/src/Util/ContextMonad.hs
Monad instance: 


instance Monad ContextEither where
    fail s = ContextEither (Left [s])
    ContextEither x >>= y = case x of
        Left ss -> ContextEither (Left ss)
        Right v -> y v
    return x = ContextEither (Right x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fast-tags-1.2/src/Control/Monad/EitherK.hs
Applicative instance: 


instance Applicative (EitherKT e m) where
    pure x = EitherKT $ \_ sk -> sk x
    EitherKT f <*> EitherKT g = EitherKT $
        \ek sk -> f ek (\h -> g ek (\x -> sk $ h x))
Monad instance: 


instance Monad (EitherKT e m) where
    return = pure
    EitherKT f >>= m = EitherKT $ \ek sk ->
        f ek (\x -> runEitherKT (m x) ek sk)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/polyparse-1.9/src/Text/ParserCombinators/HuttonMeijer.hs
Monad instance: 


instance Monad Parser where
   -- return      :: a -> Parser a
   return v        = P (\inp -> [(v,inp)])

   -- >>=         :: Parser a -> (a -> Parser b) -> Parser b
   (P p) >>= f     = P (\inp -> concat [papply (f v) out | (v,out) <- p inp])

   -- fail        :: String -> Parser a
   fail _          = P (\_ -> [])
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/polyparse-1.9/src/Text/ParserCombinators/HuttonMeijerWallace.hs
Monad instance: 


instance Monad (Parser s t e) where
   -- return      :: a -> Parser s t e a
   return v        = P (\st inp -> Right [(v,st,inp)])
   -- >>=         :: Parser s t e a -> (a -> Parser s t e b) -> Parser s t e b
   (P p) >>= f     = P (\st inp -> case p st inp of
                        Right res -> foldr joinresults (Right [])
                            [ papply' (f v) s out | (v,s,out) <- res ]
                        Left err  -> Left err
                       )
   -- fail        :: String -> Parser s t e a
   fail err        = P (\st inp -> Right [])
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/polyparse-1.9/src/Text/ParserCombinators/Poly/Parser.hs
Monad instance: 


instance Monad (Parser t) where
    return x     = P (\ts-> Success ts x)
    fail e       = P (\ts-> Failure ts e)
    (P f) >>= g  = P (continue . f)
      where
        continue (Success ts x)             = let (P g') = g x in g' ts
        continue (Committed r)              = Committed (continue r)
        continue (Failure ts e)             = Failure ts e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/polyparse-1.9/src/Text/ParserCombinators/Poly/StateParser.hs
Monad instance: 


instance Monad (Parser s t) where
    return x     = P (\s ts-> Success (ts,s) x)
    fail e       = P (\s ts-> Failure (ts,s) e)
    (P f) >>= g  = P (\s-> continue . f s)
      where
        continue (Success (ts,s) x)        = let (P g') = g x in g' s ts
        continue (Committed r)             = Committed (continue r)
        continue (Failure tss e)           = Failure tss e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/polyparse-1.9/src/Text/ParserCombinators/Poly/Lazy.hs
Applicative instance: 


instance Applicative (Parser t) where
    pure f    = return f
    --   Apply a parsed function to a parsed value.  This version
    --   is strict in the result of the function parser, but
    --   lazy in the result of the argument parser.  (Argument laziness is
    --   the distinctive feature over other implementations.)
    (P (P.P pf)) <*> px = P (P.P (continue . pf))
      where
        continue (Success z f)  = let (x,z') = runParser px z
                                  in Success z' (f x)
        continue (Committed r)  = Committed (continue r)
        continue (Failure z e)  = Failure z e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/polyparse-1.9/src/Text/ParserCombinators/Poly/StateLazy.hs
Applicative instance: 



instance Applicative (Parser s t) where
    pure f    = return f
    --   Apply a parsed function to a parsed value.  This version
    --   is strict in the result of the function parser, but
    --   lazy in the result of the argument parser.  (Argument laziness is
    --   the distinctive feature over other implementations.)
    (P (P.P pf)) <*> px = P (P.P (\s-> continue . pf s))
      where
        continue (Success (z,s) f) = let (x,s',z') = runParser px s z
                                     in Success (z',s') (f x)
        continue (Failure zs e)    = Failure zs e
        continue (Committed r)     = Committed (continue r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/yesod-pure-0.1.0.2/Yesod/Pure/NoRoute.hs
Applicative instance: 

instance Applicative NoRouteDispatch where
    pure = NoRouteDispatch (\_ _ -> Nothing) . Just
    NoRouteDispatch a f <*> NoRouteDispatch b x =
        NoRouteDispatch (\m p -> a m p <|> b m p) (f <*> x)
Monad instance: 


-- | I'm not convinced this instance is correct, for now consider it a dummy
-- placeholder for playing around with do-syntax.
instance Monad NoRouteDispatch where
    return = pure
    NoRouteDispatch f Nothing >>= _ = NoRouteDispatch f Nothing
    NoRouteDispatch a (Just x) >>= f = NoRouteDispatch a (Just ()) *> f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/svgutils-0.1/Data/SVG/Internal/Fail.hs
Monad instance: 


instance Monad FailM where
  return = OK
  fail = Fail
  (>>=) (Fail x) _ = Fail x
  (>>=) (OK x) f = f x
Applicative instance: 


instance Applicative FailM where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/agda-server-0.1.1/JSDict.hs
Monad instance: 


instance Monad (JSM ()) where
    return = Ret
    (>>=) = Bind
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CoreErlang-0.0.3/Language/CoreErlang/Pretty.hs
Applicative instance: 


instance Applicative (DocM s) where
         pure        = return
         (<*>) m1 m2 = do x1 <- m1; x2 <- m2; return (x1 x2)
Monad instance: 


instance Monad (DocM s) where
         (>>=) = thenDocM
         (>>) = then_DocM
         return = retDocM
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gtk2hs-buildtools-0.9/c2hs/base/state/StateTrans.hs
Monad instance: 


instance Monad (STB bs gs) where
  return = yield
  (>>=)  = (+>=)
  (>>)   = (+>)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gtk2hs-buildtools-0.9/c2hs/base/state/StateBase.hs
Monad instance: 


instance Monad (PreCST e s) where
  return = yield
  (>>=)  = (+>=)
  (>>)   = (+>)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gtk2hs-buildtools-0.9/c2hs/c/CParserMonad.hs
Monad instance: 


instance Monad P where
  return = returnP
  (>>=) = thenP
  fail m = getPos >>= \pos -> failP pos [m]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reasonable-lens-0.2.1.1/src/Control/Lens/Getter.hs
Applicative instance: 


instance Monoid r => Applicative (Accessor r) where
  pure _ = Accessor mempty
  {-# INLINE pure #-}
  Accessor a <*> Accessor b = Accessor (mappend a b)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reasonable-lens-0.2.1.1/src/Control/Lens/Setter.hs
Applicative instance: 


instance Applicative Mutator where
  pure = Mutator
  {-# INLINE pure #-}
  Mutator f <*> Mutator a = Mutator (f a)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/picoparsec-0.1.2.3/Data/Picoparsec/Zepto.hs
Monad instance: 


instance Monad (Parser t) where
    return a = Parser $ \s -> (# OK a, s #)
    {-# INLINE return #-}

    m >>= k   = Parser $ \s -> case runParser m s of
                                 (# OK a, s' #) -> runParser (k a) s'
                                 (# Fail err, s' #) -> (# Fail err, s' #)
    {-# INLINE (>>=) #-}

    fail msg = Parser $ \s -> (# Fail msg, s #)
Applicative instance: 


instance Applicative (Parser t) where
    pure   = return
    {-# INLINE pure #-}
    (<*>)  = ap
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/picoparsec-0.1.2.3/Data/Picoparsec/Internal/Types.hs
Monad instance: 


instance Monad (Parser t) where
    return = returnP
    (>>=)  = bindP
    fail   = failDesc
Applicative instance: 


instance Applicative (Parser i) where
    pure   = return
    {-# INLINE pure #-}
    (<*>)  = apP
    {-# INLINE (<*>) #-}

    -- These definitions are equal to the defaults, but this
    -- way the optimizer doesn't have to work so hard to figure
    -- that out.
    (*>)   = (>>)
    {-# INLINE (*>) #-}
    x <* y = x >>= \a -> y >> return a
    {-# INLINE (<*) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/xml-conduit-1.3.5/Text/XML/Stream/Parse.hs
Monad instance: 


instance Monad AttrParser where
    return a = AttrParser $ \as -> Right (as, a)
    (AttrParser f) >>= g = AttrParser $ \as ->
        either Left (\(as', f') -> runAttrParser (g f') as') (f as)
Applicative instance: 

instance Applicative AttrParser where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ProxN-0.0.1/src/Data/ProxN/Tree2N.hs
Applicative instance: 


instance (Tree2NClass n) => Applicative (Tree2N n) where
  pure a = Tree2NBranch a (pure Tree2NLeaf)
  Tree2NLeaf <*> _ = Tree2NLeaf
  _ <*> Tree2NLeaf = Tree2NLeaf
  (Tree2NBranch f tf) <*> (Tree2NBranch a ta) = Tree2NBranch (f a) (fmap (<*>) tf <*> ta)
Applicative instance: 


instance Applicative (Treed P.Zero) where
  pure = TreeNil
  (TreeNil f) <*> (TreeNil a) = TreeNil (f a)
Applicative instance: 


instance (Applicative (Treed n)) => Applicative (Treed (P.Succ n)) where
  pure a = pure a :/\: pure a
  (f1 :/\: f2) <*> (a :/\: b) = (f1 <*> a) :/\: (f2 <*> b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ProxN-0.0.1/src/Data/ProxN/VecN.hs
Applicative instance: 


instance Applicative (VecN P.Zero) where
  pure _ = VecNil
  (<*>) _ _ = VecNil
Applicative instance: 


instance (Applicative (VecN n)) => Applicative (VecN (P.Succ n)) where
  pure a = a :<: pure a
  (f :<: v1) <*> (a :<: v2) = f a :<: (v1 <*> v2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/alex-meta-0.3.0.8/src/ParseMonad.hs
Monad instance: 


instance Monad P where
 (P m) >>= k = P $ \env -> case m env of
                        Left err -> Left err
                        Right (env',ok) -> unP (k ok) env'
 return a = P $ \env -> Right (env,a)
Applicative instance: 


instance Applicative P where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/alex-meta-0.3.0.8/src/NFA.hs
Monad instance: 


instance Monad NFAM where
  return a = N $ \s n e -> (s,n,a)

  m >>= k  = N $ \s n e -> case unN m s n e of
                                 (s', n', a) -> unN (k a) s' n' e
Applicative instance: 


instance Applicative NFAM where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dialog-0.3.0.0/library/Dialog/Internal.hs
Applicative instance: 


instance Applicative (DialogT m) where
  pure = Pure
  (<*>) = ap
Monad instance: 


instance Monad (DialogT m) where
  actionA >>= makeActionB = Bind (\func -> func actionA makeActionB)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/functor-combo-0.3.6/src/FunctorCombo/StrictMemo.hs
Applicative instance: 


instance (Applicative (Trie k), IsNat n) => Applicative (TrieTree n k) where
  pure = pureV nat
  (<*>) = apV nat
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/functor-combo-0.3.6/src/FunctorCombo/Functor.hs
Applicative instance: 



-- What about Applicative instances?  I think Void could implement (<*>)
-- but not pure.  Hm.  Id and (:*:) are easy, while (:+:) is problematic.

-- instance Applicative Id where
--   pure a = Id a
--   Id f <*> Id x = Id (f x)

-- instance Applicative Id where
--   pure  = Id
--   (<*>) = inId2 ($)

instance (Applicative f, Applicative g) => Applicative (f :*: g) where
  pure a = pure a :*: pure a
  (f :*: g) <*> (a :*: b) = (f <*> a) :*: (g <*> b)
Monad instance: 


instance (Functor f, Functor g, Monad f, Monad g) =>
         Monad (f :*: g) where
  return a = return a :*: return a
  m >>= k = joinP (k <$> m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/functor-combo-0.3.6/src/FunctorCombo/Pair.hs
Applicative instance: 


instance Applicative Pair where
  pure a = a :# a
  (f :# g) <*> (a :# b) = (f a :# g b)
Monad instance: 


instance Monad Pair where
  return = pure
  m >>= f = joinP (f <$> m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pipes-key-value-csv-0.4.0.0/src/Data/Validation.hs
Applicative instance: 


instance Semigroup e => Applicative (Validation e) where
  pure = Success
  (<*>) = app
    where
      app (Success f) (Success a) = Success (f a)
      app (Failure e) (Success _) = Failure e
      app (Success _) (Failure e) = Failure e
      app (Failure e1) (Failure e2) = Failure (e1 <> e2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-products-4.0.1/Control/Monad/Product.hs
Applicative instance: 


instance (Applicative g, Applicative h) => Applicative (Product g h) where
  pure a = Product (pure a, pure a)
  Product (gf, hf) <*> Product (ga, ha) = Product (gf <*> ga, hf <*> ha)
  Product (gf, hf) <*  Product (ga, ha) = Product (gf <*  ga, hf <*  ha)
  Product (gf, hf)  *> Product (ga, ha) = Product (gf  *> ga, hf  *> ha)
Monad instance: 


instance (Monad g, Monad h) => Monad (Product g h) where
  return a = Product (return a, return a)
  Product (g, h) >>= k = Product (g >>= fst . runProduct . k, h >>= snd . runProduct . k)
  Product (ga, ha) >> Product (gb, hb) = Product (ga >> gb, ha >> hb)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/formlets-0.8/Text/Formlets.hs
Applicative instance: 


instance (Monad m, Applicative m, Monoid xml) => Applicative (Form xml m) where
   pure = pureF
   (<*>) = applyF
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/formlets-0.8/Text/Formlets/FormResult.hs
Applicative instance: 
 -- DEBUG

instance Applicative FormResult where
   pure = Success
   Failure msgs <*> Failure msgs' = Failure (msgs ++ msgs')
   Success _ <*> Failure msgs' = Failure msgs'
   Failure msgs' <*> Success _ = Failure msgs'
   Success f <*> Success x = Success (f x)
   NotAvailable x <*> _ = NotAvailable x
   _ <*> NotAvailable x = NotAvailable x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unfoldable-0.8.4/src/Data/Unfolder.hs
Applicative instance: 


instance Applicative f => Applicative (BFS f) where
  pure = packBFS . pure
  BFS ff <*> BFS fx = BFS $ \(d, split) -> flattenBFS $
    [ liftA2 (liftA2 (<*>)) (ff (i, split)) (fx (j, split)) | (i, j) <- split d ]
Applicative instance: 


instance Applicative Arb where
  pure = Arb 0 . pure . pure
  Arb i1 ff <*> Arb i2 fx = Arb (i1 + i2) $ liftA2 (<*>) ff fx
Applicative instance: 

instance Num a => Applicative (NumConst a) where
  pure _ = NumConst 1
  NumConst a <*> NumConst b = NumConst $ a * b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fixplate-0.1.6/Data/Generics/Fixplate/Misc.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (StateT s m) where
  pure  = return
  (<*>) = ap
Monad instance: 


instance (Monad m) => Monad (StateT s m) where
  return a = state $ \s -> (a, s)
  m >>= k  = StateT $ \s -> do
    ~(a, s') <- runStateT m s
    runStateT (k a) s'
  fail str = StateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fixplate-0.1.6/Data/Generics/Fixplate/Base.hs
Applicative instance: 


instance Functor f => Applicative (CoAttrib f) where
  pure x = CoAttrib (Fix (Pure x))
  (<*>)  = ap
Monad instance: 


instance Functor f => Monad (CoAttrib f) where
  return x = CoAttrib (Fix (Pure x))
  CoAttrib (Fix (CoAnn t))  >>=  u  =  CoAttrib (Fix (CoAnn (fmap (unCoAttrib . (>>=u) . CoAttrib) t)))
  CoAttrib (Fix (Pure  x))  >>=  u  =  u x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/oi-0.4.0.2/src/Data/OI/Internal.hs
Applicative instance: 


instance Applicative OI where
  pure = (##)
  f <*> g = ((f ??) (g ??) ##)
Monad instance: 


instance Monad OI where
  return = (##)
  (>>=)  = flip ($) . (??)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hip-1.0.1.2/src/Graphics/Image/ColorSpace/Gray.hs
Monad instance: 



instance Monad (Pixel Gray) where

  return = PixelGray
  {-# INLINE return #-}

  (>>=) (PixelGray g) f = f g
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hip-1.0.1.2/src/Graphics/Image/ColorSpace/Luma.hs
Monad instance: 



instance Monad (Pixel Y) where

  return = PixelY
  {-# INLINE return #-}

  (>>=) (PixelY y) f = f y
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hub-1.9.0.1/Hub/Poss.hs
Monad instance: 

instance Monad (Poss e) where
    (>>=) ps f = poss NOPE f ps
    return     = YUP
Applicative instance: 


instance Applicative (Poss e) where
        (<*>) ps ps' = do f <- ps; x<-ps'; return $ f x
        pure         = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Deadpan-DDP-0.9.6.0/src/Web/DDP/Deadpan/DSL.hs
Monad instance: 


instance Monad DeadpanApp where
  return  = DeadpanApp . return
  s >>= f = DeadpanApp $ _deadpanApp s >>= _deadpanApp . f
Applicative instance: 


instance Applicative DeadpanApp where
  pure = DeadpanApp . pure
  (DeadpanApp f) <*> (DeadpanApp m) = DeadpanApp (f <*> m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/numeric-prelude-0.4.2/src/Algebra/AffineSpace.hs
Applicative instance: 


instance Applicative (MAC a v) where
   {-# INLINE pure #-}
   {-# INLINE (<*>) #-}
   pure x = MAC $ \ _av _v -> x
   MAC f <*> MAC x =
      MAC $ \av v -> f av v $ x av v
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/numeric-prelude-0.4.2/src/Number/ResidueClass/Reader.hs
Applicative instance: 


instance Applicative (T a) where
   (<*>) = ap
   pure = return
Monad instance: 


instance Monad (T a) where
   (Cons x) >>= y  =  Cons (\r -> toFunc (y (x r)) r)
   return = Cons . const
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/numeric-prelude-0.4.2/src/Number/Physical.hs
Applicative instance: 


instance Applicative (T a) where
   (<*>) = ap
   pure = return
Monad instance: 


instance Monad (T i) where
  (>>=) (Cons xu x) f =
    if Unit.isScalar xu
    then f x
    else error "Physics.Quantity.Value.(>>=): function for scalars, only"
  return = fromScalarSingle
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/numeric-prelude-0.4.2/src/NumericPrelude/Elementwise.hs
Applicative instance: 


instance Applicative (T v) where
   {-# INLINE pure #-}
   {-# INLINE (<*>) #-}
   pure = with
   Cons f <*> Cons e =
      Cons $ \v -> f v $ e v
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/x-dsp-0.2.3.1/tools/CsoundImplTemplate.hs
Applicative instance: 


instance Applicative (SDelay n) where
  pure = SDelay . pure
  (SDelay a) <*> (SDelay b) = SDelay (a <*> b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/x-dsp-0.2.3.1/src/Language/XDsp/Implementations/Csound.hs
Applicative instance: 


instance Applicative (SDelay n) where
  pure = SDelay . pure
  (SDelay a) <*> (SDelay b) = SDelay (a <*> b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tracer-0.1/Debug/Tracer.hs
Applicative instance: 


-- |
-- Provides sequencing with tracing ('<*>', '*>' and '<*').

instance (Applicative m, Pos p) => Applicative (TracerT p m) where
  -- pure :: a -> m a
  pure x                      = TracerT $ seq x $ \l -> pure (x, pstep l)

  -- (<*>) :: f (a -> b) -> f a -> f b
  (TracerT f) <*> (TracerT x) = TracerT $ seq (seq f x) $ \l ->
        let fnext                   = f (ppush l)          -- :: m (a -> b, p)

            trans (f', l') (x',l'') = (f' x', ppop l' (pstep l''))
                                                           -- :: (a->b,p) -> ((a,p)->(b,p))

            fenc                    = fmap trans fnext     -- :: m ((a,p)->(b,p))

            xnext                   = x (ppush l)          -- :: m (a, p)
        in  fenc <*> xnext
Monad instance: 


-- |
-- Provides do-notation with tracing.

instance (Monad m, Pos p) => Monad (TracerT p m) where
  return x          = TracerT $ seq x $ \p -> return (x, (pstep p))
  (TracerT x) >>= f = TracerT $         \p -> do
                                              (v, p') <- x (pstep p)
                                              (TracerT x') <- return $ f v
                                              x'  (pstep p')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/allocated-processor-0.0.2/src/Control/Processor.hs
Applicative instance: 


instance Monad m => Applicative (Processor m a) where
  -- | 
  -- > [[ pure ]] = const
  pure b = processor pf af cf rf
    where pf _ = return
          af _ = return ()
          cf _ = return b
          rf _ = return ()

  -- |
  -- [[ pf <*> px ]] = \a -> ([[ pf ]] a) ([[ px ]] a)
  -- (same as '(<*>)' on functions)
  (<*>) (Processor pf af cf rf) (Processor px ax cx rx) = processor py ay cy ry
    where py a (stateF, stateX) = do
            f' <- pf a stateF
            x' <- px a stateX
            return (f', x')

          ay a = do
            stateF <- af a
            stateX <- ax a
            return (stateF, stateX)

          -- this is the only part that seems specific to <*>
          cy (stateF, stateX) = do
            b2c <- cf stateF
            b <- cx stateX
            return (b2c b)

          ry (stateF, stateX) = do
            rx stateX
            rf stateF
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Nomyx-Rules-0.1.0/src/Language/Nomyx/Expression.hs
Monad instance: 


instance Monad Exp where
   return = Const
   (>>=) = Bind
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/AFSM-0.1.3.1/src/Control/AFSM/Event.hs
Applicative instance: 


instance Applicative Event where
  pure a = Event a
  (<*>) (Event f) m = fmap f m
  (<*>) (ErrEvent s0) (ErrEvent s1) = ErrEvent $ s0 ++ "," ++ s1
  (<*>) (ErrEvent s0) _ = ErrEvent s0
  (<*>) ExitEvent _ = ExitEvent
  (<*>) NoEvent _ = NoEvent
Monad instance: 


instance Monad Event where
  return = pure
  (>>=) (Event a) f = f a
  (>>=) NoEvent _ = NoEvent
  (>>=) (ErrEvent s) _ = (ErrEvent s)
  (>>=) ExitEvent _ = ExitEvent
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fst-0.9.0.1/FST/StateMonad.hs
Monad instance: 


instance Monad STM where
 return   x       = STM(\s -> (x,s))
 (STM m) >>=  f   = STM(\s -> let (a,s1) = m s in
                          unSTM (f a) s1)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/var-0.2.0.0/src/Control/Monad/Prim.hs
Applicative instance: 


instance Applicative (Prim s) where
  pure a = Prim $ \ s -> (# s, a #)
  {-# INLINE pure #-}
  f <*> a = Prim $ \ s -> case unPrim f s of
    (# s', f' #) -> case unPrim a s' of
      (# s'', a' #) -> (# s'', f' a' #)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad (Prim s) where
  return a = Prim $ \ s -> (# s, a #)
  {-# INLINE return #-}
  m >>= k = Prim $ \ s -> case unPrim m s of
    (# s', a #) -> unPrim (k a) s'
  {-# INLINE (>>=) #-}
  m >> n = Prim $ \ s -> case unPrim m s of
    (# s', _ #) -> unPrim n s'
  {-# INLINE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HAppS-State-0.9.3/src/HAppS/State/Monad.hs
Monad instance: 


{-
instance (Monad (m STM), MonadTrans m) => Monad (Ev (m STM)) where
    return x = Ev $ return x
    fail x   = unsafeIOToEv (logM "HAppS.State.Monad" CRITICAL ("Ev failure: "++x)) >> Ev (fail x)
    ev >>= f = Ev $ unEv ev >>= unEv . f
-}
instance (Monad m) => Monad (Ev m) where
    return x = Ev $ \_ -> return x
    fail x   = Ev $ \_ -> fail x
    ev >>= f = Ev $ \env -> unEv ev env >>= \x -> unEv (f x) env
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/xournal-types-0.5.1.0/src/Data/Xournal/Select.hs
Applicative instance: 


-- |
instance Applicative SeqZipper where
  pure = singletonSZ
  SZ (f,(f1s,f2s)) <*> SZ (x,(y1s,y2s)) = SZ (f x, (zipWith id f1s y1s, zipWith id f2s y2s))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rope-0.6.4/Data/Rope/Annotation/Product.hs
Applicative instance: 


instance (Applicative f, Applicative g) => Applicative (f :*: g) where
    pure a = pure a :*: pure a
    (f :*: g) <*> (a :*: b) = (f <*> a) :*: (g <*> b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rope-0.6.4/Data/Rope/Branded.hs
Applicative instance: 


instance Monoid t => Applicative (Branded Unsafe t) where
    pure = Branded mempty
    Branded s f <*> Branded s' a = Branded (s `mappend` s') (f a)
Monad instance: 


instance Monoid t => Monad (Branded Unsafe t) where
    return = Branded mempty
    Branded s a >>= f = Branded (s `mappend` s') b
        where Branded s' b = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pseudo-trie-0.0.4.3/src/Data/Trie/Rooted.hs
Applicative instance: 


-- | Intersection instance
instance (Eq t) => Applicative (Rooted t) where
  pure x = Rooted (Just x) []
  (<*>) (Rooted mf fs) (Rooted mx xs) =
    Rooted (mf <*> mx)
      [intersectionWith ($) f x | f <- fs, x <- xs]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/special-functors-1.0.0.1/Data/Traversable.hs
Applicative instance: 


instance Applicative Id where
        pure = Id
        Id f <*> Id x = Id (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mezzolens-0.0.0/src/Mezzolens/Unchecked.hs
Applicative instance: 


instance Applicative (FreeApplicativePStore i j) where
  pure x = FreeApplicativePStore $ const (pure x)
  FreeApplicativePStore f <*> FreeApplicativePStore x = FreeApplicativePStore $ \op -> (f op) <*> (x op)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/grammar-combinators-0.2.7/Text/GrammarCombinators/Parser/TopDown.hs
Monad instance: 


instance Monad (NonBranchingRule phi r t) where
  ra >> rb = MkNBR $ \g -> unNBR ra g >> unNBR rb g
  ra >>= f = MkNBR $ \g -> unNBR ra g >>= \v -> unNBR (f v) g
  return v = MkNBR $ \_ -> return v
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/grammar-combinators-0.2.7/Text/GrammarCombinators/Transform/PenalizeErrors.hs
Applicative instance: 

instance Applicative IsJustApp where
  pure _ = IJA True
  IJA va <*> IJA vb = IJA $ va && vb
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reflection-extras-0.1.1.0/src/Data/Reflection/Extras.hs
Applicative instance: 


instance Applicative (Lift p s) where
   pure              = Lift
   Lift f <*> Lift x = Lift $ f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/graphbuilder-0.1.0.0/src/Data/Graph/Builder.hs
Monad instance: 


instance Monad (GraphBuilder e a b) where
  return a = GraphBuilder (return a)
  (GraphBuilder m) >>= f = GraphBuilder (m >>= unGB . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/parcom-lib-0.8.0.3/Text/Parcom/Core.hs
Monad instance: 


-- | Parcom is a monad. Obviously. Since the Parcom monad handles both failure
-- through 'Either' as well as carrying along its internal state, *and*
-- supporting the transformed parent monad, the implementation is a tiny bit
-- hairy.
instance (Monad m) => Monad (ParcomT s t m) where
    return x = ParcomT (\s -> return (Right x, s))
    fail err = ParcomT (\s -> return (Left $ ParcomError err (psSourcePosition s), s))
    m >>= f = ParcomT $ \s -> do -- in the m Monad
        (a, s') <- runParcomT m s
        case a of
            Left err -> return (Left err, s')
            Right ma -> do
                runParcomT (f ma) s'
Applicative instance: 


instance (Monad m) => Applicative (ParcomT s t m) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haddock-api-2.17.3/src/Haddock/Interface/Rename.hs
Monad instance: 


instance Monad RnM where
  (>>=) = thenRn
  return = pure
Applicative instance: 


instance Applicative RnM where
  pure = returnRn
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haddock-api-2.17.3/src/Haddock/Types.hs
Applicative instance: 


instance Applicative ErrMsgM where
    pure a = Writer (a, [])
    (<*>)  = ap
Monad instance: 


instance Monad ErrMsgM where
        return   = pure
        m >>= k  = Writer $ let
                (a, w)  = runWriter m
                (b, w') = runWriter (k a)
                in (b, w ++ w')
Applicative instance: 


instance Applicative ErrMsgGhc where
    pure a = WriterGhc (return (a, []))
    (<*>) = ap
Monad instance: 


instance Monad ErrMsgGhc where
  return = pure
  m >>= k = WriterGhc $ runWriterGhc m >>= \ (a, msgs1) ->
               fmap (second (msgs1 ++)) (runWriterGhc (k a))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/clash-lib-0.6.9/src/CLaSH/Rewrite/Types.hs
Applicative instance: 


instance Applicative (RewriteMonad extra) where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad (RewriteMonad extra) where
  return a = R (\_ s -> (a, s, mempty))
  m >>= k  = R (\r s -> case runR m r s of
                          (a,s',w) -> case runR (k a) r s' of
                                        (b,s'',w') -> let w'' = mappend w w'
                                                      in seq w'' (b,s'',w''))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/graphs-0.7/src/Data/Graph/Algorithm.hs
Applicative instance: 


instance Graph g => Applicative (GraphSearch g) where
  pure a = GraphSearch
    (const (return a))
    (const (return a))
    (const (return a))
    (const (return a))
    (const (return a))

  m <*> n = GraphSearch
    (\v -> enterVertex m v `ap` enterVertex n v)
    (\e -> enterEdge m e `ap`   enterEdge n e)
    (\e -> grayTarget m e `ap`  grayTarget n e)
    (\v -> exitVertex m v `ap`  exitVertex n v)
    (\e -> blackTarget m e `ap` blackTarget n e)
Monad instance: 


instance Graph g => Monad (GraphSearch g) where
  return = pure
  m >>= f = GraphSearch
    (\v -> enterVertex m v >>= ($ v) . enterVertex . f)
    (\e -> enterEdge m e >>= ($ e)   . enterEdge . f)
    (\e -> grayTarget m e >>= ($ e)  . grayTarget . f)
    (\v -> exitVertex m v >>= ($ v)  . exitVertex . f)
    (\e -> blackTarget m e >>= ($ e) . blackTarget . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/graphs-0.7/src/Data/Graph/Dual.hs
Applicative instance: 


instance Applicative g => Applicative (Dual g) where
  pure = Dual . pure
  Dual f <*> Dual a = Dual (f <*> a)
  Dual f <*  Dual a = Dual (f <*  a)
  Dual f  *> Dual a = Dual (f  *> a)
Monad instance: 


instance Monad g => Monad (Dual g) where
  return = Dual . return
  Dual g >>= k = Dual (g >>= runDual . k)
  Dual g >> Dual h = Dual (g >> h)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/graphs-0.7/src/Data/Graph/AdjacencyList.hs
Applicative instance: 


instance Applicative (AdjacencyList i) where
  pure = AdjacencyList . const
  AdjacencyList f <*> AdjacencyList a = AdjacencyList $ \t -> f t (a t)
Monad instance: 


instance Monad (AdjacencyList i) where
  return = AdjacencyList . const
  AdjacencyList f >>= k = AdjacencyList $ \t -> runAdjacencyList (k (f t)) t
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/graphs-0.7/src/Data/Graph/AdjacencyMatrix.hs
Applicative instance: 


instance Applicative (AdjacencyMatrix arr i) where
  pure = AdjacencyMatrix . const
  AdjacencyMatrix f <*> AdjacencyMatrix a = AdjacencyMatrix $ \t -> f t (a t)
Monad instance: 


instance Monad (AdjacencyMatrix arr i) where
  return = AdjacencyMatrix . const
  AdjacencyMatrix f >>= k = AdjacencyMatrix $ \t -> runAdjacencyMatrix (k (f t)) t
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monadLib-3.7.3/src/MonadLib/Monads.hs
Monad instance: 


instance Monad (Reader i) where
  return  = derive_return iso_R
  fail    = derive_fail iso_R
  (>>=)   = derive_bind iso_R
Monad instance: 


instance (Monoid i) => Monad (Writer i) where
  return  = derive_return iso_W
  fail    = derive_fail iso_W
  (>>=)   = derive_bind iso_W
Monad instance: 


instance Monad (State i) where
  return  = derive_return iso_S
  fail    = derive_fail iso_S
  (>>=)   = derive_bind iso_S
Monad instance: 


instance Monad (Exception i) where
  return  = derive_return iso_X
  fail    = derive_fail iso_X
  (>>=)   = derive_bind iso_X
Monad instance: 


instance Monad (Cont i) where
  return  = derive_return iso_C
  fail    = derive_fail iso_C
  (>>=)   = derive_bind iso_C
Applicative instance: 


instance               Applicative (Reader    i) where pure = return; (<*>) = ap
Applicative instance: 

instance (Monoid i) => Applicative (Writer    i) where pure = return; (<*>) = ap
Applicative instance: 

instance               Applicative (State     i) where pure = return; (<*>) = ap
Applicative instance: 

instance               Applicative (Exception i) where pure = return; (<*>) = ap
Applicative instance: 

instance               Applicative (Cont      i) where pure = return; (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monadLib-3.7.3/src/MonadLib.hs
Monad instance: 



instance Monad Id where
  return x = I x
  fail x   = error x
  m >>= k  = k (runId m)
Monad instance: 


instance Monad Lift where
  return x  = L x
  fail x    = error x
  L x >>= k = k x
Monad instance: 
     -- Note: the pattern is important here
                      -- because it makes things strict


-- Note: None of the transformers make essential use of the 'fail' method.
-- Instead, they delegate its behavior to the underlying monad.

instance (Monad m) => Monad (IdT m) where
  return  = t_return
  fail    = t_fail
  m >>= k = IT (runIdT m >>= (runIdT . k))
Monad instance: 


instance (Monad m) => Monad (ReaderT i m) where
  return  = t_return
  fail    = t_fail
  m >>= k = R (\r -> runReaderT r m >>= \a -> runReaderT r (k a))
Monad instance: 


instance (Monad m) => Monad (StateT i m) where
  return  = t_return
  fail    = t_fail
  m >>= k = S (\s -> runStateT s m >>= \ ~(a,s') -> runStateT s' (k a))
Monad instance: 


instance (Monad m,Monoid i) => Monad (WriterT i m) where
  return  = t_return
  fail    = t_fail
  m >>= k = W $ unW m     >>= \ ~(P a w1) ->
                unW (k a) >>= \ ~(P b w2) ->
                return (P b (mappend w1 w2))
Monad instance: 


instance (Monad m) => Monad (ExceptionT i m) where
  return  = t_return
  fail    = t_fail
  m >>= k = X $ runExceptionT m >>= \e ->
                case e of
                  Left x  -> return (Left x)
                  Right a -> runExceptionT (k a)
Monad instance: 


instance (Monad m) => Monad (ChoiceT m) where
  return x  = Answer x
  fail x    = lift (fail x)

  Answer a  >>= k     = k a
  NoAnswer >>= _      = NoAnswer
  Choice m1 m2 >>= k  = Choice (m1 >>= k) (m2 >>= k)
  ChoiceEff m >>= k   = ChoiceEff (liftM (>>= k) m)
Monad instance: 


instance (Monad m) => Monad (ContT i m) where
  return  = t_return
  fail    = t_fail
  m >>= k = C $ \c -> runContT (\a -> runContT c (k a)) m
Applicative instance: 


-- Applicative support ---------------------------------------------------------

-- NOTE: It may be possible to make these more general
-- (i.e., have Applicative, or even Functor transformers)

instance              Applicative Id            where (<*>) = ap; pure = return
Applicative instance: 

instance              Applicative Lift          where (<*>) = ap; pure = return
Applicative instance: 

instance (Monad m) => Applicative (IdT m)       where (<*>) = ap; pure = return
Applicative instance: 

instance (Monad m) => Applicative (ReaderT i m) where (<*>) = ap; pure = return
Applicative instance: 

instance (Monad m) => Applicative (StateT i m)  where (<*>) = ap; pure = return
Applicative instance: 

instance (Monad m,Monoid i)
                   => Applicative (WriterT i m) where (<*>) = ap; pure = return
Applicative instance: 

instance (Monad m) => Applicative (ExceptionT i m)
                                                where (<*>) = ap; pure = return
Applicative instance: 

instance (Monad m) => Applicative (ChoiceT m)   where (<*>) = ap; pure = return
Applicative instance: 

instance (Monad m) => Applicative (ContT i m)   where (<*>) = ap; pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tamarin-prover-utils-0.8.5.1/src/Control/Monad/Trans/Disj.hs
Monad instance: 





-- Instances
------------

instance Monad m => Monad (DisjT m) where
    -- Ensure that contradictions are not reported via fail!
    fail    = error
    {-# INLINE return #-}
    return  = DisjT . return
    {-# INLINE (>>=) #-}
    m >>= f = DisjT $ (unDisjT . f) =<< unDisjT m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tamarin-prover-utils-0.8.5.1/src/Text/Dot.hs
Applicative instance: 


instance Applicative Dot where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad Dot where
  return a = Dot $ \ uq -> ([],uq,a)
  m >>= k  = Dot $ \ uq -> case unDot m uq of
                           (g1,uq',r) -> case unDot (k r) uq' of
                                           (g2,uq2,r2) -> (g1 ++ g2,uq2,r2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kansas-lava-0.2.4.3/Language/KansasLava/Optimization.hs
Applicative instance: 


instance Applicative Opt where
    pure x = Opt x 0
    (Opt f n) <*> (Opt x m) = Opt (f x) (n + m)
Monad instance: 


instance Monad Opt where
    return a = Opt a 0
    (Opt a n) >>= k = case k a of
                        Opt r m -> Opt r (n + m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kansas-lava-0.2.4.3/Language/KansasLava/RTL.hs
Applicative instance: 


instance Applicative (RTL s c) where
        pure x = RTL $ \ _ _ -> return (x, [])
        mf <*> mx = RTL $ \ c u -> do
            (f, us1) <- unRTL mf c u
            (x, us2) <- unRTL mx c u
            return (f x, us1 ++ us2)
Monad instance: 


instance Monad (RTL s c) where
        return = pure
        m >>= k = RTL $ \ c u -> do (r1,f1) <- unRTL m c u
                                    (r2,f2) <- unRTL (k r1) c u
                                    return (r2,f1 ++ f2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kansas-lava-0.2.4.3/Language/KansasLava/Fabric.hs
Applicative instance: 


instance Applicative Fabric where
        pure x = Fabric $ \ _ -> (x, [], [])
        (Fabric ff) <*> (Fabric fx) = Fabric $ \ ins ->
          let (f, in_names, outs) = ff ins
              (x, in_names', outs') = fx ins
          in (f x, in_names ++ in_names', outs ++ outs')
Monad instance: 


instance Monad Fabric where
        return = pure
        (Fabric f) >>= k = Fabric $ \ ins -> let
                          (a,in_names,outs) = f ins
                          (r,in_names',outs') = unFabric (k a) ins
                       in (r,in_names ++ in_names',outs ++ outs')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kansas-lava-0.2.4.3/Language/KansasLava/Stream.hs
Applicative instance: 


instance Applicative Stream where
        pure a = a `Cons` Nothing
        (h1 `Cons` t1) <*> (h2 `Cons` t2) = h1 h2 `Cons` (t1 `opt_ap` t2)
           where
                   Nothing  `opt_ap` Nothing  = Nothing
                   Nothing  `opt_ap` (Just x) = Just (pure h1 <*> x)
                   (Just f) `opt_ap` Nothing  = Just (f <*> pure h2)
                   (Just f) `opt_ap` (Just x) = Just (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kansas-lava-cores-0.1.2.2/Hardware/KansasLava/Simulators/Polyester.hs
Applicative instance: 


instance Applicative Polyester where
        pure x = Polyester $ \ _ _ -> return (x, [])
        (Polyester pf) <*> (Polyester px) = Polyester $ \ inp st -> do
            (f, s1) <- pf inp st
            (x, s2) <- px inp st
            return (f x, s1 ++ s2)
Monad instance: 


instance Monad Polyester where
        return = pure
        (Polyester f) >>= k = Polyester $ \ inp st -> do
                                (a,s1)  <- f inp st
                                let Polyester g = k a
                                (b,s2)  <- g inp st
                                return (b,s1 ++ s2)
        fail msg = error msg
Applicative instance: 


instance Applicative ANSI where
        pure = RETURN
        mf <*> mx = BIND mf $ \f ->
                    BIND mx $ \x ->
                    RETURN (f x)
Monad instance: 


instance Monad ANSI where
        return = pure
        (>>=) = BIND
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reflection-without-remorse-0.9.5/Control/Monad/Free/Reflectable.hs
Monad instance: 


instance Monad (FreeMonad f) where
  return = fromView . Pure
  (FM m r) >>= f = FM m (r >< tsingleton (FC f))
Applicative instance: 


instance Applicative (FreeMonad f) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reflection-without-remorse-0.9.5/Control/Monad/Operational/Reflectable.hs
Monad instance: 


instance Monad (Program r) where
  return = fromView . Return
  (Program t s) >>= f = Program t (s |> TC f)
Applicative instance: 


instance Applicative (Program r) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/MaybeT-transformers-0.2/Control/Monad/Maybe.hs
Monad instance: 


instance (Monad m) => Monad (MaybeT m) where
  fail _ = MaybeT (return Nothing)
  return = lift . return
  x >>= f = MaybeT (runMaybeT x >>= maybe (return Nothing) (runMaybeT . f))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Stream-0.4.7.2/Data/Stream.hs
Applicative instance: 


instance Applicative Stream where
  pure = repeat
  (<*>) = zipWith ($)
Monad instance: 


instance Monad Stream where
  return = repeat
  xs >>= f = join (fmap f xs)
    where
      join :: Stream (Stream a) -> Stream a
      join ~(Cons xs xss) = Cons (head xs) (join (map tail xss))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/enumerator-0.4.9.1/hs/Data/Enumerator.hs
Monad instance: 


instance Monad Stream where
        return = Chunks . return
        Chunks xs >>= f = mconcat (fmap f xs)
        EOF >>= _ = EOF
Monad instance: 


instance Monad m => Monad (Iteratee a m) where
        return x = yield x (Chunks [])

        m0 >>= f = ($ m0) $ fix $
                \bind m -> Iteratee $ runIteratee m >>= \r1 ->
                        case r1 of
                                Continue k -> return (Continue (bind . k))
                                Error err -> return (Error err)
                                Yield x (Chunks []) -> runIteratee (f x)
                                Yield x extra -> runIteratee (f x) >>= \r2 ->
                                        case r2 of
                                                Continue k -> runIteratee (k extra)
                                                Error err -> return (Error err)
                                                Yield x' _ -> return (Yield x' extra)
Applicative instance: 


instance Monad m => A.Applicative (Iteratee a m) where
        pure = return
        (<*>) = CM.ap
Applicative instance: 


-- | Since: 0.4.5
instance A.Applicative Stream where
        pure = return
        (<*>) = CM.ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hyperfunctions-0/src/Control/Monad/Hyper.hs
Applicative instance: 


instance Applicative (Hyper a) where
  pure a = Hyper $ \_ -> a
  p <* _ = p
  _ *> p = p
  (<*>) = curry $ ana $ \(i,j) fga ->
    unroll i (\i' -> fga (i',j)) $ unroll j (\j' -> fga (i,j'))
Monad instance: 


instance Monad (Hyper a) where
  return = pure
  m >>= f = cata (\g -> roll $ \k -> unroll (f (g k)) k) m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hyperfunctions-0/src/Control/Monad/Hyper/Rep.hs
Applicative instance: 


instance Applicative (Hyper a) where
  pure b = Hyper (Identity (const b)) ()
  p <* _ = p
  _ *> p = p
  Hyper (f :: f (f a -> b -> c)) x <*> Hyper (g :: g (g a -> b)) y = Hyper h (x,y) where
    h :: Compose f g (Compose f g a -> c)
    h = tabulate $ \(i,j) (Compose fga) ->
      index f i (fmap (`index` j) fga) (index g j (index fga i))
Monad instance: 


instance Monad (Hyper a) where
  return = pure
  m >>= f = cata (\g -> roll $ \k -> unroll (f (g k)) k) m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unbound-generics-0.3.1/src/Unbound/Generics/LocallyNameless/Alpha.hs
Applicative instance: 


instance Applicative (FFM f) where
  pure = return
  (FFM h) <*> (FFM k) = FFM (\r j -> h (\f -> k (r . f) j) j)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad (FFM f) where
  return x = FFM (\r _j -> r x)
  {-# INLINE return #-}
  (FFM h) >>= f = FFM (\r j -> h (\x -> runFFM (f x) r j) j)
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/stepwise-1.0.2/src/Control/Monad/Stepwise/Derived.hs
Applicative instance: 


-- Applicative instance of 'Stepwise' computations.
instance Error e => Applicative (Stepwise e i o w) where
  pure    = return
  p <*> q = let !r1 = (\f -> let !r2 = return . f in q >>= r2)
            in p >>= r1
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/stepwise-1.0.2/src/Control/Monad/Stepwise/Core.hs
Monad instance: 



-- | Monad instance for Stepwise. See 'Control.Monad.BreadthFirst.Proofs' for
--   proofs of the monad laws.
instance Error e => Monad (Stepwise e i o w) where
  return = final
  fail   = abort . strMsg
  (>>=)  = resume

  {-# SPECIALIZE instance Error e => Monad (Stepwise e i o w) #-}
  {-# SPECIALIZE instance Monad (Stepwise (Errors e) i o w)   #-}
  {-# SPECIALIZE instance Monad (Stepwise String i o w)       #-}
  {-# SPECIALIZE instance Monad (Stepwise AnyFailure i o w)     #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/roguestar-engine-0.6.0.1/src/DB.hs
Monad instance: 


instance Monad DB where
    return a = DB $ \h f -> f a h
    k >>= m = DB $ \h f -> cycleDB k h $ \a h' -> cycleDB (m a) h' f
    fail = error
Applicative instance: 


instance Applicative DB where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ZipFold-0.1.4/src/Data/WithCont.hs
Applicative instance: 



-- Standard Applicative instance for |Monoidal|
instance Zip z => Applicative (WithCont z) where
  pure a    = fmap (const a) unit
  wf <*> wx = app <$> (wf `zip` wx)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ZipFold-0.1.4/src/Data/Zip/FoldL.hs
Applicative instance: 



instance Zip' z => Applicative (WithCont' z) where
  pure a = WC' (error "unneeded pre-cont") (pure a)
  WC' hf hk <*> WC' xf xk =
    WC' (hf `zip'` xf) (\ (P a a') -> (hk a) (xk a'))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/UrlDisp-0.1.7/Network/UrlDisp/Types.hs
Applicative instance: 


instance MonadCGI m => Applicative (StateT UrlS (MaybeT m)) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/csound-sampler-0.0.6.5/src/Csound/Sam/Core.hs
Applicative instance: 


instance Applicative Sample where
        pure = Sam . pure . pure
        (Sam rf) <*> (Sam ra) = Sam $ liftA2 (<*>) rf ra
Applicative instance: 


instance Applicative S where
        pure a = S a InfDur
        (S f df) <*> (S a da) = S (f a) $ case (df, da) of
                (Dur durF, Dur durA) -> Dur $ maxB durF durA
                _                            -> InfDur
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wai-lite-0.2.0.0/Web/Simple/Router.hs
Monad instance: 


instance Monad Route where
  return a = Route (const $ return Nothing) a
  (Route rtA valA) >>= fn =
    let (Route rtB valB) = fn valA
    in Route (\req -> do
      resA <- rtA req
      case resA of
        Nothing -> rtB req
        Just _ -> return resA) valB
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wai-lite-0.2.0.0/Network/Wai/Router.hs
Monad instance: 


instance Monad Route where
  return a = Route (const $ return Nothing) a
  (Route rtA valA) >>= fn =
    let (Route rtB valB) = fn valA
    in Route (\req -> do
      resA <- rtA req
      case resA of
        Nothing -> rtB req
        Just _ -> return resA) valB
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Consumer-1.2/Control/Monad/Consumer.hs
Monad instance: 


instance Monad (Consumer c) where
  return a         = Consumer (\c -> (a,c))
  Consumer m >>= k = Consumer (\c -> let (a,c1)     = m c
                                         Consumer n = k a
                                     in n c1)
Applicative instance: 


instance Applicative (Consumer a) where
    pure = return
    (<*>) = ap
Monad instance: 


instance (Monad m) => Monad (ConsumerT c m) where
        return a = ConsumerT $ \c -> return (a, c)
        m >>= k  = ConsumerT $ \c -> do
                (a, c') <- runConsumerT m c
                runConsumerT (k a) c'
        fail str = ConsumerT $ \_ -> fail str
Applicative instance: 


instance (Monad m) => Applicative (ConsumerT c m) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/urlencoded-0.4.1/test/TestDriver.hs
Applicative instance: 


instance Applicative Gen where
    (<*>) = liftM2 ($)
    pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/growler-0.6.0/src/Web/Growler/Types.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (GrowlerT m) where
  pure = GrowlerT . pure
  (GrowlerT f) <*> (GrowlerT r) = GrowlerT (f <*> r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tup-functor-0.3.0.0/Data/Tup/Tup/Strict.hs
Applicative instance: 


--------------------------------------------------------------------------------

instance Applicative Tup0 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup0
  Tup0 <*> Tup0 = Tup0
Applicative instance: 


instance Applicative Tup1 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup1 x
  Tup1 f1 <*> Tup1 x1 = Tup1 (f1 x1)
Applicative instance: 


instance Applicative Tup2 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup2 x x
  Tup2 f1 f2 <*> Tup2 x1 x2 = Tup2 (f1 x1) (f2 x2)
Applicative instance: 


instance Applicative Tup3 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup3 x x x
  Tup3 f1 f2 f3 <*> Tup3 x1 x2 x3 = Tup3 (f1 x1) (f2 x2) (f3 x3)
Applicative instance: 


instance Applicative Tup4 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup4 x x x x
  Tup4 f1 f2 f3 f4 <*> Tup4 x1 x2 x3 x4 = Tup4 (f1 x1) (f2 x2) (f3 x3) (f4 x4)
Applicative instance: 


instance Applicative Tup5 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup5 x x x x x
  Tup5 f1 f2 f3 f4 f5 <*> Tup5 x1 x2 x3 x4 x5 = Tup5 (f1 x1) (f2 x2) (f3 x3) (f4 x4) (f5 x5)
Applicative instance: 


instance Applicative Tup6 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup6 x x x x x x
  Tup6 f1 f2 f3 f4 f5 f6 <*> Tup6 x1 x2 x3 x4 x5 x6 = Tup6 (f1 x1) (f2 x2) (f3 x3) (f4 x4) (f5 x5) (f6 x6)
Applicative instance: 


instance Applicative Tup7 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup7 x x x x x x x
  Tup7 f1 f2 f3 f4 f5 f6 f7 <*> Tup7 x1 x2 x3 x4 x5 x6 x7
    = Tup7 (f1 x1) (f2 x2) (f3 x3) (f4 x4) (f5 x5) (f6 x6) (f7 x7)
Applicative instance: 


instance Applicative Tup8 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup8 x x x x x x x x
  Tup8 f1 f2 f3 f4 f5 f6 f7 f8 <*> Tup8 x1 x2 x3 x4 x5 x6 x7 x8
    = Tup8 (f1 x1) (f2 x2) (f3 x3) (f4 x4) (f5 x5) (f6 x6) (f7 x7) (f8 x8)
Applicative instance: 


instance Applicative Tup9 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup9 x x x x x x x x x
  Tup9 f1 f2 f3 f4 f5 f6 f7 f8 f9 <*> Tup9 x1 x2 x3 x4 x5 x6 x7 x8 x9
    = Tup9 (f1 x1) (f2 x2) (f3 x3) (f4 x4) (f5 x5) (f6 x6) (f7 x7) (f8 x8) (f9 x9)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tup-functor-0.3.0.0/Data/Tup/Tup/Lazy.hs
Applicative instance: 


--------------------------------------------------------------------------------

instance Applicative Tup0 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup0
  Tup0 <*> Tup0 = Tup0
Applicative instance: 


instance Applicative Tup1 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup1 x
  Tup1 f1 <*> Tup1 x1 = Tup1 (f1 x1)
Applicative instance: 


instance Applicative Tup2 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup2 x x
  Tup2 f1 f2 <*> Tup2 x1 x2 = Tup2 (f1 x1) (f2 x2)
Applicative instance: 


instance Applicative Tup3 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup3 x x x
  Tup3 f1 f2 f3 <*> Tup3 x1 x2 x3 = Tup3 (f1 x1) (f2 x2) (f3 x3)
Applicative instance: 


instance Applicative Tup4 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup4 x x x x
  Tup4 f1 f2 f3 f4 <*> Tup4 x1 x2 x3 x4 = Tup4 (f1 x1) (f2 x2) (f3 x3) (f4 x4)
Applicative instance: 


instance Applicative Tup5 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup5 x x x x x
  Tup5 f1 f2 f3 f4 f5 <*> Tup5 x1 x2 x3 x4 x5 = Tup5 (f1 x1) (f2 x2) (f3 x3) (f4 x4) (f5 x5)
Applicative instance: 


instance Applicative Tup6 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup6 x x x x x x
  Tup6 f1 f2 f3 f4 f5 f6 <*> Tup6 x1 x2 x3 x4 x5 x6 = Tup6 (f1 x1) (f2 x2) (f3 x3) (f4 x4) (f5 x5) (f6 x6)
Applicative instance: 


instance Applicative Tup7 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup7 x x x x x x x
  Tup7 f1 f2 f3 f4 f5 f6 f7 <*> Tup7 x1 x2 x3 x4 x5 x6 x7
    = Tup7 (f1 x1) (f2 x2) (f3 x3) (f4 x4) (f5 x5) (f6 x6) (f7 x7)
Applicative instance: 


instance Applicative Tup8 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup8 x x x x x x x x
  Tup8 f1 f2 f3 f4 f5 f6 f7 f8 <*> Tup8 x1 x2 x3 x4 x5 x6 x7 x8
    = Tup8 (f1 x1) (f2 x2) (f3 x3) (f4 x4) (f5 x5) (f6 x6) (f7 x7) (f8 x8)
Applicative instance: 


instance Applicative Tup9 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Tup9 x x x x x x x x x
  Tup9 f1 f2 f3 f4 f5 f6 f7 f8 f9 <*> Tup9 x1 x2 x3 x4 x5 x6 x7 x8 x9
    = Tup9 (f1 x1) (f2 x2) (f3 x3) (f4 x4) (f5 x5) (f6 x6) (f7 x7) (f8 x8) (f9 x9)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tup-functor-0.3.0.0/Data/Tup/Newtype.hs
Applicative instance: 


----------------------------------------------------------------------------------------------------------------------------------------------------------------

instance Applicative NTup0 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure _ = NTup0
  NTup0 <*> NTup0 = NTup0
Applicative instance: 


instance Applicative NTup1 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = NTup1 x
  NTup1 f1 <*> NTup1 x1 = NTup1 (f1 x1)
Applicative instance: 


instance Applicative NTup2 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = NTup2 (x,x)
  NTup2 (f1,f2) <*> NTup2 (x1,x2) = NTup2 (f1 x1, f2 x2)
Applicative instance: 


instance Applicative NTup3 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = NTup3 (x,x,x)
  NTup3 (f1,f2,f3) <*> NTup3 (x1,x2,x3) = NTup3 (f1 x1, f2 x2, f3 x3)
Applicative instance: 


instance Applicative NTup4 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = NTup4 (x,x,x,x)
  NTup4 (f1,f2,f3,f4) <*> NTup4 (x1,x2,x3,x4) = NTup4 (f1 x1, f2 x2, f3 x3, f4 x4)
Applicative instance: 


instance Applicative NTup5 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = NTup5 (x,x,x,x,x)
  NTup5 (f1,f2,f3,f4,f5) <*> NTup5 (x1,x2,x3,x4,x5) = NTup5 (f1 x1, f2 x2, f3 x3, f4 x4, f5 x5)
Applicative instance: 


instance Applicative NTup6 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = NTup6 (x,x,x,x,x,x)
  NTup6 (f1,f2,f3,f4,f5,f6) <*> NTup6 (x1,x2,x3,x4,x5,x6) = NTup6 (f1 x1, f2 x2, f3 x3, f4 x4, f5 x5, f6 x6)
Applicative instance: 


instance Applicative NTup7 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = NTup7 (x,x,x,x,x,x,x)
  NTup7 (f1,f2,f3,f4,f5,f6,f7) <*> NTup7 (x1,x2,x3,x4,x5,x6,x7)
    = NTup7 (f1 x1, f2 x2, f3 x3, f4 x4, f5 x5, f6 x6, f7 x7)
Applicative instance: 


instance Applicative NTup8 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = NTup8 (x,x,x,x,x,x,x,x)
  NTup8 (f1,f2,f3,f4,f5,f6,f7,f8) <*> NTup8 (x1,x2,x3,x4,x5,x6,x7,x8)
    = NTup8 (f1 x1, f2 x2, f3 x3, f4 x4, f5 x5, f6 x6, f7 x7, f8 x8)
Applicative instance: 


instance Applicative NTup9 where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = NTup9 (x,x,x,x,x,x,x,x,x)
  NTup9 (f1,f2,f3,f4,f5,f6,f7,f8,f9) <*> NTup9 (x1,x2,x3,x4,x5,x6,x7,x8,x9)
    = NTup9 (f1 x1, f2 x2, f3 x3, f4 x4, f5 x5, f6 x6, f7 x7, f8 x8, f9 x9)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tup-functor-0.3.0.0/Data/Tup/Vec.hs
Applicative instance: 


--------------------------------------------------------------------------------

instance Applicative Empty where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Empty
  Empty <*> Empty = Empty
Applicative instance: 


instance Applicative v => Applicative (Cons v) where
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
  pure x = Cons x (pure x)
  Cons f fs <*> Cons x xs = Cons (f x) (fs <*> xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/magma-0.4.0.0/Data/Magma.hs
Applicative instance: 


instance Applicative BinaryTree where
  pure = Leaf
  {-# INLINE pure #-}
  Leaf f <*> Leaf x = Leaf (f x)
  Leaf f <*> Node l r = Node (f <$> l) (f <$> r)
  Node l r <*> t = Node (l <*> t) (r <*> t)
Monad instance: 


instance Monad BinaryTree where
  return = Leaf
  {-# INLINE return #-}
  Leaf a >>= k = k a
  Node l r >>= k = Node (l >>= k) (r >>= k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/snap-1.0.0.0/src/Snap/Snaplet/Internal/RST.hs
Applicative instance: 



instance (Functor m, Monad m) => Applicative (RST r s m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance (Monad m) => Monad (RST r s m) where
    return a = RST $ \_ s -> return (a, s)
    (>>=)    = rwsBind
    fail msg = RST $ \_ _ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/snap-1.0.0.0/src/Snap/Snaplet/Internal/Lensed.hs
Applicative instance: 



------------------------------------------------------------------------------
instance (Functor m, Monad m) => Applicative (Lensed b v m) where
    pure a = Lensed $ \_ v s -> return (a, v, s)
    Lensed mf <*> Lensed ma = Lensed $ \l v s -> do
        (f, v', s') <- mf l v s
        (\(a,v'',s'') -> (f a, v'', s'')) <$> ma l v' s'
Monad instance: 



------------------------------------------------------------------------------
instance Monad m => Monad (Lensed b v m) where
    return a = Lensed $ \_ v s -> return (a, v, s)
    Lensed g >>= k = Lensed $ \l v s -> do
        (a, v', s') <- g l v s
        unlensed (k a) l v' s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-skeleton-0.1.2.2/src/Control/Monad/Skeleton.hs
Applicative instance: 


instance Applicative (Skeleton t) where
  pure = return
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad (Skeleton t) where
  return a = Skeleton $ Spine (Return a) id
  {-# INLINE return #-}
  Skeleton (Spine t c) >>= k = Skeleton $ Spine t (c |> Kleisli k)
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/data-object-0.3.1.9/Data/Object.hs
Monad instance: 


instance Monad (Object key) where
    return = Scalar
    x >>= f = joinObj . fmap f $ x
Applicative instance: 


instance Applicative (Object key) where
    pure  = Scalar
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haste-markup-0.0.1.0/src/Haste/Markup/Internal.hs
Monad instance: 


instance Monad MarkupM where
    return _ = Empty
    {-# INLINE return #-}
    (>>) = Append
    {-# INLINE (>>) #-}
    h1 >>= f = h1 >> f
        (error "Text.Blaze.Internal.MarkupM: invalid use of monadic bind")
    {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/respond-1.1.0/src/Web/Respond/Path.hs
Applicative instance: 


instance Applicative PathMatcher where
    pure v = PathMatcher $ pure $ pure v
    f <*> r = PathMatcher $ (<*>) <$> runPathMatcher f <*> runPathMatcher r
Monad instance: 


instance Monad PathMatcher where
    return = pure
    a >>= f = PathMatcher $ (>>=) <$> runPathMatcher a  <*> flip (runPathMatcher . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/helm-0.7.1/src/FRP/Helm/Sample.hs
Applicative instance: 


instance Applicative Sample where
  pure = Unchanged
  (Changed   f) <*> (Changed   x) = Changed (f x)
  (Changed   f) <*> (Unchanged x) = Changed (f x)
  (Unchanged f) <*> (Changed   x) = Changed (f x)
  (Unchanged f) <*> (Unchanged x) = Unchanged (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/helm-0.7.1/src/FRP/Helm/Signal.hs
Applicative instance: 


instance Applicative Signal where
  pure = Signal . pure . pure . pure
  (Signal f) <*> (Signal x) = Signal $ liftA2 (liftA2 (<*>)) f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/happstack-dlg-0.1.2/src/Happstack/Server/Dialogues.hs
Monad instance: 


{-
    Dlg is a monad in the obvious way: return represents a dialogue that has no
    steps; and (>>=) combines dialogues by doing the first part of the first
    dialogue, and then continuing with the rest.
-}
instance Monad m => Monad (Dlg m) where
    return         = Done
    Done x   >>= y = y x
    Action x >>= y = Action (x >>= return . (>>= y))
    Step p f >>= y = Step p (f >>= y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/set-monad-0.2.0.0/Data/Set/Monad.hs
Applicative instance: 


instance A.Applicative Set where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad Set where
  return = Return
  (>>=)  = Bind
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskell-awk-1.1.1/tests/Everything.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (UncertainT m) where
  pure = UncertainT . pure
  UncertainT mf <*> UncertainT mx = UncertainT (mf <*> mx)
Monad instance: 


instance Monad m => Monad (UncertainT m) where
  return = UncertainT . return
  UncertainT mx >>= f = UncertainT (mx >>= f')
    where
      f' = unUncertainT . f
  fail s = UncertainT (fail s)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskell-awk-1.1.1/src/Control/Monad/Trans/OptionParser.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (OptionParserT o m) where
  pure = OptionParserT . pure
  OptionParserT mf <*> OptionParserT mx = OptionParserT (mf <*> mx)
Monad instance: 


instance Monad m => Monad (OptionParserT o m) where
  return = OptionParserT . return
  OptionParserT mx >>= f = OptionParserT (mx >>= f')
    where
      f' = unOptionParserT . f
  fail s = OptionParserT (fail s)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskell-awk-1.1.1/src/Control/Monad/Trans/Uncertain.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (UncertainT m) where
  pure = UncertainT . pure
  UncertainT mf <*> UncertainT mx = UncertainT (mf <*> mx)
Monad instance: 


instance Monad m => Monad (UncertainT m) where
  return = UncertainT . return
  UncertainT mx >>= f = UncertainT (mx >>= f')
    where
      f' = unUncertainT . f
  fail s = UncertainT (fail s)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Blueprint-0.1/Blueprint/Error.hs
Applicative instance: 

-- @-node:gcross.20091127142612.1393:ErrorMessage
-- @-node:gcross.20091127142612.1391:Types
-- @+node:gcross.20091127142612.1385:Instances
-- @+node:gcross.20091127142612.1386:Applicative (Either e a)
instance (Monoid e) => Applicative (Either e) where
    pure = Right
    (<*>) (Left error2) (Left error1) = Left (error1 `mappend` error2)
    (<*>) (Left error) _ = Left error
    (<*>) _ (Left error) = Left error
    (<*>) (Right function) (Right argument) = Right (function argument)
Applicative instance: 

-- @-node:gcross.20091127142612.1386:Applicative (Either e a)
-- @+node:gcross.20091127142612.1388:Applicative (ErrorT e m a)
instance (Monoid e, Error e, Monad m) => Applicative (ErrorT e m) where
    pure = return
    e_fn <*> e_arg = ErrorT $ liftM2 (<*>) (runErrorT e_fn) (runErrorT e_arg)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Blueprint-0.1/Blueprint/Configuration.hs
Applicative instance: 

-- @-node:gcross.20091126122246.1388:Monoid (ConfigParser -> ConfigParser)
-- @+node:gcross.20091127142612.1407:Applicative (ConfigurationDataWriter)
instance Applicative ConfigurationDataWriter where
    pure = return
    x <*> y = WriterT . Reader $
        \environment ->
            let (function,w1) = (runReader . runWriterT) x $ environment
                (argument,w2) = (runReader . runWriterT) y $ environment
            in (function argument,w1 `mappend` w2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Agda-2.5.1.1/src/full/Agda/TypeChecking/Monad/Exception.hs
Monad instance: 


instance
#if __GLASGOW_HASKELL__ <= 708
  (Applicative m, Monad m, Error err)
#else
  (Monad m, Error err)
#endif
  => Monad (ExceptionT err m) where
  return = pure
  ExceptionT m >>= k = ExceptionT $ do
    r <- m
    case r of
      Left err -> return $ Left err
      Right x  -> runExceptionT $ k x
  fail = ExceptionT . return . Left . strMsg
Applicative instance: 


instance (Error err, Applicative m, Monad m) => Applicative (ExceptionT err m) where
  pure  = ExceptionT . return . Right
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Agda-2.5.1.1/src/full/Agda/Utils/Parser/MemoisedCPS.hs
Monad instance: 


instance Monad (Parser k r tok) where
  return    = pure
  P p >>= f = P $ \input i k ->
    p input i $ \j x -> unP (f x) input j k
Applicative instance: 


instance Applicative (Parser k r tok) where
  pure x = P $ \_ i k -> k i x
  (<*>)  = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Agda-2.5.1.1/src/full/Agda/Utils/Parser/ReadP.hs
Applicative instance: 


-- Monad, MonadPlus

instance Applicative (P t) where
  pure x = Result x Fail
  (<*>)  = ap
Monad instance: 


instance Monad (P t) where
  return = pure

  (Get f)      >>= k = Get (\c -> f c >>= k)
  (Look f)     >>= k = Look (\s -> f s >>= k)
  Fail         >>= k = Fail
  (Result x p) >>= k = k x `mplus` (p >>= k)
  (Final r)    >>= k = final [ys' | (x,s) <- r, ys' <- run (k x) s]

  fail _ = Fail
Applicative instance: 


instance Applicative (ReadP t) where
  pure x = R (\k -> k x)
  (<*>)  = ap
Monad instance: 


instance Monad (ReadP t) where
  return    = pure
  fail _    = R (\_ -> Fail)
  R m >>= f = R (\k -> m (\a -> let R m' = f a in m' k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Agda-2.5.1.1/src/full/Agda/Utils/Tuple.hs
Applicative instance: 


instance Applicative List2 where
  pure a                            = List2 (a,a)
  (List2 (f,f')) <*> (List2 (a,a')) = List2 (f a, f' a')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Agda-2.5.1.1/src/full/Agda/Utils/ListT.hs
Applicative instance: 


instance (Functor m, Applicative m, Monad m) => Applicative (ListT m) where
  pure  = sgListT
  (<*>) = ap
Monad instance: 


  -- Another Applicative, but not the canonical one.
  -- l1 <*> l2 = ListT $ loop <$> runListT l1 <*> runListT l2
  --   where
  --   loop (Just (f, l1')) (Just (a, l2')) = Just (f a, l1' <*> l2')
  --   loop _ _ = Nothing

instance (Functor m, Applicative m, Monad m) => Monad (ListT m) where
  return  = pure
  l >>= k = concatListT $ k <$> l
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Agda-2.5.1.1/src/full/Agda/Syntax/Parser/LookAhead.hs
Monad instance: 


{--------------------------------------------------------------------------
    Monad instances
 --------------------------------------------------------------------------}

instance Monad LookAhead where
    return  = pure
    m >>= k = LookAhead $ unLookAhead m >>= unLookAhead . k
    fail s  =
        do  err <- LookAhead ask
            throwError err s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Agda-2.5.1.1/src/full/Agda/Syntax/Parser/Monad.hs
Monad instance: 


{--------------------------------------------------------------------------
    Instances
 --------------------------------------------------------------------------}

instance Monad Parser where
  return = pure

  P m >>= f = P $ \s -> case m s of
                          ParseFailed e -> ParseFailed e
                          ParseOk s' x  -> unP (f x) s'

  fail msg = P $ \s -> ParseFailed $
                         ParseError  { errSrcFile   = parseSrcFile s
                                     , errPos       = parseLastPos s
                                     , errInput     = parseInp s
                                     , errPrevToken = parsePrevToken s
                                     , errMsg       = msg
                                     }
Applicative instance: 


instance Applicative Parser where
  pure x = P $ \s -> ParseOk s x
  (<*>)  = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/network-house-0.1.0.2/Net/PacketParsing.hs
Applicative instance: 


instance Applicative PacketParser where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad PacketParser where
  return x = P $ \ p -> return (Out x p)
  P pa >>= xpb = P $ \ p0 -> do Out x p1 <-pa p0
                                unP (xpb x) p1
  fail s = P $ \ _ -> fail s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/random-fu-0.2.7.0/src/Data/Random/Distribution/Categorical.hs
Monad instance: 


instance Fractional p => Monad (Categorical p) where
    return x = Categorical (V.singleton (1, x))

    -- I'm not entirely sure whether this is a valid form of failure; see next
    -- set of comments.
    fail _ = Categorical V.empty

    -- Should the normalize step be included here, or should normalization
    -- be assumed?  It seems like there is (at least) 1 valid situation where
    -- non-normal results would arise:  the distribution being modeled is 
    -- "conditional" and some event arose that contradicted the assumed 
    -- condition and thus was eliminated ('f' returned an empty or 
    -- zero-probability consequent, possibly by 'fail'ing).
    -- 
    -- It seems reasonable to continue in such circumstances, but should there
    -- be any renormalization?  If so, does it make a difference when that 
    -- renormalization is done?  I'm pretty sure it does, actually.  So, the
    -- normalization will be omitted here for now, as it's easier for the
    -- user (who really better know what they mean if they're returning
    -- non-normalized probability anyway) to normalize explicitly than to
    -- undo any normalization that was done automatically.
    xs >>= f = {- normalizeCategoricalPs . -} fromList $ do
        (p, x) <- toList xs
        (q, y) <- toList (f x)

        return (p * q, y)
Applicative instance: 


instance Fractional p => Applicative (Categorical p) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/anansi-0.4.8/lib/Anansi/Types.hs
Applicative instance: 


instance Applicative LoomM where
        pure = return
        (<*>) = ap
Monad instance: 


instance Monad LoomM where
        return = LoomM . return
        (LoomM m) >>= f = LoomM $ do
                x <- m
                unLoomM (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskoin-util-0.0.1.1/Network/Haskoin/Util/BuildMonad.hs
Monad instance: 


instance Monad Build where
    return = Complete
    Complete x >>= f = f x
    Partial x >>= f = case f x of
        e@(Broken _) -> e
        a            -> Partial $ runBuild a
    Broken s >>= _ = Broken s
Monad instance: 


instance Monad m => Monad (BuildT m) where
    return = lift . return
    x >>= f = BuildT $ do
        v <- runBuildT x
        case v of Complete a -> runBuildT (f a)
                  Partial a  -> runBuildT (f a)
                  Broken str -> return $ Broken str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rewriting-0.2.2/src/Generics/Regular/Rewriting/Strategies.hs
Monad instance: 


instance MonadPlus m => Monad (S m) where
  return x = S x mzero
  (S x xs) >>= k =
    S r (rs2 `mplus` rs1)
    where
      S r rs1 = k x
      rs2     =
        do x' <- xs
           let S r' _ = k x'
           return r'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/typelevel-tensor-0.2.1/Data/Tensor/TypeLevel.hs
Applicative instance: 

instance Applicative Vec where
  pure _  = Vec
  _ <*> _ = Vec
Applicative instance: 

instance (Applicative n, Traversable n) => Applicative ((:~) n) where
  pure x = pure x :~ x
  (vf :~ f) <*> (vx :~ x) = (vf <*> vx) :~ (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hsx-0.9.1/src/HSX/Transform.hs
Monad instance: 


instance Monad HsxM where
 return x = MkHsxM (\s -> (x,s))
 (MkHsxM f) >>= k = MkHsxM (\s -> let (a, s') = f s
                                      (MkHsxM f') = k a
                                   in f' s')
Monad instance: 


instance Monad RN where
 return a = RN $ \s -> (a,s)
 (RN f) >>= k = RN $ \s -> let (a,s') = f s
                               (RN g) = k a
                            in g s'
Monad instance: 


instance Monad Tr where
 return a = Tr $ \s -> return (a, s)
 (Tr f) >>= k = Tr $ \s ->
          do (a, s') <- f s
             let (Tr f') = k a
             f' s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/WashNGo-2.12.0.1/WASH/Utility/SimpleParser.hs
Monad instance: 

instance Monad (Parser a) where
  return x = Parser (\ w -> [(x, w)])
  m >>=  f = let g = unParser m in
             Parser (\ w -> [ (y, w'') | (x, w') <- g w, (y, w'') <- unParser (f x) w'])
  fail str = Parser (\ w -> [])
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/WashNGo-2.12.0.1/WASH/CGI/TCGI.hs
Monad instance: 


instance Monad (TCGI b) where
  return x =
    into (return x)
  m >>=  f =
    into (outof m >>= (outof . f))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/WashNGo-2.12.0.1/WASH/CGI/CGIMonad.hs
Monad instance: 


instance Monad CGI where
  return a =
        CGI ( \cgistate -> return (a, cgistate))
  CGI cgi >>= f =
        CGI ( \cgistate ->
            cgi cgistate >>= \ (x, cgistate') ->
            unCGI (f x) cgistate')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/WashNGo-2.12.0.1/WASH/HTML/HTMLMonadBase.hs
Monad instance: 

instance Monad m => Monad (WithHTML x m) where
  return a = WithHTML (\elem -> return (a, elem))
  ma >>= f = WithHTML (\elem -> unWithHTML ma elem >>= \(a, elem') ->
                                unWithHTML (f a) elem')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/WashNGo-2.12.0.1/WASH/HTML/HTMLTemplates.hs
Monad instance: 

instance Monad (ST s) where
  return x = ST (\s -> (x, s))
  m >>= f  = ST (\s -> let (x', s') = unST m s
                       in  unST (f x') s')
Monad instance: 


instance Monad M where
  return a = M (\t -> (a, t))
  m >>= f  = M (\t -> let (a,t') = unM m t in unM (f a) t')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/WashNGo-2.12.0.1/washparser/hs/WASHOut.hs
Monad instance: 


instance Monad Out where
  return a = Out a id
  m >>= f  = case m of
               Out x shw1 ->
                 case f x of
                   Out y shw2 ->
                     Out y (shw1 . shw2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/WashNGo-2.12.0.1/washparser/hs/WASHClean.hs
Monad instance: 

instance Monad CM where -- Reader monad
  return x = CM (const x)
  m >>= f  = CM (\strs ->
                 case m of
                   CM mfun ->
                     case f (mfun strs) of
                       CM ffun ->
                         ffun strs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/jmacro-0.6.9/Language/Javascript/JMacro/TypeCheck.hs
Applicative instance: 


instance Applicative TMonad where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/repa-v4l2-0.2.0.0/src/Graphics/Webcam/Linux/Internal.hs
Monad instance: 



instance Monad m => Monad (V4lCamT m) where
  f >>= g = V4lCamT $ unV4lCam f >>= (unV4lCam . g)
  return = V4lCamT . return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/twilight-stm-1.2/src/Control/Concurrent/STM/Twilight.hs
Monad instance: 


instance Monad (STM r p q) where
    return x = STM (\state -> return (Success state x))
    (STM tr1) >>= k = STM (\state -> do
                          stmRes <- tr1 state
                          case stmRes of
                            Success newState a ->
                               let (STM tr2) = k a in
                                   tr2 newState
                            Retry newState -> return (Retry newState)
                            Error newState -> return (Error newState)
                       )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/graphics-drawingcombinators-1.5.1/src/Graphics/DrawingCombinators.hs
Applicative instance: 


instance Applicative Image where
    pure x = Image {
        dRender = (pure.pure.pure) (),
        dPick = const x
      }

    df <*> dx = Image {
        -- reversed so that things that come first go on top
        dRender = (liftA2.liftA2) (*>) (dRender dx) (dRender df),
        dPick = dPick df <*> dPick dx
      }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dynamic-cabal-0.3.5/src/Distribution/Client/Dynamic/Query.hs
Applicative instance: 


instance Applicative (Query s) where
  pure = Query (selector $ const $ const' <>$ tuple0) . const
  Query f getF <*> Query a getA = Query (zipSelector f a) $ \(fv, av) -> getF fv $ getA av
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CCA-0.1.5.3/preprocessor/State.hs
Applicative instance: 


instance Applicative (State s) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad (State s) where
  return x = State (\n -> (x, n))
  State v >>= f = State (\n -> let (x, n') = v n in runState (f x) n')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/conjure-0.1/src/BEncode/BParser.hs
Monad instance: 


instance Monad BParser where
    (BParser p) >>= f = BParser $ \b -> case p b of
                                          Ok a b' -> runB (f a) b'
                                          Error str -> Error str
    return val = BParser $ Ok val
    fail str = BParser $ \_ -> Error str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/webapp-0.3.6/Web/App/RouteT.hs
Applicative instance: 


instance (WebAppState s, Monad m) => Applicative (RouteT s m) where
  pure a = RouteT $ \_ _ _ _ -> return $ Right (a,Nothing,[],Nothing)
  (<*>) = ap
Monad instance: 


instance (WebAppState s, Monad m) => Monad (RouteT s m) where
  fail msg = RouteT $ \_ _ _ _ -> fail msg
  m >>= k = RouteT $ \st pth bdy req -> do
    v <- runRouteT m st pth bdy req
    case v of
      Left e -> return $ Left e
      Right ~(x, s, h, b) -> do
        v' <- runRouteT (k x) st pth bdy req
        case v' of
          Left InterruptNext -> return $ Left InterruptNext
          Left (InterruptHalt s' h' b') -> return $ Left combined
            where combined = InterruptHalt (s' <|> s) (h' <> h) (b <> b')
          Right ~(y, s', h', b') -> return $ Right $ combined
            where combined = (y, s' <|> s, h' <> h, b <> b')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sousit-0.4/Data/SouSiT/Sink.hs
Monad instance: 


instance Monad m => Monad (Sink i m) where
    return a = doneSink $ return a
    (Sink st) >>= f = Sink (st >>= mp)
        where mp (Done r) = liftM f r >>= sinkStatus
              mp (Cont nf cf) = return $ Cont (liftM (>>= f) . nf) (cf >>= closeSink . f)
Applicative instance: 


instance Monad m => Applicative (Sink i m) where
    pure = return
    af <*> s = do f <- af
                  v <- s
                  return (f v)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/netwire-5.0.1/Control/Wire/Session.hs
Applicative instance: 


instance (Applicative m) => Applicative (Session m) where
    pure x = let s = Session (pure (x, s)) in s

    Session ff <*> Session fx =
        Session $ liftA2 (\(f, sf) (x, sx) -> (f x, sf <*> sx)) ff fx
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/atom-1.0.9/Language/Atom/Elaboration.hs
Monad instance: 


instance Monad Atom where
  return a = Atom (\ s -> return (a, s))
  (Atom f1) >>= f2 = Atom f3
    where
    f3 s = do
      (a, s) <- f1 s
      let Atom f4 = f2 a
      f4 s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/turtle-1.2.8/src/Turtle/Shell.hs
Applicative instance: 


instance Applicative Shell where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad Shell where
    return a = Shell (\(FoldM step begin done) -> do
       x  <- begin
       x' <- step x a
       done x' )

    m >>= f = Shell (\(FoldM step0 begin0 done0) -> do
        let step1 x a = _foldIO (f a) (FoldM step0 (return x) return)
        _foldIO m (FoldM step1 begin0 done0) )

    fail _ = mzero
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-vl-0.1.4/src/Control/Monad/Free/VanLaarhoven.hs
Applicative instance: 


instance Applicative (Free effect) where
  pure a = Free (const (pure a))
  (Free fab) <*> (Free a) =
    Free (\e -> fab e <*> a e)
Monad instance: 


instance Monad (Free effect) where
  (Free run) >>= f =
    Free (\e -> run e >>= \a -> runFree (f a) e)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ide-backend-common-0.9.1.3/IdeSession/Strict/StateT.hs
Applicative instance: 


instance Monad m => Applicative (StrictStateT s m) where
  pure    = return
  f <*> x = do f' <- f ; x' <- x ; return (f' x')
Monad instance: 


instance Monad m => Monad (StrictStateT s m) where
  return a = StrictStateT $ \s -> return (a, s)
  x >>= f  = StrictStateT $ \s -> do (a, s')  <- runStateT x s
                                     (b, s'') <- runStateT (f a) s'
                                     return (b, s'')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ide-backend-common-0.9.1.3/IdeSession/Strict/Container.hs
Applicative instance: 


instance Applicative (Strict Maybe) where
  pure    = force . pure
  -- We need 'force' here because we need to force the result of the
  -- function application
  f <*> a = force $ toLazyMaybe f <*> toLazyMaybe a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/inserts-0.1.2/src/Text/Template/Inserts/Internal.hs
Applicative instance: 


instance Applicative Got where
  pure = Got
  Miss e1 <*> Miss e2 = Miss (e1 <> e2)
  Miss e  <*> _       = Miss e
  _       <*> Miss e  = Miss e
  Got f   <*> Got x   = Got (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arbtt-0.9.0.9/src/LeftFold.hs
Applicative instance: 


instance Applicative (LeftFold x) where
    pure x = Pure x
    Pure f <*> c = f <$> c
    LeftFold st1 p1 f1 <*> Pure x = LeftFold st1 p1 (\s -> f1 s x)
    LeftFold st1 p1 f1 <*> LeftFold st2 p2 f2 = LeftFold {
        start   =                   st1 :!: st2,
        process = \(s1 :!: s2) x -> p1 s1 x :!: p2 s2 x,
        finish  = \(s1 :!: s2)   -> f1 s1 (f2 s2)
        }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/easyrender-0.1.1.2/Graphics/EasyRender/Internal.hs
Monad instance: 

                                          -- ^ Page with bounding box
                                          -- known at the end.

instance Monad Document where
  return a = Document_Return a
  f >>= g = case f of
    Document_Return a -> g a
    Document_Page x y draw -> Document_Page x y draw' where
      draw' = do
        f' <- draw
        return (f' >>= g)
    Document_Page_defer draw -> Document_Page_defer draw' where
      draw' = do
        (x, y, f') <- draw
        return (x, y, f' >>= g)
Applicative instance: 


instance Applicative Document where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Draw where
  return a = Draw_Return a
  f >>= g = case f of
    Draw_Return a -> g a
    Draw_Write cmd f' -> Draw_Write cmd (f' >>= g)
    Draw_Block draw -> Draw_Block draw' where
      draw' = do
        f' <- draw
        return (f' >>= g)
Applicative instance: 


instance Applicative Draw where
  pure = return
  (<*>) = ap
Monad instance: 
  -- ^ Write a string.

instance Monad Writer where
  return a = Writer_Return a
  f >>= g = case f of
    Writer_Return a -> g a
    Writer_PutChar c f' -> Writer_PutChar c (f' >>= g)
    Writer_PutStr s f' -> Writer_PutStr s (f' >>= g)
Applicative instance: 


instance Applicative Writer where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad m => Monad (Boxed m) where
  return a = Boxed (return a)
  f >>= g = Boxed (unbox f >>= (unbox . g))
Applicative instance: 


instance Applicative m => Applicative (Boxed m) where
  pure a = Boxed (pure a)
  f <*> x = Boxed (unbox f <*> unbox x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/magico-0.0.1.1/src/Main.hs
Applicative instance: 


instance Applicative Triple where
   pure x = Triple x x x
   Triple fx fy fz <*> Triple x y z = Triple (fx x) (fy y) (fz z)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/binary-bits-0.5/Data/Binary/Bits/Get.hs
Applicative instance: 


instance Applicative Block where
  pure a = Block 0 (\_ -> a)
  (Block i p) <*> (Block j q) = Block (i+j) (\s -> p s $ q (incS i s))
  (Block i _)  *> (Block j q) = Block (i+j) (q . incS i)
  (Block i p) <*  (Block j _) = Block (i+j) p
Monad instance: 


instance Monad BitGet where
  return x = B $ \s -> return (s,x)
  fail str = B $ \(S inp n) -> putBackState inp n >> fail str
  (B f) >>= g = B $ \s -> do (s',a) <- f s
                             runState (g a) s'
Applicative instance: 


instance Applicative BitGet where
  pure x = return x
  fm <*> m = fm >>= \f -> m >>= \v -> return (f v)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/binary-bits-0.5/Data/Binary/Bits/Put.hs
Applicative instance: 


instance Applicative BitPut where
  pure a = BitPut (\s -> PairS a s)
  (BitPut f) <*> (BitPut g) = BitPut $ \s ->
    let PairS a s' = f s
        PairS b s'' = g s'
    in PairS (a b) s''
Monad instance: 


instance Monad BitPut where
  m >>= k = BitPut $ \s ->
    let PairS a s'  = run m s
        PairS b s'' = run (k a) s'
    in PairS b s''
  return x = BitPut $ \s -> PairS x s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lol-typing-1.20160822/Language/LOL/Typing/Lib/Control/Monad/Classes/StateFix.hs
Applicative instance: 

instance Monad m => Applicative (StateLazyFixT st m) where
        pure = return
        (<*>) = ap
Monad instance: 

instance Monad m => Monad (StateLazyFixT st m) where
        return  = StateLazyFixT . return
        m >>= f = StateLazyFixT (unStateLazyFixT m >>= unStateLazyFixT . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-dimensional-0.8.0.1/src/Synthesizer/Dimensional/Process.hs
Applicative instance: 


instance Applicative (T s u t) where
   pure  = pure
   (<*>) = apply
Monad instance: 


instance Monad (T s u t) where
   return = pure
   (>>=)  = bind
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lambdabot-haskell-plugins-5.1/src/Lambdabot/Plugin/Haskell/Free/Parse.hs
Applicative instance: 


instance Applicative ParseS where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad ParseS where
    return x = ParseS (\ts -> ParseSuccess x ts)
    m >>= k = ParseS (\ts -> case parse m ts of
                                ParseSuccess x ts' -> parse (k x) ts'
                                ParseError s       -> ParseError s)
    fail str = ParseS (\_ -> ParseError str)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lambdabot-haskell-plugins-5.1/src/Lambdabot/Plugin/Haskell/UnMtl.hs
Applicative instance: 


instance Applicative PMonad where
    pure = return
    (<*>) = ap
Monad instance: 


-- A monad instance so we get things like liftM and sequence for free
instance Monad PMonad where
    return t = PMonad t Nothing Nothing
    m >>= g  = let x = g (pResult m)
               in PMonad (pResult x) (pError m `mplus` pError x) Nothing
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/adaptive-tuple-0.2.0/src/Data/AdaptiveTuple/TH.hs
Applicative instance: 
 instance Functor (T1 s) => Applicative (T1 s) where pure a = T1 a; (T1 a) <*> (T1 b) = T1 (a b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hedn-0.1.8.2/src/Data/Parser.hs
Monad instance: 


instance Monad Result where
    return = Success
    {-# INLINE return #-}
    Success a >>= k = k a
    Error err >>= _ = Error err
    {-# INLINE (>>=) #-}
Applicative instance: 


instance Applicative Result where
    pure  = return
    {-# INLINE pure #-}
    (<*>) = ap
    {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Parser where
    m >>= g = Parser $ \kf ks -> let ks' a = runParser (g a) kf ks
                                 in runParser m kf ks'
    {-# INLINE (>>=) #-}
    return a = Parser $ \_kf ks -> ks a
    {-# INLINE return #-}
    fail msg = Parser $ \kf _ks -> kf msg
    {-# INLINE fail #-}
Applicative instance: 


instance Applicative Parser where
    pure  = return
    {-# INLINE pure #-}
    (<*>) = apP
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/async-extras-0.1.2.0/src/Control/Concurrent/Async/Extra.hs
Applicative instance: 


instance Applicative Promise where
  pure = Promise . return
  Promise f <*> Promise x = Promise $ uncurry ($) <$> concurrently f x
Monad instance: 


instance Monad Promise where
  return = pure
  Promise m >>= f = Promise $ async m >>= wait >>= unPromise . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/async-extras-0.1.2.0/src/Control/Concurrent/Async/Lifted/Extra.hs
Applicative instance: 


instance (b ~ IO, MonadBaseControl b m) => Applicative (Promise b m) where
  pure = Promise . return
  Promise f <*> Promise x = Promise $ uncurry ($) <$> concurrently f x
Monad instance: 


instance (b ~ IO, MonadBaseControl b m) => Monad (Promise b m) where
  return = pure
  Promise m >>= f = Promise $ async m >>= wait >>= unPromise . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/curves-1.1.0.2/Graphics/Curves/Trie.hs
Monad instance: 


instance Ord a => Monad (Trie a) where
  return x = singleton [] x
  m >>= k  = joinTrie (fmap k m)
Applicative instance: 


instance Ord a => Applicative (Trie a) where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/curves-1.1.0.2/Graphics/Curves/Colour.hs
Applicative instance: 


instance Applicative Colour' where
  pure x = Colour x x x x
  Colour fr fg fb fa <*> Colour r g b a = Colour (fr r) (fg g) (fb b) (fa a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wl-pprint-extras-3.5.0.5/src/Text/PrettyPrint/Free/Internal.hs
Applicative instance: 


instance Applicative Doc where
  pure = Effect
  (<*>) = ap
Monad instance: 


instance Monad Doc where
  return = Effect
  Fail >>= _ = Fail
  Empty >>= _ = Empty
  Char c >>= _ = Char c
  Text i s >>= _ = Text i s
  Line >>= _ = Line
  FlatAlt l r >>= k = FlatAlt (l >>= k) (r >>= k)
  Cat l r >>= k = Cat (l >>= k) (r >>= k)
  Nest i d >>= k = Nest i (d >>= k)
  Union l r >>= k = Union (l >>= k) (r >>= k)
  Effect e >>= k = k e
  Column f >>= k = Column (f >=> k)
  Nesting f >>= k = Nesting (f >=> k)
  Columns f >>= k = Columns (f >=> k)
  Ribbon f >>= k = Ribbon (f >=> k)
  fail _ = empty
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bencode-0.6.0.0/src/Data/BEncode/Parser.hs
Applicative instance: 



instance Applicative BParser where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad BParser where
    (BParser p) >>= f = BParser $ \b -> case p b of
                                          Ok a b' -> runB (f a) b'
                                          Error str -> Error str
    return val = BParser $ Ok val
    fail str = BParser $ \_ -> Error str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/snaplet-typed-sessions-0.5/src/Snap/Dialogues.hs
Monad instance: 



instance Monad m => Monad (Dlg m) where
    return         = Done
    Done x   >>= y = y x
    Action x >>= y = Action (x >>= return . (>>= y))
    Step p f >>= y = Step p (f >>= y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gang-of-threads-3.2.1/Control/Concurrent/Bag/BagT.hs
Applicative instance: 


instance Monad m => Applicative (BagT r m) where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad m => Monad (BagT r m) where
  return = BagT . return
  (BagT a) >>= b = BagT $ a >>= getBagReader . b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gang-of-threads-3.2.1/Control/Concurrent/Bag/Task.hs
Applicative instance: 


instance Applicative (TaskIO r) where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad (TaskIO r) where
  return = TaskIO . return
  (TaskIO a) >>= b = TaskIO $ a >>= getTaskReader . b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/GotoT-transformers-1.0.0.1/Control/Monad/Trans/Goto.hs
Applicative instance: 


instance Applicative m => Applicative (GotoT r m) where
    pure = GotoT . fmap Right . pure
    (GotoT m) <*> (GotoT x) = GotoT ((fmap h m) <*> x)
      where
        h (Left g) = const (Left g)
        h (Right f) = either Left (Right . f)
Monad instance: 

instance Monad m => Monad (GotoT r m) where
    return = GotoT . return . Right
    (GotoT m) >>= f = GotoT $ m >>= either (return . Left) (unwrapGotoT . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tensor-0.3.0.1/src/Data/Ordinal.hs
Monad instance: 


instance Monad Succ where
    First >>= _ = First
    (Succ x) >>= f = f x
    return = Succ
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tensor-0.3.0.1/src/Data/Tensor/Vector/Internal.hs
Applicative instance: 



instance MultiIndex i => Applicative (Tensor i) where
    pure e = T.replicate e
    (Tensor is f) <*> (Tensor _ v) = Tensor is (V.zipWith ($) f v)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/servant-server-0.8.1/src/Servant/Server/Internal/RoutingApplication.hs
Applicative instance: 


instance Applicative DelayedIO where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad DelayedIO where
  return x = DelayedIO (const $ return (Route x))
  DelayedIO m >>= f =
    DelayedIO $ \ req -> do
      r <- m req
      case r of
        Fail      e -> return $ Fail e
        FailFatal e -> return $ FailFatal e
        Route     a -> runDelayedIO (f a) req
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/powerpc-0.0.1/Language/PowerPC/RTL.hs
Monad instance: 


instance Monad RTL where
  return a = RTL (\ s -> (a, s))
  (RTL f1) >>= f2 = RTL f3
    where
    f3 s0 = f4 s1
      where
      (a, s1) = f1 s0
      RTL f4 = f2 a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pooled-io-0.0.2.1/src/Control/Concurrent/PooledIO/Final.hs
Applicative instance: 


instance Applicative T where
   pure = Cons . pure
   Cons f <*> Cons a = Cons $ f <*> a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pooled-io-0.0.2.1/src/Control/Concurrent/PooledIO/InOrder.hs
Applicative instance: 


instance Applicative T where
   pure = Cons . pure
   Cons f <*> Cons a = Cons $ f <*> a
Monad instance: 


instance Monad T where
   return = Cons . return
   Cons x >>= k  =  Cons $ decons . k =<< x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haddock-2.9.4/src/Haddock/Interface/Rn.hs
Monad instance: 

instance Monad Id where (Id v)>>=f = f v; return = Id
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haddock-2.9.4/src/Haddock/Interface/Rename.hs
Monad instance: 


instance Monad (GenRnM n) where
  (>>=) = thenRn
  return = returnRn
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haddock-2.9.4/src/Haddock/Types.hs
Monad instance: 



instance Monad ErrMsgM where
        return a = Writer (a, [])
        m >>= k  = Writer $ let
                (a, w)  = runWriter m
                (b, w') = runWriter (k a)
                in (b, w ++ w')
Monad instance: 



instance Monad ErrMsgGhc where
  return a = WriterGhc (return (a, []))
  m >>= k = WriterGhc $ runWriterGhc m >>= \ (a, msgs1) ->
               fmap (second (msgs1 ++)) (runWriterGhc (k a))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/transformers-eff-0.1.0.0/Control/Effect.hs
Applicative instance: 


instance Applicative (Eff f m) where
  pure a = Eff (\_ -> pure a)
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad (Eff f m) where
  return = pure
  {-# INLINE return #-}
  Eff a >>= f = Eff (\u -> a u >>= \b -> case f b of Eff g -> g u)
  {-# INLINE (>>=) #-}
Applicative instance: 


instance Applicative (Cont r) where
  pure x = Cont ($ x)
  {-# INLINE pure #-}
  f <*> v = Cont $ \c -> runCont f $ \g -> runCont v (c . g)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad (Cont r) where
  return x = Cont ($ x)
  {-# INLINE return #-}
  m >>= k = Cont $ \c -> runCont m (\x -> runCont (k x) c)
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lazyio-0.1.0.3/src/System/IO/Lazy/Applicative.hs
Applicative instance: 


instance Applicative T where
   pure = Cons . return . Chain.Cons Chain.RunAll
   Cons f <*> Cons x = Cons $ liftM2 (<*>) f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lazyio-0.1.0.3/src/System/IO/Lazy.hs
Monad instance: 


instance Monad T where
   return x = Cons $ return x
   x >>= f = Cons $
      mapStateT Unsafe.interleaveIO . decons . f =<<
      mapStateT Unsafe.interleaveIO (decons x)
Applicative instance: 


instance Applicative T where
   pure = return
   (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lazyio-0.1.0.3/src/Data/ApplicativeChain.hs
Applicative instance: 


instance Applicative T where
   pure = Cons RunAll
   Cons fs f <*> a =
      fmap f $ case fs of RunAll -> a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/attoparsec-trans-0.1.1.0/src/Control/Monad/Trans/Parser.hs
Applicative instance: 


instance Monad m => Applicative (ParserT i m) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad m => Monad (ParserT i m) where
  return r = ParserT $ \i -> return (DoneM i r)
  mr >>= f = ParserT $ \i -> runParserT mr i >>= rec f
    where
      rec f (FailM i s)  = return (FailM i s)
      rec f (DoneM i r)  = runParserT (f r) i
      rec f (PartialM p) = return . PartialM $ p >>= f
  fail s = ParserT $ \i -> return $ FailM i s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskell-type-exts-0.1.0/src/Language/Haskell/TypeCheck/Monad.hs
Monad instance: 


instance Monad Tc where
  return x = Tc (\_env -> return (Right x))
  fail err = Tc (\_env -> return (Left (text err)))
  m >>= k = Tc (\env -> do
                  r1 <- unTc m env
                  case r1 of
                    Left err -> return (Left err)
                    Right v -> unTc (k v) env)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wavesurfer-0.0.6/Sound/WaveSurfer.hs
Monad instance: 


-- | Monad instance for Either.
instance Monad (Either a) where
    return = Right
    x >>= f = case x of
                Left  a -> Left a
                Right r -> f r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hp2any-core-0.9.0/Profiling/Heap/Network.hs
Applicative instance: 


instance Applicative MsgParser where
    pure x = MP "" (Just . (,) x)
    MP pf gf <*> MP px gx = MP pf $ \s -> do
                                 (f,s') <- gf s
                                 s'' <- stripPrefix px s'
                                 (x,s''') <- gx s''
                                 return (f x,s''')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/blogination-0.5/executable/Main.hs
Applicative instance: 


instance Monad m => Applicative (ErrorT C.CPError m) where
    pure = return; (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cmu-1.9/src/Algebra/CommutativeMonoid/Main.hs
Monad instance: 


instance Monad AnsErr where
    (Ans x) >>= k = k x
    (Err s) >>= _ = Err s
    return        = Ans
    fail          = Err
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Nomyx-Core-0.7.6/src/Data/Todo.hs
Applicative instance: 


instance Applicative (Todo a) where
   pure                = Done
   Todo as <*> Todo bs = Todo $ as ++ bs
   Todo as <*> _       = Todo as
   Done f  <*> r       = fmap f r
Monad instance: 


instance Monad (Todo a) where
   return = Done
   Todo as >>= _ = Todo as
   Done a >>= f = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/IndexedList-0.1.0.1/Data/List/Indexed/Counted.hs
Applicative instance: 


instance (ReifyNatural n) => Applicative (CountedList n) where
   pure x    = replicate (reifyNatural :: Natural n) x
   fs <*> xs = uncurry id <$> zip fs xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gnutls-0.2/lib/Network/Protocol/TLS/GNU.hs
Applicative instance: 


instance Applicative TLS where
        pure = TLS . return
        (<*>) = ap
Monad instance: 


instance Monad TLS where
        return = TLS . return
        m >>= f = TLS $ unTLS m >>= unTLS . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gnutls-0.2/lib/Network/Protocol/TLS/GNU/ErrorT.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (ErrorT e m) where
        pure a  = ErrorT $ return (Right a)
        f <*> v = ErrorT $ do
                mf <- runErrorT f
                case mf of
                        Left  e -> return (Left e)
                        Right k -> do
                                mv <- runErrorT v
                                case mv of
                                        Left  e -> return (Left e)
                                        Right x -> return (Right (k x))
Monad instance: 


instance Monad m => Monad (ErrorT e m) where
        return = ErrorT . return . Right
        (>>=) m k = ErrorT $ do
                x <- runErrorT m
                case x of
                        Left l -> return $ Left l
                        Right r -> runErrorT $ k r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hole-0.1.1/src/Data/Hole/Strict.hs
Monad instance: 



instance Monad Hole where
    return = const Hole
    Hole >>= _ = Hole
    Hole >> _ = Hole
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hole-0.1.1/src/Data/Hole/Lazy.hs
Monad instance: 



instance Monad Hole where
    return = const Hole
    _ >>= _ = Hole
    _ >> _ = Hole
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/atto-lisp-0.2.2.2/Data/AttoLisp.hs
Monad instance: 


instance Monad Parser where
    m >>= g = Parser $ \kf ks -> let ks' a = runParser (g a) kf ks
                                  in runParser m kf ks'
    {-# INLINE (>>=) #-}
    return a = Parser $ \_kf ks -> ks a
    {-# INLINE return #-}
    fail msg = Parser $ \kf _ks -> kf msg
    {-# INLINE fail #-}
Applicative instance: 


instance Applicative Parser where
    pure  = return
    {-# INLINE pure #-}
    (<*>) = apP
    {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Result where
    return = Success
    {-# INLINE return #-}
    Success a >>= k = k a
    Error err >>= _ = Error err
    {-# INLINE (>>=) #-}
Applicative instance: 


instance Applicative Result where
    pure  = return
    {-# INLINE pure #-}
    (<*>) = ap
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/TeaHS-0.3.1/Tea/Tea.hs
Monad instance: 


instance Monad (Tea s) where
   return        = Tea . return
   (Tea a) >>= b = Tea $ a >>= extractTea . b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/List-0.5.2/src/Control/Monad/Trans/List.hs
Monad instance: 


instance Monad m => Monad (ListT m) where
    return = ListT . return . (`Cons` mempty)
    a >>= b = foldrL' mappend mempty (fmap b a)
Applicative instance: 


instance Monad m => Applicative (ListT m) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/vinyl-0.5.2/Data/Vinyl/Functor.hs
Applicative instance: 


instance (Applicative f, Applicative g) => Applicative (Compose f g) where
  pure x = Compose (pure (pure x))
  Compose f <*> Compose x = Compose ((<*>) <$> f <*> x)
Applicative instance: 


instance Applicative Identity where
  pure = Identity
  Identity f <*> Identity x = Identity (f x)
Monad instance: 


instance Monad Identity where
  return = Identity
  Identity x >>= f = f x
Applicative instance: 


instance Applicative Thunk where
  pure = Thunk
  (Thunk f) <*> (Thunk x) = Thunk (f x)
Monad instance: 


instance Monad Thunk where
  return = Thunk
  (Thunk x) >>= f = f x
Applicative instance: 


instance (Applicative f, Applicative g) => Applicative (Lift (,) f g) where
  pure x = Lift (pure x, pure x)
  Lift (f, g) <*> Lift (x, y) = Lift (f <*> x, g <*> y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/formura-1.0/src/Formura/Vec.hs
Applicative instance: 


instance Applicative Vec where
    pure x = PureVec x
    PureVec f <*> PureVec x = PureVec $ f x
    PureVec f <*> Vec xs    = Vec $ fmap f xs
    Vec fs <*> PureVec x    = Vec $ fmap ($x) fs
    Vec fs <*> Vec xs = Vec (zipWith id fs xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/husky-0.4/src/TokenParser.hs
Applicative instance: 




{- Definitions for Applicative Parsec instance -}

-- | Applicative instance for Monad
instance Applicative (GenParser s a) where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hxweb-0.1/src/Network/HxWeb/Monad.hs
Monad instance: 


instance Monad (WebPage st) where
    WebPage g >>= f
        = WebPage $
          do g' <- g
             case g' of
               Redirect url -> return (Redirect url)
               Fail msg -> return (Fail msg)
               WebResult ret -> unWebPage (f ret)
    fail = WebPage . return . Fail
    return = WebPage . return . WebResult
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rmonad-0.8.0.2/src/Control/RMonad/AsMonad.hs
Monad instance: 


instance RMonad m => Monad (AsMonad m) where
   return = Return
   (>>=) = Bind
   fail = Fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/protocol-buffers-2.4.0/Text/ProtocolBuffers/Get.hs
Monad instance: 


instance Monad Get where
  return a = seq a $ Get (\sc -> sc a)
  {-# INLINE return #-}
  m >>= k  = Get (\sc -> unGet m (\ a -> seq a $ unGet (k a) sc))
  {-# INLINE (>>=) #-}
  fail = throwError . strMsg
Applicative instance: 


instance Applicative Get where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/camfort-0.900/src/Camfort/Helpers.hs
Monad instance: 


#if __GLASGOW_HASKELL__ < 800
instance Monoid x => Monad ((,) x) where
    return a = (mempty, a)
    (x, a) >>= k = let (x', b) = k a
                   in (mappend x x', b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/quipper-0.7/src/Quipper/Circuit.hs
Monad instance: 


instance Monad ReadWrite where
  return a = RW_Return a
  f >>= g = case f of
    RW_Return a -> g a
    RW_Write gate f' -> RW_Write gate (f' >>= g)
    RW_Read bit cont -> RW_Read bit (\bool -> cont bool >>= g)
    RW_Subroutine name subroutine f' -> RW_Subroutine name subroutine (f' >>= g)
Applicative instance: 


instance Applicative ReadWrite where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/quipper-0.7/src/Quipper/Labels.hs
Monad instance: 


instance Monad LabelMonad where
  return a = LabelMonad (\idxl -> (Map.empty, a))
  f >>= g = LabelMonad h where
    h idxl = (Map.union m1 m2, z) where
      (m1, y) = getLabelMonad f idxl
      (m2, z) = getLabelMonad (g y) idxl
Applicative instance: 


instance Applicative LabelMonad where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/quipper-0.7/src/Quipper/Monad.hs
Monad instance: 


instance Monad Circ where
  return a = Circ (\s -> return (a, s))
  f >>= g = Circ h
    where
      h s0 = do
        (a, s1) <- getCirc f s0
        getCirc (g a) s1
Applicative instance: 


-- every monad is applicative, and so is this one
instance Applicative Circ where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/quipper-0.7/src/Libraries/Auxiliary.hs
Monad instance: 


instance Monad Id where
  return a = Id a
  (Id a) >>= b = b a
Applicative instance: 


instance Applicative Id where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/quipper-0.7/src/Libraries/Template/LiftQ.hs
Monad instance: 


instance Monad LiftQ where
  return x = LiftQ $ return x
  (>>=) (LiftQ x) f = LiftQ $ do
           x' <- x
           let (LiftQ y) = f x'
           y
Applicative instance: 


instance Applicative LiftQ where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/quipper-0.7/src/Libraries/Template/ErrorMsgQ.hs
Monad instance: 


instance Monad ErrMsgQ where
    return x = ErrMsgQ $ return $ return x
    (>>=) (ErrMsgQ x) f = ErrMsgQ $ do
              x' <- x
              case x' of
                 Left s -> return (Left s)
                 Right r -> let (ErrMsgQ y) = f r in y
Applicative instance: 


instance Applicative ErrMsgQ where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtl-c-0.1/Control/Monad/State/CPS.hs
Applicative instance: 


instance Applicative (StateT s m) where
    pure x = StateT $ \s c -> c x s
    {-# INLINABLE pure #-}
    mf <*> ma = StateT $ \s c -> unStateT mf s $ \f s' -> unStateT ma s' (c . f)
    {-# INLINABLE (<*>) #-}
Monad instance: 


instance Monad (StateT s m) where
    return x = StateT $ \s c -> c x s
    m >>= k = StateT $ \s c -> unStateT m s $ \a s' -> unStateT (k a) s' c
    {-# INLINABLE (>>=) #-}
    m >> n = StateT $ \s c -> unStateT m s $ \_ s' -> unStateT n s' c
    {-# INLINABLE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtl-c-0.1/Control/Monad/Reader/CPS.hs
Applicative instance: 


instance Applicative (ReaderT r m) where
    pure x = ReaderT $ \_ c -> c x
    {-# INLINABLE pure #-}
    mf <*> ma = ReaderT $ \r c -> unReaderT mf r $ \f -> unReaderT ma r (c . f)
    {-# INLINABLE (<*>) #-}
Monad instance: 


instance Monad (ReaderT r m) where
    return x = ReaderT $ \_ c -> c x
    {-# INLINABLE return #-}
    m >>= k = ReaderT $ \r c -> unReaderT m r (\a -> unReaderT (k a) r c)
    {-# INLINABLE (>>=) #-}
    m >> n = ReaderT $ \r c -> unReaderT m r (\_ -> unReaderT n r c)
    {-# INLINABLE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtl-c-0.1/Control/Monad/Writer/CPS.hs
Applicative instance: 


instance Monoid w => Applicative (WriterT w m) where
    pure x = WriterT $ \c -> c x mempty
    {-# INLINABLE pure #-}
    mf <*> ma = WriterT $ \c -> unWriterT mf $ \f !w -> unWriterT ma $ \a !w' -> c (f a) $! mappend w w'
    {-# INLINABLE (<*>) #-}
Monad instance: 


instance Monoid w => Monad (WriterT w m) where
    return x = WriterT $ \c -> c x mempty
    {-# INLINABLE return #-}
    m >>= k = WriterT $ \c -> unWriterT m $ \a !w -> unWriterT (k a) $ \b !w' -> c b $! mappend w w'
    {-# INLINABLE (>>=) #-}
    m >> n = WriterT $ \c -> unWriterT m $ \_ !w -> unWriterT n $ \b !w' -> c b $! mappend w w'
    {-# INLINABLE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/timeless-0.9.0.1/src/FRP/Timeless/Signal.hs
Applicative instance: 


instance (Monad m) => Applicative (Signal s m a) where
    pure = SConst . Just
    sf <*> sx =
        SGen $ \ds mx ->
        liftM2 (\(mf, sf) (mx, sx) -> lstrict (mf <*> mx, sf <*> sx))
        (stepSignal sf ds mx)
        (stepSignal sx ds mx)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/timeless-0.9.0.1/src/FRP/Timeless/Session.hs
Applicative instance: 


instance (Applicative m) => Applicative (Session m) where
    pure x = let s = Session (pure (x, s)) in s

    Session ff <*> Session fx =
        Session $ liftA2 (\(f, sf) (x, sx) -> (f x, sf <*> sx)) ff fx
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/libffi-0.1/examples/CCall.hs
Applicative instance: 


instance Applicative (GenParser tok st) where
    pure    = return
    (<*>)   = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Hoed-0.3.6/Debug/Hoed/NoTrace.hs
Applicative instance: 


#if __GLASGOW_HASKELL__ >= 710
instance Applicative ObserverM where
    pure  = return
    (<*>) = ap
Monad instance: 

#endif

instance Monad ObserverM where
        return a = ObserverM (\ c i -> (a,i))
        fn >>= k = ObserverM (\ c i ->
                case runMO fn c i of
                  (r,i2) -> runMO (k r) c i2
                )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pcf-0.1.0.1/src/Language/Pcf.hs
Applicative instance: 

instance Applicative Exp where
  pure = return
  (<*>) = ap
Monad instance: 

instance Monad Exp where
  return = V
  V a >>= f = f a
  App l r >>= f = App (l >>= f) (r >>= f)
  Lam t body >>= f = Lam t (body >>>= f)
  Fix t body >>= f = Fix t (body >>>= f)
  Ifz i t e >>= f = Ifz (i >>= f) (t >>= f) (e >>>= f)
  Suc e >>= f = Suc (e >>= f)
  Zero >>= _ = Zero
Applicative instance: 

instance Applicative ExpC where
  pure = return
  (<*>) = ap
Monad instance: 

instance Monad ExpC where
  return = VC
  VC a >>= f = f a
  AppC l r >>= f = AppC (l >>= f) (r >>= f)
  LamC t clos body >>= f = LamC t (map (>>= f) clos) (body >>>= f)
  FixC t clos body >>= f = FixC t (map (>>= f) clos) (body >>>= f)
  IfzC i t e >>= f = IfzC (i >>= f) (t >>= f) (e >>>= f)
  SucC e >>= f = SucC (e >>= f)
  ZeroC >>= _ = ZeroC
Applicative instance: 

instance Applicative ExpL where
  pure = return
  (<*>) = ap
Monad instance: 

instance Monad ExpL where
  return = VL
  VL a >>= f = f a
  AppL l r >>= f = AppL (l >>= f) (r >>= f)
  SucL e >>= f = SucL (e >>= f)
  ZeroL >>= _ = ZeroL
  IfzL i t e >>= f = IfzL (i >>= f) (t >>= f) (e >>>= f)
  LetL binds body >>= f = LetL (map go binds) (body >>>= f)
    where go (RecL t es scope) = RecL t (map (>>= f) es) (scope >>>= f)
          go (NRecL t es scope) = NRecL t (map (>>= f) es) (scope >>>= f)
Applicative instance: 

instance Applicative FauxC where
  pure = return
  (<*>) = ap
Monad instance: 

instance Monad FauxC where
  return = VFC
  VFC a >>= f = f a
  AppFC l r >>= f = AppFC (l >>= f) (r >>= f)
  SucFC e >>= f = SucFC (e >>= f)
  ZeroFC >>= _ = ZeroFC
  IfzFC i t e >>= f = IfzFC (i >>= f) (t >>= f) (e >>>= f)
  LetFC binds body >>= f = LetFC (map go binds) (body >>>= f)
    where go (NRecFC i es) = NRecFC i (map (>>= f) es)
          go (RecFC t i es) = RecFC t i (map (>>= f) es)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fuzzcheck-0.1.1/Test/FuzzCheck.hs
Applicative instance: 


instance Applicative Fuzz where
    pure x = Fuzz (Compose (pure (Pair (Const ["<arg>"]) (Identity x))))
    Fuzz f <*> Fuzz x = Fuzz (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/zmidi-core-0.8.1/src/ZMidi/Core/Internal/SimpleFormat.hs
Applicative instance: 



instance Applicative Table where
  pure a    = Table $ \_ s ac -> (s,ac,a)
  mf <*> ma = Table $ \r s ac ->
                let (s1,ac1,f) = getTable mf r s ac
                    (s2,ac2,a) = getTable ma r s1 ac1
                in (s2,ac2,f a)
Monad instance: 




instance Monad Table where
  return    = pure
  ma >>= k  = Table $ \r s ac ->
                let (s1,ac1,a) = getTable ma r s ac in getTable (k a) r s1 ac1
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/zmidi-core-0.8.1/src/ZMidi/Core/Internal/ParserMonad.hs
Applicative instance: 



instance Applicative ParserM where
  pure a    = ParserM $ \s -> (Right a, s)
  af <*> ma = ParserM $ \s -> let (ef,s')  = getParserM af s
                              in case ef of
                                Left e  -> (Left e, s')
                                Right f -> let (a,s'') = getParserM ma s'
                                           in (fmap f a,s'')
Monad instance: 


instance Monad ParserM where
  return a  = ParserM $ \s -> (Right a, s)
  m >>= k   = ParserM $ \s -> let (ea,s') = getParserM m s
                              in case ea of
                                Left e -> (Left e, s')
                                Right a -> (getParserM . k) a s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Tape-0.4.0.0/Data/Stream/Tape.hs
Applicative instance: 


-- | A tape is @Applicative@, where the @\<*\>@ is equivalent to its @ComonadApply@ instance (required
--   by law), and a pure value is the tape consisting of copies of that value in both directions.
instance Applicative Tape where
   (<*>) = (<@>)
   pure  = Tape <$> pure <*> id <*> pure
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hpp-0.3.1.0/src/Hpp/Parser.hs
Applicative instance: 


instance Monad m => Applicative (Parser m i) where
  pure x = Parser (pure x)
  {-# INLINE pure #-}
  Parser f <*> Parser x = Parser (f <*> x)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad m => Monad (Parser m i) where
  return = pure
  {-# INLINE return #-}
  Parser ma >>= fb = Parser $ ma >>= runParser . fb
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hpp-0.3.1.0/src/Hpp/Types.hs
Applicative instance: 


instance Monad m => Applicative (HppT t m) where
  pure = HppT . pure . PureF
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad m => Monad (HppT t m) where
  return = pure
  {-# INLINE return #-}
  HppT ma >>= fb = HppT $ ma >>= \case
                     PureF x -> runHppT $ fb x
                     FreeF x -> return . FreeF $ fmap (>>= fb) x
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hpp-0.3.1.0/src/Hpp/Streamer.hs
Applicative instance: 


instance Monad m => Applicative (Streamer m i o) where
  pure = Streamer . return . Done . Just
  {-# INLINE pure #-}
  Streamer ma <*> g = Streamer $ ma >>= \case
    Await f d -> return $ Await ((<*> g) . f) (d <*> g)
    Yield o n -> return $ Yield o (n <*> g)
    Done r -> maybe (runStream empty) (runStream . flip fmap g) r
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/xml-conduit-parse-0.3.1.0/Data/Conduit/Parser/XML.hs
Monad instance: 


instance Monad AttrParser where
  return a = AttrParser $ \attributes -> Right (attributes, a)
  (AttrParser p) >>= f = AttrParser $ p >=> (\(attributes', a) -> runAttrParser (f a) attributes')
Applicative instance: 


instance Applicative AttrParser where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/MagicHaskeller-0.9.6.5/MagicHaskeller/MyCheck.hs
Applicative instance: 

instance Applicative Gen where
    pure a = Gen $ \_ _ -> a
    (<*>)  = ap
Monad instance: 

instance Monad Gen where
    return      = pure
    Gen m >>= k = Gen $ \n g -> case split g of (g1,g2) -> unGen (k (m n g1)) n g2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/MagicHaskeller-0.9.6.5/Control/Monad/Search/Best.hs
Applicative instance: 

instance Applicative Best where
    pure x = Result [x]
    (<*>)  = ap
Monad instance: 

instance Monad Best where
    return = pure
    Result xs >>= f = msum $ map f xs
    Delay  b  >>= f = Delay $ b >>= f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskell-formatter-1.0.0/src/library/Language/Haskell/Formatter/Result.hs
Applicative instance: 


instance Applicative.Applicative Result where
        pure = return
        (<*>) = Monad.ap
Monad instance: 


instance Monad Result where
        return = Result . return
        Result result >>= action = Result $ result >>= toEither . action
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/colonnade-0.4/src/Colonnade/Internal.hs
Applicative instance: 


instance Monoid a => Applicative (EitherWrap a) where
  pure = EitherWrap . Right
  EitherWrap (Left a1) <*> EitherWrap (Left a2) = EitherWrap (Left (mappend a1 a2))
  EitherWrap (Left a1) <*> EitherWrap (Right _) = EitherWrap (Left a1)
  EitherWrap (Right _) <*> EitherWrap (Left a2) = EitherWrap (Left a2)
  EitherWrap (Right f) <*> EitherWrap (Right b) = EitherWrap (Right (f b))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/colonnade-0.4/src/Colonnade/Types.hs
Applicative instance: 


instance Applicative (Decoding f content) where
  pure = DecodingPure
  DecodingPure f <*> y = fmap f y
  DecodingAp h c y <*> z = DecodingAp h c (flip <$> y <*> z)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/xmonad-contrib-bluetilebranch-0.9.1.4/XMonad/Actions/GridSelect.hs
Applicative instance: 


instance Applicative (TwoD a) where
    (<*>) = ap
    pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liblastfm-0.6.0/src/Lastfm/Internal.hs
Applicative instance: 


instance Applicative (Request f) where
  pure x = Request (pure x)
  Request f <*> Request x = Request (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/multirec-0.7.6/src/Generics/MultiRec/Base.hs
Applicative instance: 


instance Applicative I0 where
  pure              = I0
  (I0 f) <*> (I0 x) = I0 (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/regex-applicative-0.3.3/Text/Regex/Applicative/Reference.hs
Monad instance: 


instance Monad (P s) where
    return x = P $ \s -> [(x, s)]
    (P a) >>= k = P $ \s ->
        a s >>= \(x,s) -> unP (k x) s
Applicative instance: 


instance Applicative (P s) where
    (<*>) = ap
    pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/regex-applicative-0.3.3/Text/Regex/Applicative/Interface.hs
Applicative instance: 


instance Applicative (RE s) where
    pure x = const x <$> Eps
    a1 <*> a2 = App a1 a2
    a *> b = pure (const id) <*> Void a <*> b
    a <* b = pure const <*> a <*> Void b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CouchDB-1.2.2/src/Database/CouchDB/HTTP.hs
Applicative instance: 


instance Applicative CouchMonad where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad CouchMonad where

  return a = CouchMonad $ \conn -> return (a,conn)

  (CouchMonad m) >>= k = CouchMonad $ \conn -> do
    (a,conn') <- m conn
    let (CouchMonad m') = k a
    m' conn'

  fail msg = CouchMonad $ \conn -> do
    fail $ "internal error: " ++ msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/intervals-0.7.2/src/Numeric/Interval/Kaucher.hs
Applicative instance: 


instance Applicative Interval where
  pure a = I a a
  {-# INLINE pure #-}
  I f g <*> I a b = I (f a) (g b)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Interval where
  return a = I a a
  {-# INLINE return #-}
  I a b >>= f = I a' b' where
    I a' _ = f a
    I _ b' = f b
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghcjs-hplay-0.3.4/src/GHCJS/HPlay/View.hs
Applicative instance: 


instance Applicative Widget where
  pure= return

  Widget (Transient x) <*> Widget (Transient y) = Widget . Transient $ do
      mx <- x --  !> "mx"--  !> "mx"
      my <- y --  !> "my"--  !> "my"
      return $ mx <*> my
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hxt-tagsoup-9.1.3/src/Text/XML/HXT/Parser/TagSoup.hs
Applicative instance: 


instance Applicative Parser where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad Parser where
    return x    = P $ \ ts -> (x, ts)
    p >>= f     = P $ \ ts -> let
                              (res, ts') = parse p ts
                              in
                              parse (f res) ts'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Checked-0.0.0.2/Data/Checked.hs
Applicative instance: 


-- |Checked values combine as you would expect, except that two Left values combine to set up a trace of warnings
instance Applicative Checked where
 pure v = Checked (Right v)
 (Checked (Right f)) <*> (Checked (Right v)) = Checked (Right (f v))
 (Checked (Right f)) <*> (Checked (Left ((t, s), mb, v))) = Checked (Left ((t, s), Just (Checked (Left ((t, s), mb, v))), f v))
 (Checked (Left ((t, s), mb, f))) <*> (Checked (Right v)) = Checked (Left ((t, s), mb, f v))
 (Checked (Left ((t, s), mb, f))) <*> (Checked (Left ((t', s'), mb', v'))) = Checked (Left ((t, s), Just (Checked (Left ((t', s'), mb', v'))), f v'))
Monad instance: 


-- |The monadic values also combine like the Applicative
instance Monad Checked where
 Checked (Right v) >>= k = k v
 Checked (Left (w, mb, v)) >>= k = pure id <$> Checked (Left (w, mb, v)) <*> k v
 return v = Checked (Right v)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lgtk-0.8.0.4/src/LGtk/Render.hs
Monad instance: 


instance Monad Maybe' where
    return = pure
    Just' x >>= f = f x
    _ >>= _ = Nothing'
Applicative instance: 


instance Applicative Maybe' where
    pure = Just'
    Just' f <*> Just' x = Just' $ f x
    _ <*> _ = Nothing'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unpack-funcs-0.3.1/Control/Monad/Unpack/Class.hs
Monad instance: 


instance (Unpackable arg, Monad m) => Monad (UnpackedReaderT arg m) where
  {-# INLINE return #-}
  {-# INLINE (>>=) #-}
  return x = lift $ return x
  m >>= k = unpackedReaderT $ \ arg ->
    do  a <- runUnpackedReaderT m arg
        runUnpackedReaderT (k a) arg
Applicative instance: 


instance (Unpackable arg, Applicative f) => Applicative (UnpackedReaderT arg f) where
  {-# INLINE pure #-}
  {-# INLINE (<*>) #-}
  pure f = unpackedReaderT $ \ _ -> pure f
  f <*> x = unpackedReaderT $ \ arg -> runUnpackedReaderT f arg <*> runUnpackedReaderT x arg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/failable-list-0.2/Data/FailableList.hs
Monad instance: 


instance Monad (FailableList e) where
        Done        >>= _ = Done
        Fail e      >>= _ = Fail e
        (Next x xs) >>= k = append (k x) (xs >>= k)
        return = flip Next Done
Applicative instance: 


instance A.Applicative (FailableList e) where
        pure = return
        (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/total-map-0.0.6/src/Data/TotalMap.hs
Applicative instance: 


instance Ord k => Applicative (TMap k) where
  pure v = TMap v mempty
  fs@(TMap df mf) <*> xs@(TMap dx mx) =
    tabulate (df dx)
             (M.keysSet mf `mappend` M.keysSet mx)
             ((!) fs <*> (!) xs)
Monad instance: 


-- Note: I'd like to 'trim' the tabulate result in <*>, but doing so would
-- require the Eq constraint on values, which breaks Applicative.

instance Ord k => Monad (TMap k) where
  return  = pure
  m >>= f = joinT (f <$> m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-0.5.0.0/Test/QuickCheck.hs
Applicative instance: 


instance Applicative QueryDenotation where
  pure    = QueryDenotation . pure . pure . pure
  f <*> x = QueryDenotation ((liftA2 . liftA2 . liftA2) ($)
                                (unQueryDenotation f) (unQueryDenotation x))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-0.5.0.0/src/Opaleye/Constant.hs
Applicative instance: 


instance Applicative (Constant a) where
  pure = Constant . pure
  Constant f <*> Constant x = Constant (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-0.5.0.0/src/Opaleye/Internal/Distinct.hs
Applicative instance: 


instance Applicative (Distinctspec a) where
  pure = Distinctspec . pure
  Distinctspec f <*> Distinctspec x = Distinctspec (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-0.5.0.0/src/Opaleye/Internal/Join.hs
Applicative instance: 


instance A.Applicative (NullMaker a) where
  pure = NullMaker . A.pure
  NullMaker f <*> NullMaker x = NullMaker (f A.<*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-0.5.0.0/src/Opaleye/Internal/RunQuery.hs
Applicative instance: 


-- TODO: Seems like this one should be simpler!
instance Applicative (QueryRunner c) where
  pure = flip (QueryRunner (P.lmap (const ()) PP.empty)) (const False)
         . pure
         . pure
  QueryRunner uf rf bf <*> QueryRunner ux rx bx =
    QueryRunner (P.dimap (\x -> (x,x)) (const ()) (uf PP.***! ux)) ((<*>) <$> rf <*> rx) (liftA2 (||) bf bx)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-0.5.0.0/src/Opaleye/Internal/TableMaker.hs
Applicative instance: 


instance Applicative (ViewColumnMaker a) where
  pure = ViewColumnMaker . pure
  ViewColumnMaker f <*> ViewColumnMaker x = ViewColumnMaker (f <*> x)
Applicative instance: 


instance Applicative (ColumnMaker a) where
  pure = ColumnMaker . pure
  ColumnMaker f <*> ColumnMaker x = ColumnMaker (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-0.5.0.0/src/Opaleye/Internal/Values.hs
Applicative instance: 


instance Applicative (Valuesspec a) where
  pure = Valuesspec . pure
  Valuesspec f <*> Valuesspec x = Valuesspec (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-0.5.0.0/src/Opaleye/Internal/Aggregate.hs
Applicative instance: 


instance Applicative (Aggregator a) where
  pure = Aggregator . pure
  Aggregator f <*> Aggregator x = Aggregator (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-0.5.0.0/src/Opaleye/Internal/Unpackspec.hs
Applicative instance: 


instance Applicative (Unpackspec a) where
  pure = Unpackspec . pure
  Unpackspec f <*> Unpackspec x = Unpackspec (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-0.5.0.0/src/Opaleye/Internal/QueryArr.hs
Applicative instance: 


instance Applicative (QueryArr a) where
  pure = arr . const
  f <*> g = arr (uncurry ($)) <<< (f &&& g)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-0.5.0.0/src/Opaleye/Internal/PackMap.hs
Applicative instance: 


instance Applicative (PackMap a b s) where
  pure x = PackMap (pure (pure (pure x)))
  PackMap f <*> PackMap x = PackMap (liftA2 (liftA2 (<*>)) f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-0.5.0.0/src/Opaleye/Internal/Binary.hs
Applicative instance: 


instance Applicative (Binaryspec a) where
  pure = Binaryspec . pure
  Binaryspec f <*> Binaryspec x = Binaryspec (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opaleye-0.5.0.0/src/Opaleye/Internal/Table.hs
Applicative instance: 


instance Applicative (Writer a) where
  pure x = Writer (fmap (const ()) (pure x))
  Writer f <*> Writer x = Writer (liftA2 (\_ _ -> ()) f x)
Applicative instance: 


instance Applicative (TableProperties a) where
  pure x = TableProperties (pure x) (View x)
  TableProperties fw (View fv) <*> TableProperties xw (View xv) =
    TableProperties (fw <*> xw) (View (fv xv))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sequent-core-0.5.0.1/src/Language/SequentCore/Simpl/Monad.hs
Monad instance: 


instance Monad SimplM where
  {-# INLINE return #-}
  return x = SimplM $
    \_ -> getDynFlags >>= \dflags -> return (x, zeroSimplCount dflags)

  {-# INLINE (>>=) #-}
  m >>= k
    = SimplM $ \mode -> do
        (x, count1) <- unSimplM m mode
        (y, count2) <- unSimplM (k x) mode
        let count = count1 `plusSimplCount` count2
        return $ count `seq` (y, count)
Applicative instance: 


instance Applicative SimplM where
  {-# INLINE pure #-}
  pure = return

  {-# INLINE (<*>) #-}
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/command-qq-0.3.0.0/example/CommandT.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (CommandT m) where
  pure = CommandT . pure
  CommandT f <*> CommandT x = CommandT (f <*> x)
Monad instance: 


instance (Functor m, Monad m) => Monad (CommandT m) where
  return = pure
  CommandT x >>= k = CommandT (x >>= unCommandT . k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uni-events-2.2.2.0/Events/Events.hs
Monad instance: 


-- ----------------------------------------------------------------------
-- Monadic Events
-- We include some extra GHC magic here, so that using "always"
-- in monadic events is not especially inefficient.
-- ----------------------------------------------------------------------

instance Monad Event where
   (>>=) = thenGetEvent
   (>>) = thenEvent
   return = doneEvent

   fail str = always (ioError (userError str))
Applicative instance: 


instance Applicative Event where
   pure = return
   (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/process-streaming-0.9.1.2/src/System/Process/Streaming.hs
Applicative instance: 


instance Applicative (Feed1 b e) where
    pure a = Feed1 (pure a)
    Feed1 fa <*> Feed1 a = Feed1 (fa <*> a)
Applicative instance: 


{-| 
    'pure' writes nothing to @stdin@.
    '<*>' sequences the writes to @stdin@.
-}
instance Applicative (Feed1_ b e) where
  pure = Feed1_ . pure . pure . pure
  Feed1_ fs <*> Feed1_ as =
      Feed1_ $ \consumer -> do
          (outbox1,inbox1,seal1) <- spawn' (bounded 1)
          (outbox2,inbox2,seal2) <- spawn' (bounded 1)
          runConceit $
              Conceit (runExceptT $ do
                           r1 <- ExceptT $ (fs $ toOutput outbox1)
                                               `finally` atomically seal1
                           r2 <- ExceptT $ (as $ toOutput outbox2)
                                               `finally` atomically seal2
                           return $ r1 r2
                      )
              <*
              Conceit (do
                         (runEffect $
                             (fromInput inbox1 >> fromInput inbox2) >-> consumer)
                            `finally` atomically seal1
                            `finally` atomically seal2
                         runExceptT $ pure ()
                      )
Applicative instance: 



{-| 
    'pure' writes nothing to @stdin@, discards the data coming from @stdout@ and @stderr@, and ignores the exit code.

    '<*>' combines handlers by sequencing the writes to @stdin@, and making concurrent reads from @stdout@ and @stderr@.
-}
instance Applicative (Streams e) where
    pure a = Streams (pure a)

    Streams f <*> Streams x = Streams (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/brainfuck-monad-0.5.0/Control/Monad/BrainFuck.hs
Monad instance: 


instance Monad BrainFuck where
        return = pure
        a >>= b = BrainFuck $ \start -> let
                (left, mid, val) = func a start
                (right, end, ret) = func (b val) mid
                in (left ++ right, end, ret)
Applicative instance: 


instance Applicative BrainFuck where
        pure v = BrainFuck $ \loc -> ([], loc, v)
        (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lojbanXiragan-0.3/src/Parse.hs
Monad instance: 
           -- unconditional error labeling

-- Standard monadic combinators
instance Derivs d => Monad (Parser d) where

        -- Sequencing combinator
        (Parser p1) >>= f = Parser parse

                where parse dvs = first (p1 dvs)

                      first (Parsed val rem err) =
                        let Parser p2 = f val
                        in second err (p2 rem)
                      first (NoParse err) = NoParse err

                      second err1 (Parsed val rem err) =
                        Parsed val rem (joinErrors err1 err)
                      second err1 (NoParse err) =
                        NoParse (joinErrors err1 err)

        -- Result-producing combinator
        return x = Parser (\dvs -> Parsed x dvs (nullError dvs))

        -- Failure combinator
        fail [] = Parser (\dvs -> NoParse (nullError dvs))
        fail msg = Parser (\dvs -> NoParse (msgError (dvPos dvs) msg))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/stringbuilder-0.5.0/src/Data/String/Builder.hs
Applicative instance: 


instance Applicative BuilderM where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad BuilderM where
  return a            = BuilderM a id
  BuilderM a xs >>= f = case f a of
    BuilderM b ys -> BuilderM b (xs . ys)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fixed-length-0.2/src/Data/FixedLength.hs
Applicative instance: 


instance Natural n => Applicative (T n) where
   pure = repeat
   f <*> x = zipWith ($) f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/algebra-4.3/src/Numeric/Algebra/Dual.hs
Applicative instance: 


instance Applicative Dual where
  pure = pureRep
  (<*>) = apRep
Monad instance: 


instance Monad Dual where
  return = pureRep
  (>>=) = bindRep
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/algebra-4.3/src/Numeric/Algebra/Complex.hs
Applicative instance: 


instance Applicative Complex where
  pure = pureRep
  (<*>) = apRep
Monad instance: 


instance Monad Complex where
  return = pureRep
  (>>=) = bindRep
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/algebra-4.3/src/Numeric/Algebra/Hyperbolic.hs
Applicative instance: 


instance Applicative Hyper' where
  pure = pureRep
  (<*>) = apRep
Monad instance: 


instance Monad Hyper' where
  return = pureRep
  (>>=) = bindRep
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/algebra-4.3/src/Numeric/Algebra/Quaternion.hs
Applicative instance: 


instance Applicative Quaternion where
  pure = pureRep
  (<*>) = apRep
Monad instance: 


instance Monad Quaternion where
  return = pureRep
  (>>=) = bindRep
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/algebra-4.3/src/Numeric/Map.hs
Applicative instance: 


instance Applicative (Map r b) where
  pure a = Map $ \k _ -> k a
  mf <*> ma = Map $ \k b -> (mf $# \f -> (ma $# k . f) b) b
Monad instance: 


instance Monad (Map r b) where
  return a = Map $ \k _ -> k a
  m >>= f = Map $ \k b -> (m $# \a -> (f a $# k) b) b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/algebra-4.3/src/Numeric/Coalgebra/Trigonometric.hs
Applicative instance: 


instance Applicative Trig where
  pure = pureRep
  (<*>) = apRep
Monad instance: 


instance Monad Trig where
  return = pureRep
  (>>=) = bindRep
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/algebra-4.3/src/Numeric/Coalgebra/Dual.hs
Applicative instance: 


instance Applicative Dual' where
  pure = pureRep
  (<*>) = apRep
Monad instance: 


instance Monad Dual' where
  return = pureRep
  (>>=) = bindRep
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/algebra-4.3/src/Numeric/Coalgebra/Hyperbolic.hs
Applicative instance: 


instance Applicative Hyper where
  pure = pureRep
  (<*>) = apRep
Monad instance: 


instance Monad Hyper where
  return = pureRep
  (>>=) = bindRep
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/algebra-4.3/src/Numeric/Coalgebra/Quaternion.hs
Applicative instance: 


instance Applicative Quaternion' where
  pure = pureRep
  (<*>) = apRep
Monad instance: 


instance Monad Quaternion' where
  return = pureRep
  (>>=) = bindRep
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/algebra-4.3/src/Numeric/Covector.hs
Applicative instance: 


instance Applicative (Covector r) where
  pure a = Covector $ \k -> k a
  mf <*> ma = Covector $ \k -> mf $* \f -> ma $* k . f
Monad instance: 


instance Monad (Covector r) where
  return a = Covector $ \k -> k a
  m >>= f = Covector $ \k -> m $* \a -> f a $* k
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Animas-0.2/src/FRP/Animas/Task.hs
Monad instance: 



------------------------------------------------------------------------------
-- Monad instance
------------------------------------------------------------------------------

instance Monad (Task a b) where
    tk >>= f = Task (\k -> (unTask tk) (\c -> unTask (f c) k))
    return x = Task (\k -> k x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lol-calculus-1.20160822/Language/LOL/Calculus/Abstraction.hs
Applicative instance: 

instance Monad expr => Applicative (Abstraction bound expr) where
        pure  = return
        (<*>) = ap
Monad instance: 

-- | A 'Monad' instance capturing the notion of /variable substitution/,
-- used by 'unabstract' to decrement the /DeBruijn indices/.
instance Monad expr => Monad (Abstraction bound expr) where
        return = Abstraction . return . Var_Free . return
        Abstraction expr >>= f = Abstraction $ expr >>= \var ->
                case var of
                 Var_Bound bound -> return (Var_Bound bound)
                 Var_Free  e     -> e >>= (\(Abstraction ex) -> ex) . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lol-calculus-1.20160822/Language/LOL/Calculus/Term.hs
Applicative instance: 


instance Applicative Term where
        pure = TeTy_Var
        (<*>) = ap
Monad instance: 

-- | A 'Monad' instance capturing the notion of /variable substitution/ with /capture-avoiding/.
instance Monad Term where
        return = pure
        Type_Sort        s >>= _  = Type_Sort s
        TeTy_Axiom       a >>= _  = TeTy_Axiom a
        TeTy_Var         v >>= go = go v
        TeTy_App    f    x >>= go = TeTy_App    (f    >>= go) (x  >>= go)
        Term_Abst v f_in f >>= go = Term_Abst v (f_in >>= go) (f >>>= go)
        Type_Abst v f_in f >>= go = Type_Abst v (f_in >>= go) (f >>>= go)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hedis-simple-0.1.0.0/src/Database/Redis/Simple.hs
Applicative instance: 


instance Applicative RedisTx where
  pure = RedisTx . pure . pure
  l <*> r = RedisTx $ (fromRedisTx l >>= \txl -> fromRedisTx r >>= \txr -> return $ txl <*> txr)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wumpus-basic-0.9.0/src/Wumpus/Basic/Paths/Construction.hs
Applicative instance: 



instance Applicative (PathM u) where
  pure a    = PathM $ \s -> (a,s)
  mf <*> ma = PathM $ \s -> let (f,s1) = getPathM mf s
                                (a,s2) = getPathM ma s1
                            in (f a,s2)
Monad instance: 


instance Monad (PathM u) where
  return a  = PathM $ \s -> (a,s)
  m >>= k   = PathM $ \s -> let (a,s1) = getPathM m s in
                            (getPathM . k) a s1
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wumpus-basic-0.9.0/src/Wumpus/Basic/Graphic/BaseTypes.hs
Applicative instance: 


-- Applicative

instance Applicative DrawingF where
  pure a    = DrawingF $ \_   -> a
  mf <*> ma = DrawingF $ \ctx -> let f = getDrawingF mf ctx
                                     a = getDrawingF ma ctx
                                 in f a
Monad instance: 


-- Monad 

instance Monad DrawingF where
  return a  = DrawingF $ \_   -> a
  ma >>= k  = DrawingF $ \ctx -> let a = getDrawingF ma ctx
                                 in (getDrawingF . k) a ctx
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wumpus-basic-0.9.0/src/Wumpus/Basic/Graphic/ScalingContext.hs
Applicative instance: 


instance Applicative (Scaling ux uy u) where
  pure a    = Scaling $ \_   -> a
  mf <*> ma = Scaling $ \ctx -> let f = getScaling mf ctx
                                    a = getScaling ma ctx
                                in (f a)
Monad instance: 


instance Monad (Scaling ux uy u) where
  return a = Scaling $ \_   -> a
  m >>= k  = Scaling $ \ctx -> let a = getScaling m ctx
                               in (getScaling . k) a ctx
Applicative instance: 


instance Monad m => Applicative (ScalingT ux uy u m) where
  pure a    = ScalingT $ \_   -> return a
  mf <*> ma = ScalingT $ \ctx -> getScalingT mf ctx >>= \f ->
                                 getScalingT ma ctx >>= \a ->
                                 return (f a)
Monad instance: 


instance Monad m => Monad (ScalingT ux uy u m) where
  return a = ScalingT $ \_   -> return a
  m >>= k  = ScalingT $ \ctx -> getScalingT m ctx >>= \a ->
                                (getScalingT . k) a ctx
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wumpus-basic-0.9.0/src/Wumpus/Basic/Graphic/Drawing.hs
Applicative instance: 




-- Applicative

instance Applicative (Drawing u) where
  pure a    = Drawing $ \_   s -> (a, s)
  mf <*> ma = Drawing $ \ctx s -> let (f,s1) = getDrawing mf ctx s
                                      (a,s2) = getDrawing ma ctx s1
                                 in (f a, s2)
Applicative instance: 



instance Monad m => Applicative (DrawingT u m) where
  pure a    = DrawingT $ \_   s -> return (a, s)
  mf <*> ma = DrawingT $ \ctx s -> getDrawingT mf ctx s  >>= \(f,s1) ->
                                   getDrawingT ma ctx s1 >>= \(a,s2) ->
                                   return (f a, s2)
Monad instance: 


-- Monad

instance Monad (Drawing u) where
  return a  = Drawing $ \_   s -> (a, s)
  ma >>= k  = Drawing $ \ctx s -> let (a,s1) = getDrawing ma ctx s
                                  in (getDrawing . k) a ctx s1
Monad instance: 





instance Monad m => Monad (DrawingT u m) where
  return a  = DrawingT $ \_   s -> return (a, s)
  ma >>= k  = DrawingT $ \ctx s -> getDrawingT ma ctx s       >>= \(a,s1) ->
                                   (getDrawingT . k) a ctx s1
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wumpus-basic-0.9.0/src/Wumpus/Basic/Monads/TurtleMonad.hs
Applicative instance: 



-- Applicative 

instance Monad m => Applicative (TurtleT u m) where
  pure a    = TurtleT $ \s -> return (a,s)
  mf <*> ma = TurtleT $ \s -> getTurtleT mf s  >>= \(f,s')  ->
                              getTurtleT ma s' >>= \(a,s'') ->
                              return (f a,s'')
Monad instance: 



-- Monad 

instance Monad m => Monad (TurtleT u m) where
  return a = TurtleT $ \s -> return (a,s)
  m >>= k  = TurtleT $ \s -> getTurtleT m s        >>= \(a,s')  ->
                             (getTurtleT . k) a s' >>= \(b,s'') ->
                             return (b,s'')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wumpus-basic-0.9.0/src/Wumpus/Basic/Text/LRText.hs
Applicative instance: 



instance Applicative (LRText u) where
  pure a    = LRText $ \_ s -> (a,s)
  mf <*> ma = LRText $ \r s -> let (f,s')  = getLRText mf r s
                                   (a,s'') = getLRText ma r s'
                               in (f a,s'')
Monad instance: 


instance Monad (LRText u) where
  return a  = LRText $ \_ s -> (a,s)
  m >>= k   = LRText $ \r s -> let (a,s')  = getLRText m r s
                               in (getLRText . k) a r s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/noodle-0.0.19/src/lib/Language/Noodle/Parsing/Generic.hs
Monad instance: 



-- monad instance for parsers applied to state and token types
instance Monad (GParser s t) where
  return value     = P (\(state,tokens) -> Success value state tokens)
  fail message     = P (\(state,_) -> Failure message state)
  (>>=) (P f) cont = P body where
      body (state,tokens)
            = let first = f (state,tokens)
              in case first of
                (Failure msg fstate)             -> Failure msg fstate -- encountered failure, propogate
                (Success result sstate stokens)  -> appcont result sstate stokens -- ok, apply continuation
      appcont result state tokens
            = let (P rest) = cont result in rest (state,tokens)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Obsidian-0.4.0.0/Obsidian/Program.hs
Monad instance: 


---------------------------------------------------------------------------
-- Monad
--------------------------------------------------------------------------
instance Monad (Program t) where
  return = Return
  (>>=) = Bind
Applicative instance: 


---------------------------------------------------------------------------
-- Applicative 
---------------------------------------------------------------------------
instance Applicative (Program t) where
  pure = return
  ff <*> fa =
    do
      f <- ff
      fmap f fa
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/peakachu-0.3.1/src/FRP/Peakachu/Program.hs
Applicative instance: 


instance Applicative (Program a) where
    pure x =
        Program
        { progVals = pure x
        , progMore = (pure . pure) (pure x)
        }
    left <*> right =
        Program
        { progVals = progVals left <*> progVals right
        , progMore = (liftA2 . liftA2) (<*>) (progMore left) (progMore right)
        }
Monad instance: 


instance Monad (AppendProgram a) where
    return x = AppendProg $ Program [x] Nothing
    AppendProg left >>= right =
        mconcat $ map right (progVals left) ++ [rest]
        where
            rest =
                AppendProg Program
                { progVals = []
                , progMore =
                    (fmap . fmap . withAppendProgram1)
                    (>>= right) (progMore left)
                }
Applicative instance: 


instance Applicative (AppendProgram a) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HCL-1.4/src/System/Console/HCL.hs
Monad instance: 



{- |
Request behavior as a @Monad@ covers failure - when
a request results in @Nothing@, all bind
operations fail afterwards. Thus, when one request fails,
all subsequent requests automatically fail. -}
instance Monad Request where
  return x = makeReq x
  f >>= g = f `andMaybe` g
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chp-plus-1.3.1.2/Control/Concurrent/CHP/Test.hs
Monad instance: 


instance Monad CHPTest where
  return = CHPTest . return . Right
  m >>= k = CHPTest $ runCHPTest m >>= either (return . Left) (runCHPTest . k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/zeromq4-haskell-0.6.5/src/System/ZMQ4/Monadic.hs
Monad instance: 


instance Monad (ZMQ z) where
    return = ZMQ . return
    (ZMQ m) >>= f = ZMQ $ m >>= _unzmq . f
Applicative instance: 


instance Applicative (ZMQ z) where
    pure  = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ReplicateEffects-0.3/Control/Replicate.hs
Applicative instance: 


-- | Pairwise addition.
-- 
-- 'pure' is the singleton set of exactly zero occurrences {0}. It is
-- synonymous with 'zero'.
--
-- '<*>' produces the set of occurrences that are the sums of all possible
-- pairs from the two operands. 
-- 
-- An example: sequencing @'exactly' 2@ {2} with @'exactly' 3@ {3} produces
-- {2+3} = {5}.
-- 
-- Another example: sequencing the set {0, 1} ('opt') with itself produces
-- {0+0, 0+1, 1+0, 1+1} = {0, 1, 1, 2} = {0, 1, 2}. In case of overlap, like
-- in this example, '<*>' favors the heads (of type @Maybe b@) from the left
-- operand.
instance Applicative (Replicate a) where
  pure = zero

  -- lowerBound (f1 <*> f2) = lowerBound f1 + lowerBound f2
  -- upperBound (f1 <*> f2) = upperBound f1 + upperBound f2
  Nil <*> _ = Nil
  Cons fx mx xs <*> ys =  -- 0 + n = n
                       maybe empty ((<$> ys) . fx) mx
                   <|> -- (1 + m) + n = 1 + (m + n)
                       Cons id Nothing ((\x y z -> fx (x z) y) <$> xs <*> ys)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/neither-0.3.1.1/Data/Neither.hs
Monad instance: 

instance Monad (MEither a) where
    return = MRight
    (MLeft a) >>= _ = MLeft a
    (MRight b) >>= f = f b
Applicative instance: 

instance Applicative (MEither a) where
    pure = return
    (<*>) = ap
Applicative instance: 

instance Monoid a => Applicative (AEither a) where
    pure = ARight
    ALeft x <*> ALeft y = ALeft $ x `mappend` y
    ALeft x <*> _ = ALeft x
    _ <*> ALeft y = ALeft y
    ARight x <*> ARight y = ARight $ x y
Applicative instance: 

instance (Functor m, Monad m) => Applicative (MEitherT e m) where
    pure = return
    (<*>) = ap
Monad instance: 

instance Monad m => Monad (MEitherT e m) where
    return = MEitherT . return . return
    (MEitherT x) >>= f = MEitherT $
        x >>= meither (return . MLeft) (runMEitherT . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Holumbus-Searchengine-1.2.3/src/Control/Monad/ReaderStateIO.hs
Monad instance: 


instance Monad (ReaderStateIO env state) where
    return v
        = RSIO $ \ _e s -> return (v, s)

    RSIO cmd >>= f
        = RSIO $ \ e s -> do
                          (r', s') <- cmd e s
                          let RSIO cmd2 = f r'
                          s' `seq` cmd2 e s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/elerea-2.9.0/FRP/Elerea/Param.hs
Applicative instance: 


instance Applicative (SignalGen p) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad (SignalGen p) where
  return x = SG $ \_ _ -> return x
  SG g >>= f = SG $ \p i -> g p i >>= \x -> unSG (f x) p i
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/elerea-2.9.0/FRP/Elerea/Simple.hs
Applicative instance: 


instance Applicative SignalGen where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad SignalGen where
    return x = SG $ \_ -> return x
    SG g >>= f = SG $ \p -> g p >>= \x -> unSG (f x) p
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/raw-feldspar-0.1/src/Feldspar/Data/Validated.hs
Applicative instance: 


instance Applicative Validated
  where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad Validated
  where
    return = Validated true
    Validated valid a >>= k = Validated (valid && valid') b
      where
        Validated valid' b = k a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/raw-feldspar-0.1/src/Feldspar/Data/Vector.hs
Applicative instance: 


-- | This instance behaves like the list instance:
--
-- > pure x    = [x]
-- > fs <*> xs = [f x | f <- fs, x <- xs]
instance Applicative (Push m)
  where
    pure a = Push 1 $ \write -> write 0 a
    vec1 <*> vec2 = Push (len1*len2) $ \write -> do
        dumpPush vec2 $ \i2 a ->
          dumpPush vec1 $ \i1 f ->
            write (i1*len2 + i2) (f a)
      where
        (len1,len2) = (length vec1, length vec2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/spaceprobe-0.3.0/Control/SpaceProbe/Internal/Probe.hs
Applicative instance: 


instance Applicative Probe where
  pure x = Probe x (const []) (Just . id)
  (Probe x0 f0 d0) <*> (Probe x1 f1 d1) = Probe (x0, x1) f d
    where f (s0, s1) = map (tipConcatMap (t1 . fst)) $ t0 s1
            where t0 s1' = [do {s0' <- t; return (s0', s1')} | t <- f0 s0]
                  t1 s0' = [do {s1' <- t; return (s0', s1')} | t <- f1 s1]
          d (s0, s1) = d0 s0 <*> d1 s1
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tpdb-1.3.3/src/TPDB/Xml.hs
Applicative instance: 


instance Applicative CParser where
    pure = return ; (<*>) = ap
Monad instance: 


instance Monad CParser where
    return x = CParser $ \ cs -> return ( x, cs )
    CParser p >>= f = CParser $ \ cs0 ->
        do ( x, cs1 ) <- p cs0 ; unCParser ( must_succeed $ f x ) cs1
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cnc-spec-compiler-0.2.0.1/Intel/Cnc/EasyEmit.hs
Monad instance: 


-- BOILERPLATE, because of newtype rather than type synonym for EasyEmit:
instance Monad EasyEmit where
  -- Whew, need to verify that this has no perfermance overhead:
  (EE ma) >>= fn = EE (ma >>= (\x -> case fn x of EE m -> m))
  return x       = EE (return x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/argparser-0.3.4/src/System/Console/ArgParser/BaseType.hs
Applicative instance: 


instance Applicative ParserSpec where
  pure val = ParserSpec [] $ pure val
  ParserSpec d1 p1 <*> ParserSpec d2 p2 =
    ParserSpec (d1 ++ d2) (p1 <*> p2)
Applicative instance: 


instance Applicative Parser where
  pure val = Parser parser where
    parser args = (Right val, args)
  (Parser f) <*> (Parser g) = Parser (\args ->
    let (h, newargs) = f args
        (res, lastargs) = g newargs
    in (h <*> res, lastargs))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Catana-0.3/Control/Monad/Catana.hs
Applicative instance: 


instance Applicative (Catana i o b) where
  f <*> x = Catana $ step f . flip (step . (<$> x))
  pure = Catana . flip ($)
Monad instance: 


instance Monad (Catana i o b) where
  return = pure
  m >>= f = Catana $ step m . flip (step . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-ghc74-0.10.4/Distribution/Client/Tar.hs
Monad instance: 


instance Monad Partial where
    return        = Ok
    Error m >>= _ = Error m
    Ok    x >>= k = k x
    fail          = Error
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-ghc74-0.10.4/Distribution/Client/Dependency/Types.hs
Monad instance: 


instance Monad (Progress step fail) where
  return a = Done a
  p >>= f  = foldProgress Step Fail f p
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/taskpool-0.1.0/Data/TaskPool/Internal.hs
Applicative instance: 


instance Applicative Tasks where
    pure x = Tasks $ \_ -> return ([], return x)
    Tasks f <*> Tasks x = Tasks $ \pool -> do
        (xh, xa) <- x pool
        (tx, x') <- wrap pool xh xa
        (fh, fa) <- f pool
        return (tx:fh, fa >>= flip fmap x')
      where
        wrap pool hs action = atomically $ do
            mv <- newEmptyTMVar
            t <- submitTask_ pool $ atomically . putTMVar mv =<< action
            forM_ hs $ unsafeSequenceTasks pool t
            return (t, atomically $ takeTMVar mv)
Monad instance: 


instance Monad Tasks where
    return = pure
    Tasks m >>= f = Tasks $ \pool -> do
        (_mh, mx) <- m pool
        mx >>= flip runTasks' pool . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hinquire-0.1.1/test/properties.hs
Applicative instance: 


instance Applicative Identity where
    pure a = Identity a
    Identity f <*> Identity x = Identity (f x)
Monad instance: 


instance Monad Identity where
    return a = Identity a
    m >>= k  = k (runIdentity m)
Applicative instance: 


instance (Applicative f, Applicative g) => Applicative (Compose f g) where
    pure x = Compose (pure (pure x))
    Compose f <*> Compose x = Compose ((<*>) <$> f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hinquire-0.1.1/src/Network/Hinquire.hs
Applicative instance: 


instance Monoid k => Applicative (Inquire k) where
    pure = Predicate mempty Equal

    Atom <*> _ = Atom
    _ <*> Atom = Atom
    (Predicate _ _ f) <*> (Predicate k r v) = Predicate k r (f v)
    p@Predicate {} <*> (Group i1 b i2) = Group (p <*> i1) b (p <*> i2)
    p@Predicate {} <*> (Wrap b i) = Wrap b (p <*> i)
    (Group i1 b i2) <*> i3 = Group (i1 <*> i3) b (i2 <*> i3)
    (Wrap b i1) <*> i2 = Wrap b (i1 <*> i2)
Monad instance: 


instance Monoid k => Monad (Inquire k) where
    return = Predicate mempty Equal

    Atom >>= _ = Atom
    -- This seems wrong,
    -- we've forgotten everything about our Predicate except the value
    (Predicate _ _ v) >>= f = f v
    (Group i1 b i2) >>= f = Group (i1 >>= f) b (i2 >>= f)
    (Wrap b i) >>= f = Wrap b (i >>= f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/zeromq3-haskell-0.5.2/src/System/ZMQ3/Monadic.hs
Monad instance: 


instance Monad (ZMQ z) where
    return = ZMQ . return
    (ZMQ m) >>= f = ZMQ $! m >>= _unzmq . f
Applicative instance: 


instance Applicative (ZMQ z) where
    pure  = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CSPM-Frontend-0.9.2.0/src/Language/CSPM/AlexWrapper.hs
Monad instance: 


instance Monad Alex where
  m >>= k  = Alex $ \s -> case unAlex m s of
                            Left msg -> Left msg
                            Right (s',a) -> unAlex (k a) s'
  return a = Alex $ \s -> Right (s,a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/JustParse-2.1/src/Data/JustParse/Internal.hs
Applicative instance: 


instance Applicative (Parser s) where
    pure = return
    {-# INLINE pure #-}
    (<*>) = ap
    {-# INLINE (<*>) #-}
Monad instance: 


instance Monad (Parser s) where
    return v = Parser $ \s -> [Done v s]
    {-# INLINE return #-}
    (Parser p) >>= f = Parser $ p >=> g
        where
            g (Done a s) = parse (f a) s
            g (Partial p) = [Partial $ p >=> g]
    {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/deepcontrol-0.5.4.3/DeepControl/Monad/Trans/Identity.hs
Applicative instance: 


instance (Applicative m1, Applicative m2) => Applicative (IdentityT2 m1 m2) where
    pure x = IdentityT2 $ (.**) x
    (<*>) = lift2IdentityT2 (|*>>)
Monad instance: 

instance (Monad m1, Monad m2, Traversable m2) => Monad (IdentityT2 m1 m2) where
    return = IdentityT2 . (.**)
    m >>= f = IdentityT2 $ runIdentityT2 m >>== (f >-> runIdentityT2)
Applicative instance: 


instance (Applicative m1, Applicative m2, Applicative m3) => Applicative (IdentityT3 m1 m2 m3) where
    pure x = IdentityT3 $ (.***) x
    (<*>) = lift2IdentityT3 (|*>>>)
Monad instance: 

instance (Monad m1, Monad m2, Traversable m2, Monad m3, Traversable m3) => Monad (IdentityT3 m1 m2 m3) where
    return = IdentityT3 . (.***)
    m >>= f = IdentityT3 $ runIdentityT3 m >>>= (f >-> runIdentityT3)
Applicative instance: 


instance (Applicative m1, Applicative m2, Applicative m3, Applicative m4) => Applicative (IdentityT4 m1 m2 m3 m4) where
    pure x = IdentityT4 $ (.****) x
    (<*>) = lift2IdentityT4 (|*>>>>)
Monad instance: 

instance (Monad m1, Monad m2, Traversable m2, Monad m3, Traversable m3, Monad m4, Traversable m4) => Monad (IdentityT4 m1 m2 m3 m4) where
    return = IdentityT4 . (.****)
    m >>= f = IdentityT4 $ runIdentityT4 m >>>>= (f >-> runIdentityT4)
Applicative instance: 


instance (Applicative m1, Applicative m2, Applicative m3, Applicative m4, Applicative m5) => Applicative (IdentityT5 m1 m2 m3 m4 m5) where
    pure x = IdentityT5 $ (.*****) x
    (<*>) = lift2IdentityT5 (|*>>>>>)
Monad instance: 

instance (Monad m1, Monad m2, Traversable m2, Monad m3, Traversable m3, Monad m4, Traversable m4, Monad m5, Traversable m5) => Monad (IdentityT5 m1 m2 m3 m4 m5) where
    return = IdentityT5 . (.*****)
    m >>= f = IdentityT5 $ runIdentityT5 m >>>>>= (f >-> runIdentityT5)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/shady-gen-0.5.1/src/Shady/Vec.hs
Applicative instance: 


instance IsNat n => Applicative (Vec n) where
  pure  = pureV
  (<*>) = applyV
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/derivation-trees-0.7.3/DerivationTrees.hs
Applicative instance: 



instance Monoid t => Applicative (Writer t) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/djinn-lib-0.0.1.2/src/Djinn/LJT.hs
Applicative instance: 


instance Applicative P where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad P where
  return x  = P $ \ s -> [(s, x)]
  P m >>= f = P $ \ s -> [ y | (s',x) <- m s, y <- unP (f x) s' ]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/withdependencies-0.2.3/Control/Dependency.hs
Applicative instance: 


instance Applicative (Require identifier content) where
    pure  = Pure
    (<*>) = Ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/acid-state-0.8.3/src/Data/Acid/Common.hs
Applicative instance: 


-- mtl pre-2.0 doesn't have these instances to newtype-derive, but they're
-- simple enough.
instance Applicative (Update st) where
    pure = return
    (<*>) = ap
Applicative instance: 


instance Applicative (Query st) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/raaz-0.0.2/Raaz/Core/MonoidalAction.hs
Applicative instance: 


-- Proof of functor laws.
--
-- fmap id (TwistRF (x, m)) = TwistRF (fmap id x, m)
--                          = TwistRF (x, m)
--
-- fmap (f . g)  (TwistRF fx m) = TwistRF (fmap (f . g) x, m)
--                              = TwistRF (fmap f . fmap g $ x, m)
--                              = TwistRF (fmap f (fmap g x), m)
--                              = fmap f   $ TwistRF (fmap g x,  m)
--                              = (fmap f . fmap g) (TwistRF fx) m)
--

instance DistributiveF m f => Applicative (TwistRF f m) where
  pure a = TwistRF (pure a) mempty
  {-# INLINE pure #-}

  (TwistRF f mf)  <*> (TwistRF val mval)  = TwistRF res mres
    where res  = f <*> mf <<.>> val
          mres = mf <> mval
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/raaz-0.0.2/Raaz/Core/Memory.hs
Applicative instance: 


instance Applicative (MT mem) where
  pure       = MT . const . pure
  mf <*> ma  = MT $ \ m -> unMT mf m <*> unMT ma m
Monad instance: 


instance Monad (MT mem) where
  return    =  MT . const . return
  ma >>= f  =  MT runIt
    where runIt mem = unMT ma mem >>= \ a -> unMT (f a) mem
Applicative instance: 


instance Applicative MemoryM where
  pure  x       = MemoryM $ \ _ -> return x
  -- Beware: do not follow the hlint suggestion. The ugly definition
  -- is to avoid usage of impredicative polymorphism.

  memF <*> memA = MemoryM $ \ runner ->  unMemoryM memF runner <*> unMemoryM memA runner
Monad instance: 


instance Monad MemoryM where
  return = pure
  memA >>= f    = MemoryM $ \ runner -> do a <- unMemoryM memA runner
                                           unMemoryM (f a) runner
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/OneTuple-0.2.1/Data/Tuple/OneTuple.hs
Applicative instance: 


instance Applicative OneTuple where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad OneTuple where
    (OneTuple x) >>= f = f x
    return = OneTuple
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/explicit-sharing-0.9/Control/Monad/Sharing/Implementation/CPS.hs
Monad instance: 


-- The monad instance is an inlined version of the instances for
-- continuation and reader monads.
instance Nondet n => Monad (Lazy n)
 where
  return x = Lazy (\c -> c x)
  a >>= k  = Lazy (\c s -> fromLazy a (\x -> fromLazy (k x) c) s)
  fail _   = Lazy (\_ _ -> failure)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/binary-store-0.1.0.1/Format/BinaryStore.hs
Applicative instance: 


instance Applicative TValue where
  {-# INLINE pure #-}
  pure = Full []
  {-# INLINE (<*>) #-}
  Full ps f <*> Full ps' x = Full (ps ++ ps') (f x)
  _ <*> _ = Hole
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/murder-1.3.4/src/Language/Grammars/Grammar.hs
Applicative instance: 


instance Applicative (PreProductions l env) where
 pure f = PP [ Pure f ]

 (PP f) <*> (PP g) = PP [ Star f' g' | f' <- f, g' <- g ]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dockerfile-0.1.0.1/Control/Monad/Writer.hs
Applicative instance: 


instance Applicative Identity where
    pure a = Identity a
    Identity f <*> Identity x = Identity (f x)
Monad instance: 


instance Monad Identity where
    return a = Identity a
    m >>= k  = k (runIdentity m)
Applicative instance: 


instance (Functor m, Monad m) => Applicative (WriterT w m) where
    pure a = WriterT $ \w -> return (a,w)
    WriterT mf <*> WriterT mx = WriterT $ \w -> do
        (f, w') <- mf w
        (x, w'') <- mx w'
        return (f x, w'')
    {-# INLINE (<*>) #-}
Monad instance: 


instance (Monad m, Monoid w) => Monad (WriterT w m) where
    return a = WriterT $ \w -> return (a, w)
    m >>= f  = WriterT $ \w -> do
        (a, w') <- unWriterT m w
        unWriterT (f a) w'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/getopt-generics-0.9/src/System/Console/GetOpt/Generics/Result.hs
Applicative instance: 


instance Applicative Result where
  pure = Success
  OutputAndExit message <*> _ = OutputAndExit message
  _ <*> OutputAndExit message = OutputAndExit message
  Success f <*> Success x = Success (f x)
  Errors a <*> Errors b = Errors (a ++ b)
  Errors errs <*> Success _ = Errors errs
  Success _ <*> Errors errs = Errors errs
Monad instance: 


instance Monad Result where
  return = pure
  Success a >>= b = b a
  Errors errs >>= _ = Errors errs
  OutputAndExit message >>= _ = OutputAndExit message

  (>>) = (*>)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/QuickCheck-2.9.1/Test/QuickCheck/Property.hs
Applicative instance: 


instance Applicative Rose where
  pure = return
  -- f must be total
  (<*>) = liftM2 ($)
Monad instance: 


instance Monad Rose where
  return x = MkRose x []
  -- k must be total
  m >>= k  = joinRose (fmap k m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/QuickCheck-2.9.1/Test/QuickCheck/Monadic.hs
Applicative instance: 


instance Monad m => Applicative (PropertyM m) where
  pure = return
  (<*>) = liftM2 ($)
Monad instance: 


instance Monad m => Monad (PropertyM m) where
  return x            = MkPropertyM (\k -> k x)
  MkPropertyM m >>= f = MkPropertyM (\k -> m (\a -> unPropertyM (f a) k))
  fail s              = stop (failed { reason = s })
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/QuickCheck-2.9.1/Test/QuickCheck/Gen.hs
Applicative instance: 


instance Applicative Gen where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad Gen where
  return x =
    MkGen (\_ _ -> x)

  MkGen m >>= k =
    MkGen (\r n ->
      let (r1,r2)  = split r
          MkGen m' = k (m r1 n)
       in m' r2 n
    )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/logict-state-0.1.0.2/src/Control/Monad/LogicState.hs
Applicative instance: 


instance Applicative (LogicStateT gs bs f) where
    pure a = LogicStateT $ \sk -> sk a
    f <*> a = LogicStateT $ \sk -> unLogicStateT f (\g -> unLogicStateT a (sk . g))
Monad instance: 


instance Monad (LogicStateT gs bs m) where
    return a = LogicStateT ($ a)
    m >>= f = LogicStateT $ \sk -> unLogicStateT m (\a -> unLogicStateT (f a) sk)
    fail _ = LogicStateT $ flip const
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/representable-tries-3.0.2/src/Control/Monad/Reader/Trie.hs
Applicative instance: 


instance (HasTrie a, Applicative m) => Applicative (ReaderTrieT a m) where
  pure = ReaderTrieT . pure . pure
  ReaderTrieT ff <*> ReaderTrieT fa = ReaderTrieT ((<*>) <$> ff <*> fa)
Monad instance: 


instance (HasTrie a, Monad m) => Monad (ReaderTrieT a m) where
  return = ReaderTrieT . pure . return
  ReaderTrieT fm >>= f = ReaderTrieT $ tabulate (\a -> index fm a >>= flip index a . runReaderTrieT . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/representable-tries-3.0.2/src/Data/Functor/Representable/Trie.hs
Applicative instance: 


instance HasTrie a => Applicative ((:->:) a) where
  pure a = Trie (pureRep a)
  (<*>) = apRep
  a <* _ = a
  _ *> b = b
Monad instance: 


instance HasTrie a => Monad ((:->:) a) where
  return a = Trie (pureRep a)
  (>>=) = (>>-)
  _ >> m = m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/representable-tries-3.0.2/src/Data/Functor/Representable/Trie/Either.hs
Applicative instance: 


instance (Applicative f, Applicative g) => Applicative (EitherTrie f g) where
  pure a = EitherTrie (pure a) (pure a)
  EitherTrie ff fg <*> EitherTrie af ag = EitherTrie (ff <*> af) (fg <*> ag)
  a <* _ = a
  _ *> b = b
Monad instance: 


instance (Representable f, Representable g) => Monad (EitherTrie f g) where
  return = pureRep
  (>>=) = bindRep
  _ >> a = a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/representable-tries-3.0.2/src/Data/Functor/Representable/Trie/List.hs
Applicative instance: 


instance Representable f => Applicative (ListTrie f) where
  pure a = as where as = ListTrie a (pureRep as)
  (<*>) = apRep
  a <* _ = a
  _ *> b = b
Monad instance: 


instance Representable f => Monad (ListTrie f) where
  return a = as where as = ListTrie a (pureRep as)
  (>>=) = bindRep
  _ >> a = a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/representable-tries-3.0.2/src/Data/Functor/Representable/Trie/Bool.hs
Applicative instance: 


instance Applicative BoolTrie where
  pure a = BoolTrie a a
  (<*>) = (<.>)
  a <* _ = a
  _ *> b = b
Monad instance: 


instance Monad BoolTrie where
  return = pure
  BoolTrie a b >>= f = BoolTrie (false (f a)) (true (f b))
  _ >> a = a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/indices-1.7.1/src/Data/Index.hs
Applicative instance: 


instance KnownNat s => Applicative ((:.) s) where
  {-# INLINE pure #-}
  {-# INLINE (<*>) #-}
  {-# INLINE (*>) #-}
  {-# INLINE (<*) #-}
  pure x                    = 1:.x
  d@(ix0 :. f) <*> ix1 :. x = ((ix0*ix1) `rem` dimHead d) :. f x
  (*>)                      = (>>)
  (<*)                      = flip (>>)
Monad instance: 


instance KnownNat s => Monad ((:.) s) where
  {-# INLINE return #-}
  {-# INLINE (>>=) #-}
  return x              = 1:.x
  d@(ix0:.a) >>= f      = case f a of
    ix1 :. b -> ((ix0*ix1) `rem` dimHead d) :. b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dbus-client-0.4.1/hs/DBus/Client.hs
Monad instance: 


instance Monad DBus where
        return = DBus . return
        (>>=) (DBus m) f = DBus $ m >>= unDBus . f
Applicative instance: 


instance A.Applicative DBus where
        pure = return
        (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/visual-graphrewrite-0.4.0.1/GraphRewrite/Internal/Rename.hs
Monad instance: 



--instance Monad Result where
instance Monad (Result) where

        a >>= b = case a of
                Error err        -> fail err
                Ok x            -> b x

        fail = Error

        return = Ok
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/stm-2.4.4.1/Control/Sequential/STM.hs
Applicative instance: 


instance Applicative STM where
    pure = STM . const . pure
    STM mf <*> STM mx = STM $ \ r -> mf r <*> mx r
Monad instance: 


instance Monad STM where
    return = pure
    STM m >>= k = STM $ \ r -> do
        x <- m r
        unSTM (k x) r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sunroof-compiler-0.2/Language/Sunroof/Types.hs
Monad instance: 


instance Monad (JS t) where
  return a = JS $ \ k -> return a >>= k
  m >>= k = JS $ \ k0 -> unJS m (\ r -> unJS (k r) k0)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/envparse-0.4/src/Env/Internal/Parser.hs
Applicative instance: 


instance Applicative (Parser e) where
  pure =
    Parser . pure
  Parser f <*> Parser x =
    Parser (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/envparse-0.4/src/Env/Internal/Val.hs
Applicative instance: 


instance Monoid e => Applicative (Val e) where
  pure = Ok

  Err e <*> Err e' = Err (e <> e')
  Err e <*> _      = Err e
  _     <*> Err e' = Err e'
  Ok  f <*> Ok  a  = Ok (f a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/envparse-0.4/src/Env/Internal/Free.hs
Applicative instance: 


instance Functor f => Applicative (Alt f) where
  pure = Pure
  (<*>) = Ap
Applicative instance: 


instance Monoid m => Applicative (Mon m) where
  pure _ = Mon mempty
  Mon x <*> Mon y = Mon (mappend x y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/event-driven-0.0.2/Control/Talk.hs
Monad instance: 


instance Monad ( TalkM t ) where
  return a         = Terminus $ \_   t -> ( a, t )
  Terminus x >>= f = Terminus $ \tms t ->
    let ( v, t' ) = x tms t
     in case f v of
          Delegate -> ( error "not allow delegate here", t' )
          term     -> runTerminus term tms t'
  Delegate   >>= _ = Delegate
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-lgbt-0.0.2/src/Control/Monad/State/LGBT.hs
Applicative instance: 


instance Applicative (LGBT localState globalState m) where
  LGBT f <*> LGBT a = LGBT $ f <*> a
  pure v            = LGBT $ pure v
Monad instance: 


instance Monad                              m
      => Monad (LGBT localState globalState m) where
  return v     = LGBT $ return v
  LGBT a >>= b = LGBT $ a >>= (_unLGBT . b)
  fail   s     = LGBT $ fail s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-lgbt-0.0.2/src/Control/Monad/Backtrack.hs
Applicative instance: 


instance Applicative (BacktrackT r m) where
    pure x  = BacktrackT  (\_cf cs -> cs x)
    {-# INLINE pure #-}
    f <*> v = BacktrackT $ \cf cs -> runBacktrackT f cf
                         $ \r     -> runBacktrackT v cf (cs . r)
    {-# INLINE (<*>) #-}
Monad instance: 


instance Monad (BacktrackT r m) where
    m >>= k  = BacktrackT $ \cf cs -> runBacktrackT m cf (\v -> runBacktrackT (k v) cf cs)
    fail s   = BacktrackT $ \cf _cs -> cf s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wumpus-microprint-0.9.0/src/Wumpus/Microprint/Tokenizer.hs
Applicative instance: 


instance Applicative Lexer where
  pure a    = Lexer $ \_ s -> (a,s)
  mf <*> ma = Lexer $ \r s -> let (f,s1) = getLexer mf r s
                                  (a,s2) = getLexer ma r s1
                              in (f a, s2)
Monad instance: 


instance Monad Lexer where
  return a = Lexer $ \_ s -> (a,s)
  m >>= k  = Lexer $ \r s -> let (a,s1) = getLexer m r s
                              in (getLexer . k) a r s1
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wumpus-microprint-0.9.0/src/Wumpus/Microprint/Teletype.hs
Applicative instance: 


instance Applicative Teletype where
  pure a    = Teletype $ \w s -> (a,w,s)
  mf <*> ma = Teletype $ \w s -> let (f,w1,s1) = getTeletype mf w  s
                                     (a,w2,s2) = getTeletype ma w1 s1
                                  in (f a,w2,s2)
Monad instance: 


instance Monad Teletype where
  return a = Teletype $ \w s -> (a,w,s)
  m >>= k  = Teletype $ \w s -> let (a,w1,s1) = getTeletype m w s
                                 in (getTeletype . k) a w1 s1
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/vacuum-2.2.0.0/src/GHC/Vacuum/Internal.hs
Applicative instance: 

instance Applicative (S s) where
  pure  = return
  (<*>) = ap
Monad instance: 

instance Monad (S s) where
  return a = S (\k -> k a)
  S g >>= f = S (\k -> g (\a -> unS (f a) k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hexpr-0.0.0.0/Language/Distfix.hs
Applicative instance: 


instance Applicative (DistfixResult' e) where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad (DistfixResult' e) where
    return = Result . Right
    (Result x) >>= k = Result (x >>= unResult . k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hexpr-0.0.0.0/Control/Monad/Environment.hs
Applicative instance: 


instance (Ref.C m) => Applicative (EnvironmentT k v m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance (Ref.C m) => Monad (EnvironmentT k v m) where
    return = E . return
    x >>= k = E (unEnvT . k =<< unEnvT x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hexpr-0.0.0.0/Control/Monad/Gensym.hs
Applicative instance: 


instance (Monad m) => Applicative (SymbolGenT s m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance (Monad m) => Monad (SymbolGenT s m) where
    return = SymbolGenT . return
    x >>= k = SymbolGenT $ unSymbolGenT x >>= unSymbolGenT . k
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hexpr-0.0.0.0/Control/Monad/Stack.hs
Applicative instance: 

instance (Monad m) => Applicative (StackT s m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance (Monad m) => Monad (StackT s m) where
    return = StackT . return
    x >>= k = StackT $ unStack x >>= unStack . k
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hexpr-0.0.0.0/Control/Monad/Errors.hs
Applicative instance: 


instance (Monad m, Monoid e) => Applicative (ErrorsT e m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance (Monad m, Monoid e) => Monad (ErrorsT e m) where
    return x = ErrorsT . return $ \e -> (Just x, e)
    x >>= k = ErrorsT $ do
        eRes <- runErrorsT x
        case eRes of
            Left err -> return $ \e -> (Nothing, e <> Just err)
            Right val -> unErrors $ k val
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/funsat-0.6.2/src/Funsat/Monad.hs
Monad instance: 


instance Monad (SSTErrMonad e st s) where
    return x = SSTErrMonad ($ x)
    (>>=)    = bindSSTErrMonad
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/Control/Applicative.hs
Applicative instance: 


instance Monad m => Applicative (WrappedMonad m) where
    pure = WrapMonad . pure
    WrapMonad f <*> WrapMonad v = WrapMonad (f `ap` v)
Applicative instance: 


instance Arrow a => Applicative (WrappedArrow a b) where
    pure x = WrapArrow (arr (const x))
    WrapArrow f <*> WrapArrow v = WrapArrow (f &&& v >>> arr (uncurry id))
Applicative instance: 

-- See Data.Traversable for Traversabel instance due to import loops

instance Applicative ZipList where
    pure x = ZipList (repeat x)
    ZipList fs <*> ZipList xs = ZipList (zipWith id fs xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/Control/Arrow.hs
Applicative instance: 


instance Arrow a => Applicative (ArrowMonad a) where
   pure x = ArrowMonad (arr (const x))
   ArrowMonad f <*> ArrowMonad x = ArrowMonad (f &&& x >>> arr (uncurry id))
Monad instance: 


instance ArrowApply a => Monad (ArrowMonad a) where
    ArrowMonad m >>= f = ArrowMonad $
        m >>> arr (\x -> let ArrowMonad h = f x in (h, ())) >>> app
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/Control/Monad/ST/Lazy/Imp.hs
Applicative instance: 


instance Applicative (ST s) where
    pure a = ST $ \ s -> (a,s)
    (<*>) = ap
Monad instance: 


instance Monad (ST s) where

        fail s   = errorWithoutStackTrace s

        (ST m) >>= k
         = ST $ \ s ->
           let
             (r,new_s) = m s
             ST k_a = k r
           in
           k_a new_s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/Data/List/NonEmpty.hs
Applicative instance: 


instance Applicative NonEmpty where
  pure a = a :| []
  (<*>) = ap
Monad instance: 


instance Monad NonEmpty where
  ~(a :| as) >>= f = b :| (bs ++ bs')
    where b :| bs = f a
          bs' = as >>= toList . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/Data/Functor/Identity.hs
Applicative instance: 


instance Applicative Identity where
    pure     = Identity
    (<*>)    = coerce
Monad instance: 


instance Monad Identity where
    m >>= k  = k (runIdentity m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/Data/Functor/Compose.hs
Applicative instance: 


instance (Applicative f, Applicative g) => Applicative (Compose f g) where
    pure x = Compose (pure (pure x))
    Compose f <*> Compose x = Compose ((<*>) <$> f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/Data/Functor/Product.hs
Applicative instance: 


instance (Applicative f, Applicative g) => Applicative (Product f g) where
    pure x = Pair (pure x) (pure x)
    Pair f g <*> Pair x y = Pair (f <*> x) (g <*> y)
Monad instance: 


instance (Monad f, Monad g) => Monad (Product f g) where
    Pair m n >>= f = Pair (m >>= fstP . f) (n >>= sndP . f)
      where
        fstP (Pair a _) = a
        sndP (Pair _ b) = b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/Data/Functor/Const.hs
Applicative instance: 


instance Monoid m => Applicative (Const m) where
    pure _ = Const mempty
    (<*>) = coerce (mappend :: m -> m -> m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/Data/Either.hs
Applicative instance: 


instance Applicative (Either e) where
    pure          = Right
    Left  e <*> _ = Left e
    Right f <*> r = fmap f r
Monad instance: 


instance Monad (Either e) where
    Left  l >>= _ = Left l
    Right r >>= k = k r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/Data/Complex.hs
Applicative instance: 


instance Applicative Complex where
  pure a = a :+ a
  f :+ g <*> a :+ b = f a :+ g b
Monad instance: 


instance Monad Complex where
  a :+ b >>= f = realPart (f a) :+ imagPart (f b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/Data/Monoid.hs
Applicative instance: 


instance Applicative Dual where
    pure     = Dual
    (<*>)    = coerce
Monad instance: 


instance Monad Dual where
    m >>= k  = k (getDual m)
Applicative instance: 


instance Applicative Sum where
    pure     = Sum
    (<*>)    = coerce
Monad instance: 


instance Monad Sum where
    m >>= k  = k (getSum m)
Applicative instance: 


instance Applicative Product where
    pure     = Product
    (<*>)    = coerce
Monad instance: 


instance Monad Product where
    m >>= k  = k (getProduct m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/Data/Semigroup.hs
Applicative instance: 


instance Applicative Min where
  pure = Min
  a <* _ = a
  _ *> a = a
  Min f <*> Min x = Min (f x)
Monad instance: 


instance Monad Min where
  (>>) = (*>)
  Min a >>= f = f a
Applicative instance: 


instance Applicative Max where
  pure = Max
  a <* _ = a
  _ *> a = a
  Max f <*> Max x = Max (f x)
Monad instance: 


instance Monad Max where
  (>>) = (*>)
  Max a >>= f = f a
Applicative instance: 


instance Applicative First where
  pure x = First x
  a <* _ = a
  _ *> a = a
  First f <*> First x = First (f x)
Monad instance: 


instance Monad First where
  (>>) = (*>)
  First a >>= f = f a
Applicative instance: 


instance Applicative Last where
  pure = Last
  a <* _ = a
  _ *> a = a
  Last f <*> Last x = Last (f x)
Monad instance: 


instance Monad Last where
  (>>) = (*>)
  Last a >>= f = f a
Applicative instance: 


instance Applicative Option where
  pure a = Option (Just a)
  Option a <*> Option b = Option (a <*> b)

  Option Nothing  *>  _ = Option Nothing
  _               *>  b = b
Monad instance: 


instance Monad Option where
  Option (Just a) >>= k = k a
  _               >>= _ = Option Nothing
  (>>) = (*>)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/Data/Traversable.hs
Applicative instance: 


instance Applicative (StateL s) where
    pure x = StateL (\ s -> (s, x))
    StateL kf <*> StateL kv = StateL $ \ s ->
        let (s', f) = kf s
            (s'', v) = kv s'
        in (s'', f v)
Applicative instance: 


instance Applicative (StateR s) where
    pure x = StateR (\ s -> (s, x))
    StateR kf <*> StateR kv = StateR $ \ s ->
        let (s', v) = kv s
            (s'', f) = kf s'
        in (s'', f v)
Applicative instance: 


instance Applicative Id where
    pure = Id
    Id f <*> Id x = Id (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/Data/Proxy.hs
Applicative instance: 


instance Applicative Proxy where
    pure _ = Proxy
    {-# INLINE pure #-}
    _ <*> _ = Proxy
    {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Proxy where
    _ >>= _ = Proxy
    {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/GHC/Generics.hs
Applicative instance: 


instance Applicative U1 where
  pure _ = U1
  _ <*> _ = U1
Monad instance: 


instance Monad U1 where
  _ >>= _ = U1
Applicative instance: 


instance Applicative Par1 where
  pure a = Par1 a
  Par1 f <*> Par1 x = Par1 (f x)
Monad instance: 


instance Monad Par1 where
  Par1 x >>= f = f x
Applicative instance: 


instance Applicative f => Applicative (Rec1 f) where
  pure a = Rec1 (pure a)
  Rec1 f <*> Rec1 x = Rec1 (f <*> x)
Monad instance: 


instance Monad f => Monad (Rec1 f) where
  Rec1 x >>= f = Rec1 (x >>= \a -> unRec1 (f a))
Applicative instance: 


instance Applicative f => Applicative (M1 i c f) where
  pure a = M1 (pure a)
  M1 f <*> M1 x = M1 (f <*> x)
Monad instance: 


instance Monad f => Monad (M1 i c f) where
  M1 x >>= f = M1 (x >>= \a -> unM1 (f a))
Applicative instance: 


instance (Applicative f, Applicative g) => Applicative (f :*: g) where
  pure a = pure a :*: pure a
  (f :*: g) <*> (x :*: y) = (f <*> x) :*: (g <*> y)
Monad instance: 


instance (Monad f, Monad g) => Monad (f :*: g) where
  (m :*: n) >>= f = (m >>= \a -> fstP (f a)) :*: (n >>= \a -> sndP (f a))
    where
      fstP (a :*: _) = a
      sndP (_ :*: b) = b
Applicative instance: 


instance (Applicative f, Applicative g) => Applicative (f :.: g) where
  pure x = Comp1 (pure (pure x))
  Comp1 f <*> Comp1 x = Comp1 (fmap (<*>) f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/GHC/GHCi.hs
Applicative instance: 


instance Applicative NoIO where
  pure a = NoIO (pure a)
  (<*>) = ap
Monad instance: 


instance Monad NoIO where
    (>>=) k f = NoIO (noio k >>= noio . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/GHC/ST.hs
Applicative instance: 


instance Applicative (ST s) where
    {-# INLINE pure #-}
    {-# INLINE (*>)   #-}
    pure x = ST (\ s -> (# s, x #))
    m *> k = m >>= \ _ -> k
    (<*>) = ap
Monad instance: 


instance Monad (ST s) where
    {-# INLINE (>>=)  #-}
    (>>) = (*>)
    (ST m) >>= k
      = ST (\ s ->
        case (m s) of { (# new_s, r #) ->
        case (k r) of { ST k2 ->
        (k2 new_s) }})
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/GHC/Base.hs
Applicative instance: 


instance Monoid a => Applicative ((,) a) where
    pure x = (mempty, x)
    (u, f) <*> (v, x) = (u `mappend` v, f x)
Monad instance: 


instance Monoid a => Monad ((,) a) where
    (u, a) >>= k = case k a of (v, b) -> (u `mappend` v, b)
Applicative instance: 


instance Applicative ((->) a) where
    pure = const
    (<*>) f g x = f x (g x)
Monad instance: 


instance Monad ((->) r) where
    f >>= k = \ r -> k (f r) r
Applicative instance: 


instance Applicative Maybe where
    pure = Just

    Just f  <*> m       = fmap f m
    Nothing <*> _m      = Nothing

    Just _m1 *> m2      = m2
    Nothing  *> _m2     = Nothing
Monad instance: 


instance  Monad Maybe  where
    (Just x) >>= k      = k x
    Nothing  >>= _      = Nothing

    (>>) = (*>)

    fail _              = Nothing
Applicative instance: 


-- See Note: [List comprehensions and inlining]
instance Applicative [] where
    {-# INLINE pure #-}
    pure x    = [x]
    {-# INLINE (<*>) #-}
    fs <*> xs = [f x | f <- fs, x <- xs]
    {-# INLINE (*>) #-}
    xs *> ys  = [y | _ <- xs, y <- ys]
Monad instance: 


-- See Note: [List comprehensions and inlining]
instance Monad []  where
    {-# INLINE (>>=) #-}
    xs >>= f             = [y | x <- xs, y <- f x]
    {-# INLINE (>>) #-}
    (>>) = (*>)
    {-# INLINE fail #-}
    fail _              = []
Applicative instance: 


instance Applicative IO where
    {-# INLINE pure #-}
    {-# INLINE (*>) #-}
    pure   = returnIO
    m *> k = m >>= \ _ -> k
    (<*>)  = ap
Monad instance: 


instance  Monad IO  where
    {-# INLINE (>>)   #-}
    {-# INLINE (>>=)  #-}
    (>>)      = (*>)
    (>>=)     = bindIO
    fail s    = failIO s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/Text/ParserCombinators/ReadP.hs
Applicative instance: 


-- Monad, MonadPlus

instance Applicative P where
  pure x = Result x Fail
  (<*>) = ap
Monad instance: 


instance Monad P where
  (Get f)      >>= k = Get (\c -> f c >>= k)
  (Look f)     >>= k = Look (\s -> f s >>= k)
  Fail         >>= _ = Fail
  (Result x p) >>= k = k x <|> (p >>= k)
  (Final r)    >>= k = final [ys' | (x,s) <- r, ys' <- run (k x) s]

  fail _ = Fail
Applicative instance: 


instance Applicative ReadP where
    pure x = R (\k -> k x)
    (<*>) = ap
Monad instance: 


instance Monad ReadP where
  fail _    = R (\_ -> Fail)
  R m >>= f = R (\k -> m (\a -> let R m' = f a in m' k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-4.9.0.0/Text/ParserCombinators/ReadPrec.hs
Applicative instance: 


instance Applicative ReadPrec where
    pure x  = P (\_ -> pure x)
    (<*>) = ap
Monad instance: 


instance Monad ReadPrec where
  fail s    = P (\_ -> fail s)
  P f >>= k = P (\n -> do a <- f n; let P f' = k a in f' n)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tree-monad-0.3/Control/Monad/SearchTree.hs
Applicative instance: 


instance Applicative SearchTree where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad SearchTree where
  return = One

  None       >>= _ = None
  One x      >>= f = f x
  Choice s t >>= f = Choice (s >>= f) (t >>= f)

  fail _ = None
Applicative instance: 


instance Applicative Search where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad Search where
  return x = Search ($x)
  a >>= f  = Search (\k -> search a (\x -> search (f x) k))
  fail _   = mzero
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/capped-list-1.2/Data/CappedList.hs
Monad instance: 


instance Monoid cap => Monad (CappedList cap) where
        (>>=) = flip concatMapM
        return = flip Next (Cap mempty)
Applicative instance: 


instance Monoid cap => A.Applicative (CappedList cap) where
        pure = return
        (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-ghc72-0.10.4/Distribution/Client/Tar.hs
Monad instance: 


instance Monad Partial where
    return        = Ok
    Error m >>= _ = Error m
    Ok    x >>= k = k x
    fail          = Error
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cabal-install-ghc72-0.10.4/Distribution/Client/Dependency/Types.hs
Monad instance: 


instance Monad (Progress step fail) where
  return a = Done a
  p >>= f  = foldProgress Step Fail f p
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/transient-0.4.2.2/src/Transient/Internals.hs
Applicative instance: 





instance Applicative TransIO where
  pure a  = Transient . return $ Just a

  f <*> g = Transient $ do
         rf <- liftIO $ newIORef (Nothing,[])
         rg <- liftIO $ newIORef (Nothing,[])   -- !> "NEWIOREF"

         fs  <- getContinuations

         let

             hasWait (_:Wait:_)= True
             hasWait _ = False

             appf k = Transient $  do
                   Log rec _ full <- getData `onNothing` return (Log False [] [])
                   (liftIO $ writeIORef rf  (Just k,full))
--                                !> ( show $ unsafePerformIO myThreadId) ++"APPF"
                   (x, full2)<- liftIO $ readIORef rg
                   when (hasWait  full ) $
                       -- !> (hasWait full,"full",full, "\nfull2",full2)) $
                        let full'= head full: full2
                        in (setData $ Log rec full' full')     -- !> ("result1",full')

                   return $ Just k <*> x

             appg x = Transient $  do
                   Log rec _ full <- getData `onNothing` return (Log False [] [])
                   liftIO $ writeIORef rg (Just x, full)
--                      !> ( show $ unsafePerformIO myThreadId)++ "APPG"
                   (k,full1) <- liftIO $ readIORef rf
                   when (hasWait  full) $
                       -- !> ("full", full, "\nfull1",full1)) $
                        let full'= head full: full1
                        in (setData $ Log rec full' full')   -- !> ("result2",full')

                   return $ k <*> Just x

         setContinuation f appf fs


         k <- runTrans f
                  -- !> ( show $ unsafePerformIO myThreadId)++ "RUN f"
         was <- getData `onNothing` return NoRemote
         when (was == WasParallel) $  setData NoRemote

         Log recovery _ full <- getData `onNothing` return (Log False [] [])



         if was== WasRemote  || (not recovery && was == NoRemote  && isNothing k )
--               !>  ("was,recovery,isNothing=",was,recovery, isNothing k)
         -- if the first operand was a remote request
         -- (so this node is not master and hasn't to execute the whole expression)
         -- or it was not an asyncronous term (a normal term without async or parallel
         -- like primitives) and is nothing
           then  do
             restoreStack fs
             return Nothing
           else do
             when (isJust k) $ liftIO $ writeIORef rf  (k,full)
                -- when necessary since it maybe WasParallel and Nothing

             setContinuation g appg fs

             x <- runTrans g
                    --  !> ( show $ unsafePerformIO myThreadId) ++ "RUN g"
             Log recovery _ full' <- getData `onNothing` return (Log False [] [])
             liftIO $ writeIORef rg  (x,full')
             restoreStack fs
             k'' <- if was== WasParallel
                      then do
                        (k',_) <- liftIO $ readIORef rf -- since k may have been updated by a parallel f
                        return k'
                      else return k
             return $ k'' <*> x
Monad instance: 


instance Monad TransIO where

      return  = pure

      x >>= f  = Transient $ do
--            effects <- gets effects -- liftIO $ readIORef refEventCont
            (t,mk) <- baseEffects x x f
            t $ case mk of
                 Just k  ->  runTrans (f k)

                 Nothing ->  return Nothing
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/newsynth-0.3.0.3/Quantum/Synthesis/StepComp.hs
Monad instance: 
 -- ^ Produce a \"tick\", then resume the
                      -- computation.

instance Monad StepComp where
  return a = Done a
  Done a >>= g = g a
  Tick f >>= g = Tick (f >>= g)
Applicative instance: 


instance Applicative StepComp where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/conceit-0.4.0.0/src/Control/Concurrent/Conceit.hs
Applicative instance: 


instance Applicative (Conceit e) where
  pure = Conceit . pure . pure
  Conceit fs <*> Conceit as =
         Conceit $ fmap (fmap (\(f, a) -> f a)) $ conceit fs as
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/servant-csharp-0.0.8.1/src/CS/JsonDotNet/Base.hs
Applicative instance: 

instance Monad m => Applicative (SwagT m) where
    pure x = SwagT $ \sw -> return x
    f <*> g = SwagT $ \sw -> do
                f' <- runSwagT f sw
                g' <- runSwagT g sw
                return (f' g')
Monad instance: 

instance Monad m => Monad (SwagT m) where
    f >>= k = SwagT $ \sw ->
              runSwagT f sw >>= \f' ->
              runSwagT (k f') sw
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/web-inv-route-0.1/Web/Route/Invertible/Map/Route.hs
Applicative instance: 


instance Applicative f => Applicative (RouteMapT f) where
  pure = exactlyMap . pure
  f <*> m = mapTails (\f' -> mapRoute (f' <*>) m) f
  f  *> m = mapTails (\f' -> mapRoute (f'  *>) m) f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/web-inv-route-0.1/Web/Route/Invertible/Map/Sequence.hs
Applicative instance: 


instance RouteString s => Applicative (SequenceMap s) where
  pure = leaf . Just
  SequenceMap fm fv <*> a = maybe id (\f -> (f <$> a <|>)) fv
    $ SequenceMap ((<*> a) <$> fm) Nothing
  SequenceMap am Nothing *> b =
    SequenceMap ((*> b) <$> am) Nothing
  SequenceMap am (Just _) *> b = b <|>
    SequenceMap ((*> b) <$> am) Nothing
Monad instance: 


instance RouteString s => Monad (SequenceMap s) where
  SequenceMap mm mv >>= f = maybe id ((<|>) . f) mv
    $ SequenceMap ((>>= f) <$> mm) Nothing
  (>>) = (*>)
Applicative instance: 


instance RouteString s => Applicative (SequenceMapP s) where
  pure = SequenceMapP . pure . pure
  SequenceMapP f <*> SequenceMapP m = SequenceMapP $ ((<*>) <$> f) <*> m
  SequenceMapP a  *> SequenceMapP b = SequenceMapP $ ( (*>) <$> a)  *> b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/web-inv-route-0.1/Web/Route/Invertible/Monoid/Exactly.hs
Applicative instance: 

-- |Conflict always overrides other values.
instance Applicative Exactly where
  pure = Exactly
  Exactly f <*> Exactly x = Exactly (f x)
  _ <*> Conflict = Conflict
  Conflict <*> _ = Conflict
  _ <*> _ = Blank
Monad instance: 

instance Monad Exactly where
  Blank >>= _ = Blank
  Exactly x >>= f = f x
  Conflict >>= _ = Conflict
  Exactly _ >> e = e
  Conflict >> _ = Conflict
  _ >> Conflict = Conflict
  _ >> _ = Blank
  fail _ = Conflict
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bind-marshal-0.1/src/Bind/Marshal/Control/Monad/Parameterized.hs
Monad instance: 

instance (Fail m, Return m, Bind m m m) => Monad m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/moonshine-2.0.0.0/src/Web/Moonshine.hs
Monad instance: 


instance Monad Moonshine where
  return a = Moonshine (\state -> return (state, a))
  (Moonshine m) >>= fun = Moonshine $ \state -> do
    (newState, val) <- m state
    let Moonshine m2 = fun val
    m2 newState
Applicative instance: 


instance Applicative Moonshine where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/arrow-improve-0.1.0.0/Control/Arrow/Improve.hs
Applicative instance: 


instance (Arrow a) => Applicative (ImproveArrow a b) where
  pure k = IArr (\_ -> k)
  {-# INLINE pure #-}
  f <*> x = (f &&& x) >>^ uncurry id
  {-# INLINE (<*>) #-}
Monad instance: 


instance (ArrowApply a) => Monad (ImproveArrow a b) where
  return = pure
  {-# INLINE return #-}
  x >>= f = ((x >>^ f) &&& id) >>> app
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rivet-core-0.2.0.0/src/Database/Rivet.hs
Applicative instance: 


instance Applicative (Migration m) where
  pure v = Migration v []
  (<*>) (Migration f ss) (Migration v ss') = Migration (f v) (ss ++ ss')
Monad instance: 


instance Monad (Migration m) where
  (>>=) (Migration v ss) f = let (Migration v' ss') = f v
                             in Migration v' (ss ++ ss')
  return v = Migration v []
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/autoproc-0.2.1/Autoproc/Classifier.hs
Monad instance: 


instance Monad Match where
         return = Match
         (>>=) (Match a) f = (f a)
Applicative instance: 


instance Applicative Match where
      pure  = return
      (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ANum-0.1.1.0/Data/ANum.hs
Applicative instance: 


instance (Applicative f) => Applicative (ANum f) where
  pure x = ANum (pure x)
  (ANum f) <*> (ANum x) = ANum (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-param-0.0.4/src/Control/Monad/Parameterized.hs
Monad instance: 

instance (Fail m, Return m, Bind m m m) => Monad m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SimpleH-1.2/src/Algebra/Applicative.hs
Applicative instance: 


instance Applicative (Either a)
Monad instance: 

instance Monad (Either a) where join (Right a) = a
                                join (Left a) = Left a
Applicative instance: 

instance Applicative ((->) a)
Monad instance: 

instance Monad ((->) a) where join f x = f x x
Applicative instance: 

instance Monoid w => Applicative ((,) w)
Monad instance: 

instance Monoid w => Monad ((,) w) where
  join ~(w,~(w',a)) = (w+w',a)
Applicative instance: 

instance Applicative []
Monad instance: 

instance Monad [] where join = fold
Applicative instance: 

instance Applicative Maybe
Monad instance: 

instance Monad Maybe where join = fold
Applicative instance: 

instance (Applicative f,Applicative g) => Applicative (f:**:g) where
  ff:**:fg <*> xf:**:xg = (ff<*>xf) :**: (fg<*>xg)
Applicative instance: 


instance Applicative Tree
Monad instance: 

instance Monad Tree where
  join (Node (Node a subs) subs') = Node a (subs + map join subs')
Applicative instance: 

instance Applicative Interleave
Monad instance: 

instance Monad Interleave where join = fold
Applicative instance: 


instance (Applicative f,Applicative g) => Applicative (f:.:g) where
  Compose fs <*> Compose xs = Compose ((<*>)<$>fs<*>xs)
Applicative instance: 

instance Applicative ZipList where
  ZipList zf <*> ZipList zx = ZipList (zip_ zf zx)
    where zip_ (f:fs) (x:xs) = f x:zip_ fs xs
          zip_ _ _ = []
Applicative instance: 

instance Applicative ZipTree where
  ZipTree (Node f fs) <*> ZipTree (Node x xs) =
    ZipTree (Node (f x) (getZipList ((<*>)<$>ZipList fs<*>ZipList xs)))
Applicative instance: 

instance Applicative f => Applicative (Backwards f) where
  Backwards fs <*> Backwards xs = Backwards (fs<**>xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SimpleH-1.2/src/Algebra/Functor.hs
Applicative instance: 

instance Applicative Id
Monad instance: 

instance Monad Id where join (Id a) = a
Applicative instance: 

instance Monoid a => Applicative (Const a) where
  Const a <*> Const b = Const (a+b)
Applicative instance: 

instance Applicative IO
Monad instance: 

instance Monad IO where (>>=) = (P.>>=)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SimpleH-1.2/src/Algebra/Monad/Cont.hs
Applicative instance: 

instance Applicative m => Applicative (ContT r m) where
  ContT cf <*> ContT ca = ContT (\kb -> cf (\f -> ca (\a -> kb (f a))))
Monad instance: 

instance Monad m => Monad (ContT r m) where
  ContT k >>= f = ContT (\cc -> k (\a -> runContT (f a) cc))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SimpleH-1.2/src/Algebra/Monad/Base.hs
Monad instance: 


instance (Traversable g,Monad f,Monad g) => Monad (f:.:g) where
  join = Compose .map join.join.map sequence.getCompose.map getCompose
Monad instance: 


instance MonadFix m => Monad (Backwards m) where
  join (Backwards ma) = Backwards$mfixing (\a -> liftA2 (,) (forwards a) ma)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SimpleH-1.2/src/Control/Reactive/TimeVal.hs
Applicative instance: 

instance Applicative TimeVal
Monad instance: 

instance Monad TimeVal where
  join (Since b) = b
  join Always = Always
  join Never = Never
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SimpleH-1.2/src/Control/Reactive.hs
Applicative instance: 

instance Ord t => Applicative (Reactive t) where
  Reactive f fs <*> Reactive x xs = Reactive (f x) (cons f fs<*>cons x xs)
    where cons a = _event %%~ ((minBound,a)^._future :)
Applicative instance: 

instance Ord t => Applicative (Event t) where
  fe@(yb _event -> ff:_) <*> xe@(yb _event -> fx:_) =
    ste & traverse (by state) & yb state & map snd & \st ->
    br (ff^._time + fx^._time) (st (ff^._value,fx^._value))
    where ste = map (\f (_,x) -> ((f,x),f x)) fe
              + map (\x (f,_) -> ((f,x),f x)) xe
          br t (yb _event -> e) = uniq (map (_time %- t) b + a)^._event
            where (b,a) = span (\f -> f^._time<t) e
                  uniq = map last . group
  _ <*> _ = zero
Monad instance: 

instance Ord t => Monad (Event t) where
  join = _event %%~ merge . map2 (yb _event)
    where
      merge [] = []
      merge [t] = t^._value
      merge (xs:ys:t) = xi + merge ((ys&_value%~add xe) : t) & _head._time%~(tx+)
        where add = warp2 _OrdList (+)
              (tx,(xi,xe)) = xs^.._future & _2%~break (ltFut ys)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ACME-0.0.0.1/Acme/Money.hs
Monad instance: 


instance Monad (Money u) where
        return = Money . return
        Money m >>= f = Money $ m >>= unMoney . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ACME-0.0.0.1/Acme/Perhaps.hs
Monad instance: 


instance Monad Perhaps where
        return = Definitely
        Definitely x >>= f = f x
        Probably x >>= f = case f x of
                Definitely y -> Probably y
                _ -> f x
        ProbablyNot >>= _ = ProbablyNot
        Nope >>= _ = Nope
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ACME-0.0.0.1/Acme/Trivial.hs
Monad instance: 


instance Monad Trivial where
        return _ = Trivial
        Trivial >>= _ = Trivial
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/git-0.1/Data/Git/Revision.hs
Applicative instance: 

instance Applicative (Stream elem) where
    pure  = return
    fab <*> fa = Stream $ \e1 -> case runStream fab e1 of
        Left err      -> Left err
        Right (f, e2) -> either Left (Right . first f) $ runStream fa e2
Monad instance: 

instance Monad (Stream elem) where
    return a  = Stream $ \e1 -> Right (a, e1)
    ma >>= mb = Stream $ \e1 -> either Left (\(a, e2) -> runStream (mb a) e2) $ runStream ma e1
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/git-0.1/Data/Git/Monad.hs
Applicative instance: 


instance Applicative GitM where
    pure  = returnGitM
    (<*>) = appendGitM
Monad instance: 


instance Monad GitM where
    return = returnGitM
    (>>=)  = bindGitM
    fail   = failGitM
Applicative instance: 


instance Applicative CommitAccessM where
    pure  = returnCommitAccessM
    (<*>) = appendCommitAccessM
Monad instance: 


instance Monad CommitAccessM where
    return = returnCommitAccessM
    (>>=)  = bindCommitAccessM
    fail   = failCommitAccessM
Applicative instance: 


instance Applicative CommitM where
    pure  = returnCommitM
    (<*>) = appendCommitM
Monad instance: 


instance Monad CommitM where
    return = returnCommitM
    (>>=)  = bindCommitM
    fail   = failCommitM
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/TrieMap-4.1.0/Control/Monad/Lookup.hs
Monad instance: 


instance Monad (Lookup r) where
  return a = Lookup $ \ _ yes -> yes a
  m >>= k = Lookup $ \ no yes ->
    runLookup m no (\ a -> runLookup (k a) no yes)
  fail _ = mzero
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/TrieMap-4.1.0/Data/TrieMap/Representation/TH/ReprMonad.hs
Monad instance: 


instance Monad ReprMonad where
        return x = ReprMonad $ \ knowns _ -> return ([], knowns, x)
        m >>= k = ReprMonad $ \ knowns breaks -> do
          (outDecs, knowns', a) <- runReprMonad m knowns breaks
          (outDecs', knowns'', b) <- runReprMonad (k a) knowns' breaks
          return (outDecs ++ outDecs', knowns'', b)
        fail err = ReprMonad $ \ _ _ -> fail err
Applicative instance: 


instance Applicative ReprMonad where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/TrieMap-4.1.0/Data/TrieMap/ReverseMap.hs
Applicative instance: 


instance Applicative f => Applicative (Dual f) where
  pure a = Dual (pure a)
  Dual f <*> Dual x = Dual (x <**> f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/TrieMap-4.1.0/Data/TrieMap/TrieKey.hs
Monad instance: 


instance Monad Simple where
        return = Singleton
        Null >>= _ = Null
        Singleton a >>= k = k a
        NonSimple >>= _ = NonSimple
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unordered-graphs-0.1.0.1/src/Data/Graph/Unordered/Algorithms/Clustering.hs
Applicative instance: 


instance Applicative (StateL s) where
    pure x = StateL (\ s -> (s, x))
    StateL kf <*> StateL kv = StateL $ \ s ->
        let (s', f) = kf s
            (s'', v) = kv s'
        in (s'', f v)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/attempt-0.4.0.1/Data/Attempt.hs
Applicative instance: 

instance Applicative Attempt where
    pure = Success
    (<*>) = ap
Monad instance: 

instance Monad Attempt where
    return = Success
    (Success v) >>= f = f v
    (Failure e) >>= _ = Failure e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/BNFC-2.8.1/src/ErrM.hs
Monad instance: 


instance Monad Err where
  return      = Ok
  fail        = Bad
  Ok a  >>= f = f a
  Bad s >>= _ = Bad s
Applicative instance: 


instance Applicative Err where
  pure = Ok
  (Bad s) <*> _ = Bad s
  (Ok f) <*> o  = liftM f o
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/BNFC-2.8.1/src/Data/Pair.hs
Applicative instance: 


instance Applicative Pair where
  pure a = a :/: a
  (f :/: g) <*> (a :/: b) = f a :/: g b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/separated-0.1.0/src/Data/Separated/FlipSeparated.hs
Applicative instance: 


-- | Applies functions with separator values, using a zipping operation, appending
-- elements. The identity operation is an infinite list of the empty element
-- and the given separator value.
--
-- >>> (fempty :: FlipSeparated [Int] (String -> [String])) <*> fempty
-- []
--
-- >>> (\s -> [s, reverse s, drop 1 s]) +. [1,2] +. fempty <*> "abc" +. [3,4,5] +. fempty
-- [["abc","cba","bc"],[1,2,3,4,5]]
instance Monoid s => Applicative (FlipSeparated s) where
  FlipSeparated x <*> FlipSeparated y =
    FlipSeparated (separatedSwap # (x ^. separatedSwap <*> y ^. separatedSwap))
  pure =
    FlipSeparated . (#) separatedSwap . pure
Applicative instance: 


-- | Applies functions with element values, using a zipping operation,
-- appending separators. The identity operation is an infinite list of the empty
-- separator and the given element value.
--
-- >>> fmap toUpper +. [3,4] +. reverse +. fempty <*> "abc" +. [5,6,7] +. "def" +. fempty
-- ["ABC",[3,4,5,6,7],"fed"]
instance Monoid s => Applicative (FlipSeparated1 s) where
  (<*>) =
    flipSeparated1Ap mappend
  pure a =
    FlipSeparated1 ((a, pure a) ^. separated1)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/separated-0.1.0/src/Data/Separated/Separated.hs
Applicative instance: 


-- | Applies functions with element values, using a zipping operation, appending
-- separators. The identity operation is an infinite list of the empty separator
-- and the given element value.
--
-- >>> (empty :: Separated [Int] (String -> [String])) <*> empty
-- []
--
-- >>> [1,2] +: (\s -> [s, reverse s, drop 1 s]) +: empty <*> [3,4,5] +: "abc" +: empty
-- [[1,2,3,4,5],["abc","cba","bc"]]
instance Monoid s => Applicative (Separated s) where
  (<*>) =
    separatedAp mappend
  pure =
    Separated . repeat . (,) mempty
Applicative instance: 


-- | Applies functions with separator values, using a zipping operation,
-- appending elements. The identity operation is an infinite list of the empty
-- element and the given separator value.
--
-- >>> [1,2] +: reverse +: [3,4] +: empty <*> [5,6,7] +: "abc" +: [8] +: empty
-- [[1,2,5,6,7],"cba",[3,4,8]]
instance Monoid s => Applicative (Separated1 s) where
  (<*>) =
    separated1Ap mappend
  pure =
    Separated1 mempty . swapSeparated . pure
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/option-0.1.0.1/Data/Option.hs
Monad instance: 


instance Monad Option where
  return = Some
  (Some v) >>= f = f v
  None     >>= f = None
Applicative instance: 


instance Applicative Option where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/smtLib-1.0.8/src/SMTLib2/Compat1.hs
Applicative instance: 


instance Applicative Trans where
  pure x = OK x

  OK f   <*> OK x   = OK (f x)
  Fail x <*> OK _   = Fail x
  OK _   <*> Fail x = Fail x
  Fail x <*> Fail y = Fail (x $$ y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/narc-0.1.3/Gensym.hs
Monad instance: 


instance Monad Gensym where
    return v = G(\x -> (x,v))
    m >>= k = G(\x -> let G f = m in
                      let (x', v) = f x in
                      let G f' = k v in f' x')
Applicative instance: 


instance Control.Applicative.Applicative Gensym where
    pure = return
    f <*> x = do f' <- f ; x' <- x ; return (f' x')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/webapi-0.3/src/WebApi/Param.hs
Applicative instance: 


instance Monoid e => Applicative (Validation e) where
  pure = Validation . Right
  Validation a <*> Validation b = Validation $
    case a of
      Right va -> fmap va b
      Left ea -> either (Left . mappend ea) (const $ Left ea) b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/extcore-1.0.2/Language/Core/Check.hs
Monad instance: 


instance Monad CheckRes where
  OkC a >>= k = k a
  FailC s >>= _ = fail s
  return = OkC
  fail = FailC
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/stm-promise-0.0.3.1/Control/Concurrent/STM/Promise/Tree.hs
Monad instance: 


-- The free monad over the underlying structure
instance Monad Tree where
    return              = Leaf
    Leaf x >>= f        = f x
    Node l u v >>= f    = Node l (u >>= f) (v >>= f)
    Recoverable t >>= f = Recoverable (t >>= f)
Applicative instance: 


instance Applicative Tree where
    pure  = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/stream-monad-0.4.0.2/src/Control/Monad/Stream.hs
Monad instance: 


instance Monad Stream
 where
  return = Single

  Nil       >>= _ = Nil
  Single x  >>= f = f x
  Cons x xs >>= f = f x `mplus` suspended (xs >>= f)
  Susp xs   >>= f = suspended (xs >>= f)

  fail _ = Nil
Applicative instance: 


instance Applicative Stream where
  pure  = Single

  Nil       <*> _  = Nil
  Single f  <*> xs = fmap f xs
  Cons f fs <*> xs = fmap f xs <|> (xs <**> fs)
  Susp fs   <*> xs = suspended (xs <**> fs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/jukebox-0.2.7/src/Jukebox/Options.hs
Applicative instance: 


instance (Monoid d, Applicative p) => Applicative (Annotated d p) where
  pure = Annotated mempty . pure
  Annotated d f <*> Annotated d' x =
    Annotated (d `mappend` d') (f <*> x)
Applicative instance: 


instance Applicative SeqParser where
  pure = SeqParser 0 . const . pure
  SeqParser a c <*> SeqParser a' c' = SeqParser (a + a') f
    where f xs = c xs <*> c' (drop a xs)
Applicative instance: 


instance Applicative ParParser where
  pure x = ParParser (return x) (const (pure x))
  ParParser v p <*> ParParser v' p' =
    ParParser (v <*> v') (\xs -> p xs <*> p' xs)
Applicative instance: 


instance Applicative ParseResult where
  pure = No . pure
  Yes n r <*> Yes n' r'
    | n == n' = Yes n (r <*> r')
    | otherwise = error "Options.ParseResult: inconsistent number of arguments"
  Error s <*> _ = Error s
  _ <*> Error s = Error s
  Yes n r <*> No x = Yes n (r <*> x)
  No x <*> Yes n r = Yes n (x <*> r)
  No f <*> No x = No (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/jukebox-0.2.7/src/Jukebox/TPTP/Parsec.hs
Monad instance: 


instance Monad (Parsec a) where
  {-# INLINE return #-}
  return x = Parsec (\ok err inp exp -> ok x err inp exp)
  {-# INLINE (>>=) #-}
  x >>= f = Parsec (\ok err inp exp  -> runParsec x (\y err inp exp -> runParsec (f y) ok err inp exp) err inp exp)
  {-# INLINE fail #-}
  fail _ = parseError []
Applicative instance: 


instance Applicative (Parsec a) where
  {-# INLINE pure #-}
  pure = return
  {-# INLINE (<*>) #-}
  f <*> x = do { f' <- f; x' <- x; return (f' x') }
  {-# INLINE (*>) #-}
  (*>) = (>>)
  {-# INLINE (<*) #-}
  x <* y = do
    x' <- x
    y
    return x'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sloth-0.0.2/Test/Sloth/Search.hs
Monad instance: 


instance Monad Search where
  return = Complete

  Complete x >>= f = f x
  Incomplete x >>= f =
    case f x of
         Complete y -> Incomplete y
         r          -> r
Monad instance: 


instance Monad m => Monad (SearchT m) where
  return = lift . return

  m >>= f = SearchT (runSearchT m >>= g)
   where
    g (Complete   x) = runSearchT (f x)
    g (Incomplete x) = liftM (join . Incomplete) (runSearchT (f x))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-branches-0.1.3/Simulation/Aivika/Branch/Internal/Br.hs
Monad instance: 


instance Monad BrIO where

  {-# INLINE return #-}
  return = Br . const . return

  {-# INLINE (>>=) #-}
  (Br m) >>= k = Br $ \ps ->
    m ps >>= \a ->
    let m' = unBr (k a) in m' ps
Applicative instance: 


instance Applicative BrIO where

  {-# INLINE pure #-}
  pure = return

  {-# INLINE (<*>) #-}
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ivory-opts-0.1.0.3/src/Ivory/Opts/CFG.hs
Applicative instance: 


instance Applicative WithTop where
  pure a = Val a
  Val _ <*> Top     = Top
  Val f <*> (Val a) = Val (f a)
  _     <*> _       = Top
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Xec-0.1.6/Main.hs
Monad instance: 


instance Monad m => Monad (MaybeT m) where
    return=MaybeT . return . Just
    f >>= g=MaybeT $ runMaybeT f >>= maybe (return Nothing) (runMaybeT . g)
    fail _=MaybeT $ return Nothing
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/TypeCompose-0.9.9/src/Control/Compose.hs
Applicative instance: 


-- contraFmapCF h (O gf) = O (contraFmap (fmap h) gf)

instance (Applicative g, Applicative f) => Applicative (g :. f) where
  pure  = O . pure . pure
  (<*>) = (inO2.liftA2) (<*>)
Applicative instance: 


instance Applicative Id where
  pure  = Id
  (<*>) = inId2 ($)
Monad instance: 


instance Monad Id where
  return = pure
  Id x >>= f = f x
Applicative instance: 


instance (Applicative f, Applicative g) => Applicative (f :*: g) where
  pure a = Prod (pure a, pure a)
  (<*>) = inProd2 (\ (f,g) (a,b) -> (f <*> a, g <*> b))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liquid-fixpoint-0.5.0.1/src/Language/Fixpoint/SortCheck.hs
Monad instance: 


instance Monad CheckM where
  return x     = CM $ \i -> (i, Right x)
  (CM m) >>= f = CM $ \i -> case m i of
                             (j, Left s)  -> (j, Left s)
                             (j, Right x) -> runCM (f x) j
Applicative instance: 


instance Applicative CheckM where
  pure x     = CM $ \i -> (i, Right x)
  (CM f) <*> (CM m) = CM $ \i -> case m i of
                             (j, Left s)  -> (j, Left s)
                             (_, Right x) -> case f i of
                                 (k, Left s)  -> (k, Left s)
                                 (k, Right g) -> (k, Right $ g x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/prizm-0.3.1.2/src/Data/Prizm/Types.hs
Applicative instance: 


-- | Applicative instances

instance Applicative RGB where
    pure t = RGB t t t
    (RGB f1 f2 f3) <*> (RGB r g b) = (RGB (f1 r) (f2 g) (f3 b))
Applicative instance: 


instance Applicative CIEXYZ where
    pure t = CIEXYZ t t t
    CIEXYZ f1 f2 f3 <*> CIEXYZ x y z = CIEXYZ (f1 x) (f2 y) (f3 z)
Applicative instance: 


instance Applicative CIELAB where
    pure t = CIELAB t t t
    CIELAB f1 f2 f3 <*> CIELAB l a b = CIELAB (f1 l) (f2 a) (f3 b)
Applicative instance: 


instance Applicative CIELCH where
    pure t = CIELCH t t t
    CIELCH f1 f2 f3 <*> CIELCH l c h = CIELCH (f1 l) (f2 c) (f3 h)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/speculation-1.5.0.3/src/Control/Concurrent/Speculation/Traversable.hs
Applicative instance: 


instance Applicative (IntAccumL s) where
    pure a = IntAccumL (\i s -> (# i, s, a #))
    IntAccumL mf <*> IntAccumL ma = IntAccumL (\i s ->
        case mf i s of
            (# i1, s1, f #) ->
                case ma i1 s1 of
                    (# i2, s2, a #) -> (# i2, s2, f a #))
Applicative instance: 


instance Applicative (IntAccumR s) where
    pure a = IntAccumR (\i s -> (# i, s, a #))
    IntAccumR mf <*> IntAccumR ma = IntAccumR (\i s ->
        case ma i s of
            (# i1, s1, a #) ->
                case mf i1 s1 of
                    (# i2, s2, f #) -> (# i2, s2, f a #))
Applicative instance: 


instance Applicative f => Applicative (AccT f) where
    pure a = AccT (\i -> Acc (I# i) (pure a))
    AccT mf <*> AccT ma = AccT (\i0# ->
        let !(Acc (I# i1#) f) = mf i0#
            (Acc i2 a) = ma i1#
        in  Acc i2 (f <*> a))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Craft3e-0.1.1.0/Chapter19/ParseLib.hs
Monad instance: 


instance Monad (SParse a) where
  return x = SParse (succeed x)
  (SParse pr) >>= f
    = SParse (\st -> concat [ sparse (f a) rest | (a,rest) <- pr st ])
Applicative instance: 


instance Applicative (SParse a) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Craft3e-0.1.1.0/Chapter18.hs
Monad instance: 


instance Monad (State a) where

  return x = State (\tab -> (tab,x))

  (State st) >>= f
    = State (\tab -> let
                     (newTab,y)    = st tab
                     (State trans) = f y
                     in
                     trans newTab)
Applicative instance: 


instance Applicative (State a) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Craft3e-0.1.1.0/ParseLib.hs
Monad instance: 


instance Monad (SParse a) where
  return x = SParse (succeed x)
  (SParse pr) >>= f
    = SParse (\st -> concat [ sparse (f a) rest | (a,rest) <- pr st ])
Applicative instance: 


instance Applicative (SParse a) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Craft3e-0.1.1.0/Calculator/CalcParseLib.hs
Monad instance: 


instance Monad (SParse a) where
  return x = SParse (succeed x)
  fail s   = SParse none
  (SParse pr) >>= f
    = SParse (\st -> concat [ sparse (f x) rest | (x,rest) <- pr st ])
Applicative instance: 


instance Applicative (SParse a) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/elision-0.1.3.2/src/Control/Arrow/Elision/Simple.hs
Applicative instance: 


instance Applicative (Elision f a) where
  pure x =
    Elision (const (const (pure x)))

  el0 <*> el1 =
    Elision $ \cont arg ->
        complete cont arg el0 <*> complete cont arg el1
Monad instance: 


instance Monad (Elision f a) where
  el >>= fn =
    Elision $ \cont arg ->
        complete cont arg . fn =<< complete cont arg el
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/copilot-theorem-2.2.0/src/Copilot/Theorem/Prove.hs
Applicative instance: 


instance Applicative (ProofScheme a) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad (ProofScheme a) where
  (Proof p) >>= f = Proof $ p >>= (\a -> case f a of Proof p -> p)
  return a = Proof (return a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/microlens-mtl-0.1.9.0/src/Lens/Micro/Mtl/Internal.hs
Applicative instance: 


instance (Monad m, Monoid s) => Applicative (Focusing m s) where
  pure a = Focusing (return (mempty, a))
  {-# INLINE pure #-}
  Focusing mf <*> Focusing ma = Focusing $ do
    (s, f) <- mf
    (s', a) <- ma
    return (mappend s s', f a)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance (Monad m, Monoid s, Monoid w) => Applicative (FocusingWith w m s) where
  pure a = FocusingWith (return (mempty, a, mempty))
  {-# INLINE pure #-}
  FocusingWith mf <*> FocusingWith ma = FocusingWith $ do
    (s, f, w) <- mf
    (s', a, w') <- ma
    return (mappend s s', f a, mappend w w')
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative (k (s, w)) => Applicative (FocusingPlus w k s) where
  pure = FocusingPlus . pure
  {-# INLINE pure #-}
  FocusingPlus kf <*> FocusingPlus ka = FocusingPlus (kf <*> ka)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative (k (f s)) => Applicative (FocusingOn f k s) where
  pure = FocusingOn . pure
  {-# INLINE pure #-}
  FocusingOn kf <*> FocusingOn ka = FocusingOn (kf <*> ka)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative (k (May s)) => Applicative (FocusingMay k s) where
  pure = FocusingMay . pure
  {-# INLINE pure #-}
  FocusingMay kf <*> FocusingMay ka = FocusingMay (kf <*> ka)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative (k (Err e s)) => Applicative (FocusingErr e k s) where
  pure = FocusingErr . pure
  {-# INLINE pure #-}
  FocusingErr kf <*> FocusingErr ka = FocusingErr (kf <*> ka)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance (Monad m, Monoid r) => Applicative (Effect m r) where
  pure _ = Effect (return mempty)
  {-# INLINE pure #-}
  Effect ma <*> Effect mb = Effect (liftM2 mappend ma mb)
  {-# INLINE (<*>) #-}
Applicative instance: 


instance (Monoid s, Monoid w, Monad m) => Applicative (EffectRWS w st m s) where
  pure _ = EffectRWS $ \st -> return (mempty, st, mempty)
  {-# INLINE pure #-}
  EffectRWS m <*> EffectRWS n = EffectRWS $ \st -> m st >>= \ (s,t,w) -> n t >>= \ (s',u,w') -> return (mappend s s', u, mappend w w')
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskell-src-exts-1.9.6/src/Language/Haskell/Exts/ParseMonad.hs
Applicative instance: 


instance Applicative ParseResult where
  pure = ParseOk
  ParseOk f           <*> x = f <$> x
  ParseFailed loc msg <*> _ = ParseFailed loc msg
Monad instance: 


instance Monad ParseResult where
  return = ParseOk
  ParseOk x           >>= f = f x
  ParseFailed loc msg >>= _ = ParseFailed loc msg
Monad instance: 


instance Monad P where
    return a = P $ \_i _x _y _l s _m -> Ok s a
    P m >>= k = P $ \i x y l s mode ->
        case m i x y l s mode of
            Failed loc msg -> Failed loc msg
            Ok s' a -> runP (k a) i x y l s' mode
    fail s = P $ \_r _col _line loc _stk _m -> Failed loc s
Monad instance: 


instance Monad (Lex r) where
    return a = Lex $ \k -> k a
    Lex v >>= f = Lex $ \k -> v (\a -> runL (f a) k)
    Lex v >> Lex w = Lex $ \k -> v (\_ -> w k)
    fail s = Lex $ \_ -> fail s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskell-src-exts-1.9.6/src/Language/Haskell/Exts/Annotated/ExactPrint.hs
Monad instance: 


instance Monad EP where
  return x = EP $ \l cs -> (x, l, cs, id)

  EP m >>= k = EP $ \l0 c0 -> let
        (a, l1, c1, s1) = m l0 c0
        EP f = k a
        (b, l2, c2, s2) = f l1 c1
    in (b, l2, c2, s1 . s2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskell-src-exts-1.9.6/src/Language/Haskell/Exts/Pretty.hs
Monad instance: 


instance Monad (DocM s) where
        (>>=) = thenDocM
        (>>) = then_DocM
        return = retDocM
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/salvia-protocol-1.0.1/src/Network/Protocol/Uri/Parser.hs
Applicative instance: 


instance Applicative (GenParser Char st) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bot-0.3/src/Data/Bot/Part.hs
Applicative instance: 


instance Applicative (DBot i) where
  pure o = DBot o PureB
  fd@(DBot f _) <*> xd@(DBot x _) = DBot (f x) (fd `AppB` xd)
Applicative instance: 


instance Applicative AppV where
  pure  = PureV
  (<*>) = appV
Applicative instance: 


instance Applicative (AppF h) where
  pure  = PureF
  (<*>) = AppF
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bot-0.3/src/Data/Bot/LeadFollow.hs
Applicative instance: 


instance Applicative (Follow a) where
  pure b = Follow ((pure.pure) b)
  Follow h <*> Follow k = Follow $ liftA2 (<*>) h k
Applicative instance: 


instance Applicative (Lead a) where
  pure b = Lead (b, pure b)
  Lead (f,pf) <*> Lead (x,px) = Lead (f x, pf <*> px)
Applicative instance: 


instance Applicative ((:>-) i) where
  pure x = Leads (x,mempty)
  lf <*> lx = uncurry ($) <$> (lf `pairL` lx)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bot-0.3/src/Data/Bot/Chatter.hs
Applicative instance: 


instance Applicative (ChatterBot i) where
  pure x        = arr (const x)
  fbot <*> xbot = fbot &&& xbot >>> arr (uncurry ($))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ClassLaws-0.3.1.0/src/Control/Monad/Laws/Instances.hs
Monad instance: 



instance  Monad MyList  where
    m >>= k             = foldrMyList ((+++) . k) Nil m
    m >> k              = foldrMyList ((+++) . (\ _ -> k)) Nil m
    return x            = Cons x (Cons x Nil) -- gives an error
--    return x            = Cons x Nil  -- correct
    fail _              = Nil
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ClassLaws-0.3.1.0/src/Test/ClassLaws/TestingState.hs
Monad instance: 






-- instances for the lazy state
instance Monad (State s) where
  return  =  returnState
  (>>=)   =  bindStateL
Monad instance: 



instance Monad (SS s) where
  return        =  SS . returnState
  (SS m) >>= k  =  bindSS
      where
        bindSS = SS $ S $ \s -> case runS m s of
                                  (Pair a s') -> x s'
                                      where
                                        SS (S x) = k a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Barracuda-1.0.2/Barracuda/ServerState.hs
Monad instance: 


instance Monad ServerMonad where
        return x = ServerMonad (\_ _ _ st -> (Seq.empty, Seq.empty, Seq.empty, st, x))
        (ServerMonad f) >>= g = ServerMonad (\bcast cert time st -> let
                (printSeq, outSeq, clSeq, nst, res) = f bcast cert time st
                ServerMonad f2 = g res
                (printSeq2, outSeq2, clSeq2, nnst, res2) = f2 bcast cert time nst
                in (printSeq >< printSeq2, outSeq >< outSeq2, clSeq >< clSeq2, nnst, res2)
                )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/alga-0.2.1/src/Alga/Language/Element.hs
Applicative instance: 


instance Applicative Element where
  pure           = Val
  (Val  f) <*> x = f <$> x
  (Sec  f) <*> x = Sec  $ (<*> x) <$> f
  (Mul  f) <*> x = Mul  $ (<*> x) <$> f
  (CMul f) <*> x = CMul $ (((<*> x) <$>) *** ((<*> x) <$>)) <$> f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gitlib-3.1.1/Git/Tree/Builder.hs
Monad instance: 


instance Monad m => Monad (TreeT r m) where
    return x = TreeT (return x)
    TreeT x >>= f = TreeT (x >>= runTreeT . f)
Applicative instance: 


instance (Functor m, Monad m) => Applicative (TreeT r m) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dictionary-sharing-0.1.0.0/Data/ClassSharing.hs
Applicative instance: 


instance Applicative f => Applicative (Shareable f) where
  pure                         = Shareable . pure . pure
  Shareable a <*> Shareable b  = Shareable (\r -> a r <*> b r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/vcache-0.2.6/hsrc_lib/Database/VCache/Types.hs
Applicative instance: 

instance Applicative VPut where
    pure = return
    (<*>) = ap
    {-# INLINE pure #-}
    {-# INLINE (<*>) #-}
Monad instance: 

instance Monad VPut where
    fail msg = VPut (\ _ -> fail ("VCache.VPut.fail " ++ msg))
    return r = VPut (\ s -> return (VPutR r s))
    m >>= k = VPut $ \ s ->
        _vput m s >>= \ (VPutR r s') ->
        _vput (k r) s'
    m >> k = VPut $ \ s ->
        _vput m s >>= \ (VPutR _ s') ->
        _vput k s'
    {-# INLINE return #-}
    {-# INLINE (>>=) #-}
    {-# INLINE (>>) #-}
Applicative instance: 

instance Applicative VGet where
    pure = return
    (<*>) = ap
    {-# INLINE pure #-}
    {-# INLINE (<*>) #-}
Monad instance: 

instance Monad VGet where
    fail msg = VGet (\ _ -> return (VGetE msg))
    return r = VGet (\ s -> return (VGetR r s))
    m >>= k = VGet $ \ s ->
        _vget m s >>= \ c ->
        case c of
            VGetE msg -> return (VGetE msg)
            VGetR r s' -> _vget (k r) s'
    m >> k = VGet $ \ s ->
        _vget m s >>= \ c ->
        case c of
            VGetE msg -> return (VGetE msg)
            VGetR _ s' -> _vget k s'
    {-# INLINE fail #-}
    {-# INLINE return #-}
    {-# INLINE (>>=) #-}
    {-# INLINE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tcp-0.0.2/Network/TCP/Aux/SockMonad.hs
Monad instance: 


instance Monad (SMonad t) where
    return a = SMonad $ \s -> (a,s)
    x >>= f = bindSMonad x f
    {-# INLINE return #-}
    {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tcp-0.0.2/Network/TCP/Aux/HostMonad.hs
Monad instance: 


instance Monad (HMonad t) where
    return a = HMonad $ \s -> (a,s)
    x >>= f = bindHMonad x f
    {-# INLINE return #-}
    {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bytable-0.1.0.0/src/Codec/Bytable/BigEndian.hs
Monad instance: 


instance Monad BytableM where
        return x = BytableM $ \bs -> Right (x, bs)
        BytableM m1 >>= f = BytableM $ \bs -> do
                (x, bs') <- m1 bs
                runBytableM (f x) bs'
        fail = BytableM . const . Left
Applicative instance: 


instance Applicative BytableM where
        pure = return
        (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/shell-conduit-4.5.2/src/Data/Conduit/Shell/Process.hs
Monad instance: 


instance Monad Segment where
  return = SegmentConduit . return
  SegmentConduit c >>= f =
    SegmentProcess (conduitToProcess c) >>=
    f
  SegmentProcess f >>= g =
    SegmentProcess
      (\handles ->
         do x <- f handles
            case g x of
              SegmentConduit c ->
                conduitToProcess c handles
              SegmentProcess p -> p handles)
Applicative instance: 


instance Applicative Segment where
  (<*>) = ap; pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/blocking-transactions-0.1.0.5/BlockingTransactions/BlockingTransactions.hs
Applicative instance: 


instance Applicative (BTM e) where
    pure = return
    a <*> b =
        do a' <- a
           b' <- b
           return $ a' b'
Applicative instance: 


instance Applicative (Value e) where
    pure x = Value x
    Value a <*> Value b = Value $ a b
Monad instance: 


instance Monad (BTM e) where
    return = BTReturn
    (BTReturn k) >>= m = m k
    -- The key here is that we bind the static result of the previous
    -- operation to the static result of the subsequent operation, and
    -- the monadic IO result to the subsequent monadic IO result.
    --
    -- For example, if we read a variable that contains the number 23,
    -- the static result will be $Value undefined$ while the monadic
    -- result will be $Value 23$.
    --
    -- The monadic result is unobservable without running the transaction
    -- but the static result, wrapped in a 'Value', is simply unobservable.
    --
    -- However, whenever we return a constant value, which is unwrapped,
    -- the value is observable.
    k >>= m =
           case m $ staticResult k of
                BTReturn j ->
                      BTM j
                          (workingSet k) $
                          \x ->
                              do k' <- operation k x
                                 operation (m k') x
                BTM j ws _ ->
                      BTM j
                          (ws . workingSet k) $
                          \x ->
                              do k' <- operation k x
                                 operation (m k') x
Monad instance: 


instance Monad (Value e) where
    return = Value
    (Value k) >>= m = m k
Applicative instance: 


instance Applicative (BTA a) where
    pure a = arr (const a)
    a <*> b = proc i ->
        do a' <- a -< i
           b' <- b -< i
           returnA -< a' b'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/strict-identity-0.1.0.0/src/Control/Monad/StrictIdentity.hs
Applicative instance: 



instance Applicative StrictIdentity where
    {-# INLINE pure #-}
    pure = return
    {-# INLINE (<*>) #-}
    (<*>) a b = do   f <- a ; v <- b ; return $! (f $! v)
Monad instance: 


instance Monad StrictIdentity where
    {-# INLINE return  #-}
    return !a = StrictIdentity $! a
    {-# INLINE  (>>=) #-}
    (!m) >>= (!k)  = k $! runStrictIdentity  m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/NoSlow-0.2/NoSlow/Backend/TH.hs
Monad instance: 


instance Monad SM where
  return x = SM $ \_ ns -> (x, ns)

  SM p >>= q = SM $ \s ns ->
               case p s ns of
                 (x, ns') -> runSM (q x) s ns'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/NoSlow-0.2/NoSlow/Util/Opts.hs
Monad instance: 


instance Monad Result where
  return = Ok

  Ok x     >>= f = f x
  Exit p c >>= _ = Exit p c
  Error s  >>= _ = Error s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/representable-functors-3.2.0.2/src/Control/Comonad/Representable/Store.hs
Applicative instance: 


instance (Applicative w, Semigroup (Key g), Monoid (Key g), Representable g) => Applicative (StoreT g w) where
  pure a = StoreT (pure (pureRep a)) mempty
  StoreT ff m <*> StoreT fa n = StoreT (apRep <$> ff <*> fa) (m `mappend` n)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/representable-functors-3.2.0.2/src/Control/Monad/Representable/Reader.hs
Applicative instance: 


instance (Representable f, Applicative m) => Applicative (ReaderT f m) where
  pure = ReaderT . pureRep . pure
  ReaderT ff <*> ReaderT fa = ReaderT (unrep ((<*>) <$> Rep ff <*> Rep fa))
Monad instance: 


instance (Representable f, Monad m) => Monad (ReaderT f m) where
  return = ReaderT . pureRep . return
  ReaderT fm >>= f = ReaderT $ tabulate (\a -> index fm a >>= flip index a . getReaderT . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/representable-functors-3.2.0.2/src/Data/Functor/Representable.hs
Applicative instance: 


instance Representable f => Applicative (Rep f) where
  pure = pureRep
  (<*>) = apRep
Monad instance: 


instance Representable f => Monad (Rep f) where
  return = pureRep
  (>>=) = bindRep
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haste-compiler-0.5.5.0/utils/haste-pkg/HastePkg708.hs
Applicative instance: 


instance Applicative Validate where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad Validate where
   return a = V $ return (a, [], [])
   m >>= k = V $ do
      (a, es, ws) <- runValidate m
      (b, es', ws') <- runValidate (k a)
      return (b,es++es',ws++ws')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haste-compiler-0.5.5.0/utils/haste-pkg/HastePkg710.hs
Applicative instance: 


instance Applicative Validate where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad Validate where
   return a = V $ return (a, [], [])
   m >>= k = V $ do
      (a, es, ws) <- runValidate m
      (b, es', ws') <- runValidate (k a)
      return (b,es++es',ws++ws')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haste-compiler-0.5.5.0/libraries/haste-lib/src/Haste/Serialize.hs
Monad instance: 


instance Monad Parser where
  return = Parser . return
  (Parser (Right x)) >>= f = f x
  (Parser (Left e))  >>= _ = Parser (Left e)
  fail = Parser . Left
Applicative instance: 


instance Applicative Parser where
  (<*>) = ap
  pure  = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haste-compiler-0.5.5.0/libraries/haste-lib/src/Haste/Parsing.hs
Monad instance: 


instance Monad Parse where
  return x = Parse $ \s -> Just (s, x)
  Parse m >>= f = Parse $ \s -> do
    (s', x) <- m s
    unP (f x) s'
Applicative instance: 


instance Applicative Parse where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haste-compiler-0.5.5.0/libraries/haste-lib/src/Haste/Concurrent/Monad.hs
Monad instance: 


instance Monad CIO where
  return x    = C $ \next -> next x
  (C m) >>= f = C $ \b -> m (\a -> unC (f a) b)
Applicative instance: 


instance Applicative CIO where
  (<*>) = ap
  pure  = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haste-compiler-0.5.5.0/libraries/haste-lib/src/Haste/App/Client.hs
Monad instance: 


instance Monad Client where
  (Client m) >>= f = Client $ \cs -> do
    x <- m cs
    unC (f x) cs
  return x = Client $ \_ -> return x
Applicative instance: 


instance Applicative Client where
  (<*>) = ap
  pure  = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haste-compiler-0.5.5.0/libraries/haste-lib/src/Haste/App/Monad.hs
Monad instance: 


instance Monad App where
  return x = App $ \c _ cid exports -> return (x, cid, exports, c)
  (App m) >>= f = App $ \cfg sessions cid exports -> do
    res <- m cfg sessions cid exports
    case res of
      (x, cid', exports', cfg') -> unA (f x) cfg' sessions cid' exports'
Applicative instance: 


instance Applicative App where
  (<*>) = ap
  pure  = return
Applicative instance: 

#endif

instance Applicative Server where
  (<*>) = ap
  pure  = return
Monad instance: 


instance Monad Server where
#ifdef __HASTE__
  return _ = Server
  _ >>= _  = Server
#else
  return x = Server $ \_ _ -> return x
  (Server m) >>= f = Server $ \sid ss -> do
    Server m' <- f <$> m sid ss
    m' sid ss
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haste-compiler-0.5.5.0/src/Haste/AST/PP.hs
Monad instance: 


instance Monad PP where
  PP m >>= f = PP $ \cfg indentlvl ns b ->
    case m cfg indentlvl ns b of
      (ns', b', x) -> unPP (f x) cfg indentlvl ns' b'
  return x = PP $ \_ _ ns b -> (ns, b, x)
Applicative instance: 


instance Applicative PP where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/phantom-state-0.2.1.2/Control/Applicative/PhantomState.hs
Applicative instance: 


instance Monad m => Applicative (PhantomStateT s m) where
  {-# INLINE pure #-}
  pure _ = PhantomStateT return
  {-# INLINE (<*>) #-}
  PhantomStateT f <*> PhantomStateT g = PhantomStateT (\x -> f x >>= g)
  {-# INLINE  (*>) #-}
  PhantomStateT f  *> PhantomStateT g = PhantomStateT (\x -> f x >>= g)
  {-# INLINE (<*) #-}
  PhantomStateT f <*  PhantomStateT g = PhantomStateT (\x -> f x >>= g)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wtk-0.2.1/Text/WtkParser.hs
Monad instance: 


instance Monad Parser where
   return a = Parser (\xl -> Right (xl,a))
   fail   s = Parser (\xl -> Left s)
   Parser m >>= k = Parser $ \xl ->
      case m xl of
         Left s        -> Left s
         Right (xl',a) ->
            let Parser n = k a
            in n xl'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mwc-probability-1.2.1/src/System/Random/MWC/Probability.hs
Applicative instance: 


instance Monad m => Applicative (Prob m) where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad m => Monad (Prob m) where
  return  = Prob . const . return
  m >>= h = Prob $ \g -> do
    z <- sample m g
    sample (h z) g
  {-# INLINABLE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/xml-enumerator-0.4.4.1/Text/XML/Stream/Parse.hs
Monad instance: 


instance Monad AttrParser where
    return a = AttrParser $ \as -> Right (as, a)
    (AttrParser f) >>= g = AttrParser $ \as ->
        case f as of
            Left e -> Left e
            Right (as', f') -> runAttrParser (g f') as'
Applicative instance: 

instance Applicative AttrParser where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/atrans-0.1.1.0/src/Control/Monad/Backend.hs
Applicative instance: 


instance (Monad m) => Applicative (BackendT s m) where
  pure x = BackendT $ \s -> pure (s, x)
  pf <*> q = BackendT $ \s -> do { (s', f) <- rawRunBackendT pf s; (s'', x) <- rawRunBackendT q s'; return (s'', f x) }
Monad instance: 


instance (Monad m) => Monad (BackendT s m) where
  return x = BackendT $ \s -> return (s, x)
  p >>= fq = BackendT $ \s -> do { (s', x) <- rawRunBackendT p s; rawRunBackendT (fq x) s' }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chatty-text-0.6.2.1/Text/Chatty/Parser/Carrier.hs
Monad instance: 


instance (MonadPlus m,F.Foldable m) => Monad (CarrierT m) where
  return a = Carry $ \s -> return (a,s)
  m >>= f = Carry $ \s -> msum [carry (f a) cs' | (a,cs') <- F.foldr (:) [] $ carry m s]
  fail _ = Carry $ const mzero
Applicative instance: 


instance (MonadPlus m,F.Foldable m) => Applicative (CarrierT m) where
  pure = return
  f <*> a = f `ap` a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chatty-text-0.6.2.1/Text/Chatty/Parser/Nondeterministic.hs
Monad instance: 


instance (MonadPlus m,F.Foldable m) => Monad (ForkerT m) where
  return a = Result (return a) $ const Failed
  (Result as f) >>= m = Result (results >>= rResult) (\k -> F.foldl (???) (f k >>= m) (liftM (flip rFunction k) results))
    where isResult (Result _ _) = True
          isResult _ = False
          rResult (Result x _) = x
          rFunction (Result _ f) = f
          results = mfilter isResult $ liftM m as
  Failed >>= m = Failed
  fail _ = Failed
Applicative instance: 


instance (MonadPlus m,F.Foldable m) => Applicative (ForkerT m) where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/LambdaHack-0.5.0.0/Game/LambdaHack/Common/Frequency.hs
Monad instance: 


instance Monad Frequency where
  {-# INLINE return #-}
  return x = Frequency [(1, x)] "return"
  Frequency xs name >>= f =
    Frequency [ (p * q, y) | (p, x) <- xs
                           , (q, y) <- runFrequency (f x) ]
              ("bind (" <> name <> ")")
Applicative instance: 


instance Applicative Frequency where
  pure  = return
  Frequency fs fname <*> Frequency ys yname =
    Frequency [ (p * q, f y) | (p, f) <- fs
                             , (q, y) <- ys ]
              ("(" <> fname <> ") <*> (" <> yname <> ")")
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/LambdaHack-0.5.0.0/Game/LambdaHack/Client/AI/Strategy.hs
Monad instance: 


-- | Strategy is a monad. TODO: Can we write this as a monad transformer?
instance Monad Strategy where
  {-# INLINE return #-}
  return x = Strategy $ return $! uniformFreq "Strategy_return" [x]
  m >>= f  = normalizeStrategy $ Strategy
    [ toFreq name [ (p * q, b)
                  | (p, a) <- runFrequency x
                  , y <- runStrategy (f a)
                  , (q, b) <- runFrequency y
                  ]
    | x <- runStrategy m
    , let name = "Strategy_bind (" <> nameFrequency x <> ")"]
Applicative instance: 


instance Applicative Strategy where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactor-0.1.3/Reactor/Observable.hs
Applicative instance: 


instance Applicative Observable where
  pure a = Observable $ \o -> (o ! a) *> complete o $> mempty
  (<*>) = (<.>)
Monad instance: 


instance Monad Observable where
  return = pure
  (>>=) = (>>-)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactor-0.1.3/Reactor/Task.hs
Applicative instance: 


instance Applicative Task where
  pure a = Task (\ks _kf _e -> ks a)
  (<*>) = (<.>)
Monad instance: 


instance Monad Task where
  return = pure
  (>>=) = (>>-)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactor-0.1.3/Reactor/Moore.hs
Applicative instance: 


instance Applicative (Moore i) where
  pure o = m where m = Moore (const m) o
  (<*>) = (<.>)
  (<* ) = (<. )
  ( *>) = ( .>)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/concurrent-state-0.6.0.0/src/Control/Monad/State/Concurrent/Strict.hs
Applicative instance: 


instance (Functor m, MonadIO m) => Applicative (StateC s m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance MonadIO m => Monad (StateC s m) where
    return a = StateC $ \s -> return (a, s)
    m >>= k = StateC $ \s -> do
        (a, s') <- _runStateC m s
        _runStateC (k a) s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/concurrent-state-0.6.0.0/src/Control/Monad/State/Concurrent/Lazy.hs
Applicative instance: 


instance (Functor m, MonadIO m) => Applicative (StateC s m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance MonadIO m => Monad (StateC s m) where
    return a = StateC $ \s -> return (a, s)
    m >>= k = StateC $ \s -> do
        ~(a, s') <- _runStateC m s
        _runStateC (k a) s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/concurrent-state-0.6.0.0/src/Control/Monad/RWS/Concurrent/Strict.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (RWSC r w s m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad m => Monad (RWSC r w s m) where
    return a = RWSC $ \_ s w -> return (a, s, w)
    m >>= k = RWSC $ \r s w -> do
        (a, s', w') <- _runRWSC m r s w
        _runRWSC (k a) r s' w'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/concurrent-state-0.6.0.0/src/Control/Monad/RWS/Concurrent/Lazy.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (RWSC r w s m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad m => Monad (RWSC r w s m) where
    return a = RWSC $ \_ s w -> return (a, s, w)
    m >>= k = RWSC $ \r s w -> do
        ~(a, s', w') <- _runRWSC m r s w
        _runRWSC (k a) r s' w'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/concurrent-state-0.6.0.0/src/Control/Monad/Writer/Concurrent/Strict.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (WriterC w m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad m => Monad (WriterC w m) where
    return a = WriterC $ \w -> return (a, w)
    m >>= k = WriterC $ \w -> do
        (a, w') <- _runWriterC m w
        _runWriterC (k a) w'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/concurrent-state-0.6.0.0/src/Control/Monad/Writer/Concurrent/Lazy.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (WriterC w m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad m => Monad (WriterC w m) where
    return a = WriterC $ \w -> return (a, w)
    m >>= k = WriterC $ \w -> do
        ~(a, w') <- _runWriterC m w
        _runWriterC (k a) w'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-llvm-0.8.1/src/Synthesizer/LLVM/Parameterized/SignalPrivate.hs
Applicative instance: 


{- |
ZipList semantics
-}
instance Applicative (T p) where
   pure x =
      simple
         (\() () -> return (x, ()))
         (\() -> return ((),()))
         (return ())
   (<*>) = zipWithSimple (\f a -> return (f a))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-llvm-0.8.1/src/Synthesizer/LLVM/Parameter.hs
Applicative instance: 


{- |
Useful for combining @T p a@ and @T p b@ to @T p (a,b)@
using @liftA2 (,)@.
However, we do not recommend to do so
because the result parameter can only be constant
if both operands are constant.
-}
instance App.Applicative (T p) where
   pure a = Constant a
   Constant f <*> Constant a = Constant (f a)
   f <*> a = Variable (\p -> get f p (get a p))
Monad instance: 


instance Monad (T p) where
   return = pure
   Constant x >>= f = f x
   Variable x >>= f =
      Variable (\p -> get (f (x p)) p)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-llvm-0.8.1/src/Synthesizer/LLVM/CausalParameterized/ProcessPrivate.hs
Applicative instance: 


instance Applicative (T p a) where
   pure = ArrowUtil.pure
   (<*>) = ArrowUtil.apply
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-llvm-0.8.1/src/Synthesizer/LLVM/CausalParameterized/Functional.hs
Applicative instance: 


instance Applicative (T p inp) where
   pure a = tagUnique $ arr (const a)
   f <*> x = fmap (uncurry ($))  $  f &|& x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-llvm-0.8.1/src/Synthesizer/LLVM/CausalParameterized/FunctionalPlug.hs
Applicative instance: 


instance Applicative (Core pp pl inp) where
   pure a = lift0Core $ pure a
   f <*> x = fmap (uncurry ($))  $  combineCore f x
Applicative instance: 


instance Applicative (T pp pl inp) where
   pure a = tagUnique $ pure $ pure a
   f <*> x = fmap (uncurry ($))  $  f &|& x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-llvm-0.8.1/src/Synthesizer/LLVM/Simple/SignalPrivate.hs
Applicative instance: 


{- |
ZipList semantics
-}
instance Applicative T where
   pure x = simple (\() -> return (x, ())) (return ())
   f <*> a = fmap (uncurry ($)) $ zip f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-llvm-0.8.1/src/Synthesizer/LLVM/Simple/Value.hs
Applicative instance: 


instance Applicative T where
   pure = constantValue
   f <*> x = consUnique (code f <*> code x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-llvm-0.8.1/src/Synthesizer/LLVM/Interpolation.hs
Applicative instance: 


instance Applicative Nodes02 where
   pure x = Nodes02 x x
   (Nodes02 f0 f1) <*> (Nodes02 x0 x1) = Nodes02 (f0 x0) (f1 x1)
Applicative instance: 


instance Applicative Nodes13 where
   pure x = Nodes13 x x x x
   (Nodes13 f0 f1 f2 f3) <*> (Nodes13 x0 x1 x2 x3) =
      Nodes13 (f0 x0) (f1 x1) (f2 x2) (f3 x3)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-llvm-0.8.1/src/Synthesizer/LLVM/Filter/ComplexFirstOrder.hs
Applicative instance: 


instance App.Applicative Parameter where
   {-# INLINE pure #-}
   pure x = Parameter x (x Complex.+: x)
   {-# INLINE (<*>) #-}
   Parameter fk fc <*> Parameter pk pc =
      Parameter (fk pk) $
         (Complex.real fc $ Complex.real pc)
         Complex.+:
         (Complex.imag fc $ Complex.imag pc)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-llvm-0.8.1/src/Synthesizer/LLVM/Causal/ProcessPrivate.hs
Applicative instance: 


instance Applicative (T a) where
   pure = ArrowUtil.pure
   (<*>) = ArrowUtil.apply
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-llvm-0.8.1/src/Synthesizer/LLVM/Generator/Exponential2.hs
Applicative instance: 


instance App.Applicative Parameter where
   {-# INLINE pure #-}
   pure x = Parameter x
   {-# INLINE (<*>) #-}
   Parameter f <*> Parameter k =
      Parameter (f k)
Applicative instance: 


instance App.Applicative ParameterPacked where
   {-# INLINE pure #-}
   pure x = ParameterPacked x x
   {-# INLINE (<*>) #-}
   f <*> p = ParameterPacked
      (ppFeedback f $ ppFeedback p)
      (ppCurrent f $ ppCurrent p)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/perdure-0.2.1/src/Database/Perdure/CDeserializer.hs
Applicative instance: 

--instance Pointed (Deserializer c) where
--    point x = ... inlined into pure
instance Applicative (Deserializer f) where
  {-# INLINE pure #-}
  pure x = Deserializer $ \b _ -> DeserOut x b
  {-# INLINE (<*>) #-}
  g <*> x = Deserializer $ \b ptr -> case deserialize g b ptr of DeserOut g' b' -> deserialize (g' <$> x) b' ptr
Monad instance: 

    -- we could define <*> = ap, but we would like to see if we could use <*> in the definition of join instead, see reflexion below
instance Monad (Deserializer f) where
  {-# INLINE return #-}
  return = pure
  {-# INLINE (>>=) #-}
  (>>=) = fmap join' . flip fmap where
    {-# INLINE join' #-}
    join' :: Deserializer f (Deserializer f a) -> Deserializer f a
    join' d2 = Deserializer $ \b ptr -> case deserialize d2 b ptr of DeserOut d b' -> deserialize d b' ptr
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/logict-0.6.0.2/Control/Monad/Logic.hs
Applicative instance: 


instance Applicative (LogicT f) where
    pure a = LogicT $ \sk fk -> sk a fk
    f <*> a = LogicT $ \sk fk -> unLogicT f (\g fk' -> unLogicT a (sk . g) fk') fk
Monad instance: 


instance Monad (LogicT m) where
    return a = LogicT $ \sk fk -> sk a fk
    m >>= f = LogicT $ \sk fk -> unLogicT m (\a fk' -> unLogicT (f a) sk fk') fk
    fail _ = LogicT $ \_ fk -> fk
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lvmlib-1.1/Lvm/Read.hs
Monad instance: 

instance Monad (Read v) where
  return x        = Read (\_  bs -> Result x bs)
  (Read r) >>= f  = Read (\rs bs -> case r rs bs of
                                      Result x bsx -> unRead (f x) rs bsx)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lvmlib-1.1/Lvm/Instr/Resolve.hs
Monad instance: 


instance Monad Resolve where
  return x          = R (\(_,_,d) -> (x,d))
  (R r) >>= f       = R (\ctx@(base,env,_) ->
                            case r ctx of
                              (x,depth') -> case f x of
                                              R fr -> fr (base,env,depth'))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lvmlib-1.1/Lvm/Write.hs
Monad instance: 


instance Monad Emit where
  return x          = Emit (\_   st -> (x,st))
  (Emit e) >>= f    = Emit (\env st -> case e env st of
                                         (x,stx) -> case f x of
                                                      Emit ef -> ef env stx)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tagged-0.8.5/src/Data/Tagged.hs
Applicative instance: 

#endif

#if __GLASGOW_HASKELL__ >= 801
-- these instances are provided by the bifunctors package for GHC<8.1
instance Bifoldable Tagged where
    bifoldMap _ g (Tagged b) = g b
    {-# INLINE bifoldMap #-}

instance Bitraversable Tagged where
    bitraverse _ g (Tagged b) = Tagged <$> g b
    {-# INLINE bitraverse #-}
#endif

#ifdef MIN_VERSION_deepseq
instance NFData b => NFData (Tagged s b) where
    rnf (Tagged b) = rnf b
#endif

#ifdef MIN_VERSION_transformers
# if MIN_VERSION_transformers(0,4,0) && !(MIN_VERSION_transformers(0,5,0))
instance Eq1 (Tagged s) where
    eq1 = (==)

instance Ord1 (Tagged s) where
    compare1 = compare

instance Read1 (Tagged s) where
    readsPrec1 = readsPrec

instance Show1 (Tagged s) where
    showsPrec1 = showsPrec
# else
instance Eq1 (Tagged s) where
    liftEq eq (Tagged a) (Tagged b) = eq a b

instance Ord1 (Tagged s) where
    liftCompare cmp (Tagged a) (Tagged b) = cmp a b

instance Read1 (Tagged s) where
    liftReadsPrec rp _ d = readParen (d > 10) $ \r ->
        [(Tagged a, t) | ("Tagged", s) <- lex r, (a, t) <- rp 11 s]

instance Show1 (Tagged s) where
    liftShowsPrec sp _ n (Tagged b) = showParen (n > 10) $
        showString "Tagged " .
        sp 11 b

instance Eq2 Tagged where
    liftEq2 _ eq (Tagged a) (Tagged b) = eq a b

instance Ord2 Tagged where
    liftCompare2 _ cmp (Tagged a) (Tagged b) = cmp a b

instance Read2 Tagged where
    liftReadsPrec2 _ _ rp _ d = readParen (d > 10) $ \r ->
        [(Tagged a, t) | ("Tagged", s) <- lex r, (a, t) <- rp 11 s]

instance Show2 Tagged where
    liftShowsPrec2 _ _ sp _ n (Tagged b) = showParen (n > 10) $
        showString "Tagged " .
        sp 11 b
# endif
#endif

instance Applicative (Tagged s) where
    pure = Tagged
    {-# INLINE pure #-}
    Tagged f <*> Tagged x = Tagged (f x)
    {-# INLINE (<*>) #-}
    _ *> n = n
    {-# INLINE (*>) #-}
Monad instance: 


instance Monad (Tagged s) where
    return = pure
    {-# INLINE return #-}
    Tagged m >>= k = k m
    {-# INLINE (>>=) #-}
    (>>) = (*>)
    {-# INLINE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/RefSerialize-0.3.1.4/Data/RefSerialize/Parser.hs
Applicative instance: 


instance Applicative STR where
    pure x= STR (\s -> Right (s, x))
    STR g <*> STR f= STR $ \ s ->
                       let mr = g s
                       in case mr of
                         Left err -> Left err
                         Right (s' , x) ->
                           let mr = f s'
                           in case mr of
                             Left err -> Left err
                             Right(s'', y) -> Right(s'', x y)
Monad instance: 


-- | monadic serialization & deserialization
instance  Monad STR where
    return  x = STR (\s -> Right (s, x))
    STR g >>= f = STR (\s ->

                       case g s of
                        Right (s', x)->
                          let
                              STR fun  = f x
                          in  case  fun s' of
                               left@(Left msg) -> left
                               rigth->  rigth

                        Left msg -> Left msg

                    )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/RefSerialize-0.3.1.4/Data/RefSerialize/Serialize.hs
Applicative instance: 


instance Applicative STW where
    pure x = STW (\s ->  (s, x))

    STW g <*> STW f = STW (\s ->

                       let (s', x)= g s
                           (s'',y)= f s'
                       in  (s'', x y)
                    )
Monad instance: 



-- | monadic serialization
instance  Monad STW where
    return  x = STW (\s ->  (s, x))
    STW g >>= f = STW (\s ->

                       let (s', x)= g s
                           STW fun  = f x
                       in    fun s'
                    )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/system-command-0.0.9/src/System/Command/Monad.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (Command m) where
  pure =
    Command . return . Right
  Command mf <*> Command mx =
    Command (mf >>= either (return . Left) go) where
      go f = fmap (either Left (Right . f)) mx
Monad instance: 


instance Monad m => Monad (Command m) where
  return =
    Command . return . Right
  Command mx >>= f =
    Command (mx >>= either (return . Left) (runCommand . f))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/exceptions-0.8.3/src/Control/Monad/Catch/Pure.hs
Applicative instance: 


instance Monad m => Applicative (CatchT m) where
  pure a = CatchT (return (Right a))
  (<*>) = ap
Monad instance: 


instance Monad m => Monad (CatchT m) where
  return = pure
  CatchT m >>= k = CatchT $ m >>= \ea -> case ea of
    Left e -> return (Left e)
    Right a -> runCatchT (k a)
  fail = CatchT . return . Left . toException . userError
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/llvm-extra-0.7/src/LLVM/Extra/MaybeContinuation.hs
Applicative instance: 


instance App.Applicative (T r z) where
   pure = return
   (<*>) = M.ap
Monad instance: 


instance Monad (T r z) where
   return a = lift (return a)
   (>>=) = bind
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/llvm-extra-0.7/src/LLVM/Extra/Memory.hs
Applicative instance: 


instance App.Applicative (Element r o v) where
   pure x =
      Element {
         loadElement = \ _ptr -> return x,
         storeElement = \ _ptr _v -> return (),
         extractElement = \ _o -> return x,
         insertElement = \ _v o -> return o
      }
   f <*> x =
      Element {
         loadElement = \ptr -> loadElement f ptr `ap` loadElement x ptr,
         storeElement = \ptr y -> storeElement f ptr y >> storeElement x ptr y,
         extractElement = \o -> extractElement f o `ap` extractElement x o,
         insertElement = \y o -> insertElement f y o >>= insertElement x y
      }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/llvm-extra-0.7/src/LLVM/Extra/Vector.hs
Applicative instance: 


instance App.Applicative (Constant n) where
   {-# INLINE pure #-}
   pure = Constant
   {-# INLINE (<*>) #-}
   Constant f <*> Constant a = Constant (f a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uu-tc-2015.1.1/src/ParseLib/Abstract/Core.hs
Applicative instance: 


instance Applicative (Parser s) where
  pure x    =  Parser (SP.succeed x)
  p <*> q   =  Parser (runParser p SP.<*> runParser q)
Monad instance: 


instance Monad (Parser s) where
  return    =  pure
  p >>= f   =  Parser (runParser p SP.>>= (runParser . f))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uu-tc-2015.1.1/src/ParseLib/Parallel/Core.hs
Applicative instance: 


instance Applicative (Parser s) where
  pure x    =  return x
  p <*> q   =  p >>= \ f -> q >>= \ x -> return (f x)
Monad instance: 


instance Monad (Parser s) where
  return x  =  Parser (\ k -> k x)
  p >>= f   =  Parser (\ k -> runParser p (\ x -> runParser (f x) k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hackage-server-0.5.0/Distribution/Server/Features/EditCabalFiles.hs
Monad instance: 


instance Monad CheckM where
  return         = CheckM . return
  CheckM m >>= f = CheckM (m >>= unCheckM . f)
  fail           = CheckM . throwError
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hackage-server-0.5.0/Distribution/Server/Framework/BackupRestore.hs
Monad instance: 


instance Monad Restore where
  return = RestoreDone
  fail   = RestoreFail
  RestoreDone x        >>= g = g x
  RestoreFail err      >>= _ = RestoreFail err
  RestoreAddBlob bs  f >>= g = RestoreAddBlob bs  $ \bid -> f bid >>= g
  RestoreGetBlob bid f >>= g = RestoreGetBlob bid $ \bs  -> f bs  >>= g
Applicative instance: 


instance Applicative Restore where
  pure      = return
  mf <*> mx = do f <- mf ; x <- mx ; return (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/remote-debugger-0.2.2/src/DebuggerMonad.hs
Monad instance: 


instance Monad DebuggerMonad where
    (DebuggerMonad m) >>= k = DebuggerMonad $ \s -> m s >>= \a -> toGhc (k a) s
    return a = DebuggerMonad $ \_ -> return a
Applicative instance: 


instance Applicative DebuggerMonad where
    pure  = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/remote-debugger-0.2.2/src/ParserMonad.hs
Monad instance: 


instance Monad Parser where
    p1 >>= fp2 = P $ \cs -> do
        (a, cs') <- parse p1 cs
        parse (fp2 a) cs'
    return x   = P $ \cs -> [ (x, cs) ]
    fail _     = P $ \_ ->  []
Applicative instance: 


instance Applicative Parser where
    pure x = P $ \cs -> [ (x, cs) ]
    a <*> b = a >>= (\f -> fmap f b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ede-0.2.8.5/src/Text/EDE/Internal/Types.hs
Monad instance: 


instance Monad Result where
    return          = Success
    {-# INLINE return #-}
    Success x >>= k = k x
    Failure e >>= _ = Failure e
    {-# INLINE (>>=) #-}
Applicative instance: 


instance Applicative Result where
    pure = return
    {-# INLINE pure #-}
    Success f <*> Success x  = Success (f x)
    Success _ <*> Failure e  = Failure e
    Failure e <*> Success _  = Failure e
    Failure e <*> Failure e' = Failure (PP.vsep [e, e'])
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/grm-0.1.1/Grm/Lex.hs
Monad instance: 


instance Monad M where
  (M f) >>= g = M $ \st ->
    let (ma, st1) = f st
      in case ma of
        Left e -> (Left e, st)
        Right a ->
          let M h = g a
            in h st1

  return a = M $ \st -> (Right a, st)
  fail s = M $ \st -> (Left s, st)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/folds-0.7.1/src/Data/Fold/L1'.hs
Applicative instance: 


instance Applicative (L1' a) where
  pure x = L1' (\() -> x) (\() _ -> ()) (\_ -> ())
  {-# INLINE pure #-}
  L1' kf hf zf <*> L1' ka ha za = L1'
    (\(Pair' x y) -> kf x (ka y))
    (\(Pair' x y) a -> Pair' (hf x a) (ha y a))
    (\a -> Pair' (zf a) (za a))
  (<*) m = \ _ -> m
  {-# INLINE (<*) #-}
  _ *> m = m
  {-# INLINE (*>) #-}
Monad instance: 


instance Monad (L1' a) where
  return = pure
  {-# INLINE return #-}
  m >>= f = L1' (\xs a -> walk xs (f a)) Snoc1 First <*> m
  {-# INLINE (>>=) #-}
  (>>) = (*>)
  {-# INLINE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/folds-0.7.1/src/Data/Fold/L'.hs
Applicative instance: 


instance Applicative (L' a) where
  pure b = L' (\() -> b) (\() _ -> ()) ()
  {-# INLINE pure #-}

  L' xf bxx xz <*> L' ya byy yz = L'
    (\(Pair' x y) -> xf x $ ya y)
    (\(Pair' x y) b -> Pair' (bxx x b) (byy y b))
    (Pair' xz yz)
  {-# INLINE (<*>) #-}

  (<*) m = \_ -> m
  {-# INLINE (<*) #-}

  _ *> m = m
  {-# INLINE (*>) #-}
Monad instance: 


instance Monad (L' a) where
  return = pure
  {-# INLINE return #-}

  m >>= f = L' (\xs a -> run xs (f a)) Snoc Nil <*> m
  {-# INLINE (>>=) #-}

  (>>) = (*>)
  {-# INLINE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/folds-0.7.1/src/Data/Fold/R.hs
Monad instance: 


instance Monad (R a) where
  return = pure
  {-# INLINE return #-}

  m >>= f = R (\xs a -> run xs (f a)) (:) [] <*> m
  {-# INLINE (>>=) #-}

  (>>) = (*>)
  {-# INLINE (>>) #-}
Applicative instance: 


instance Applicative (R a) where
  pure b = R (\() -> b) (\_ () -> ()) ()
  {-# INLINE pure #-}

  R xf bxx xz <*> R ya byy yz = R
    (\(Pair' x y) -> xf x $ ya y)
    (\b ~(Pair' x y) -> Pair' (bxx b x) (byy b y))
    (Pair' xz yz)
  {-# INLINE (<*>) #-}

  (<*) m = \_ -> m
  {-# INLINE (<*) #-}

  _ *> m = m
  {-# INLINE (*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/folds-0.7.1/src/Data/Fold/L.hs
Applicative instance: 


instance Applicative (L a) where
  pure b = L (\() -> b) (\() _ -> ()) ()
  {-# INLINE pure #-}

  L xf bxx xz <*> L ya byy yz = L
    (\(Pair' x y) -> xf x $ ya y)
    (\(Pair' x y) b -> Pair' (bxx x b) (byy y b))
    (Pair' xz yz)
  {-# INLINE (<*>) #-}

  (<*) m = \_ -> m
  {-# INLINE (<*) #-}

  _ *> m = m
  {-# INLINE (*>) #-}
Monad instance: 


instance Monad (L a) where
  return = pure
  {-# INLINE return #-}

  m >>= f = L (\xs a -> run xs (f a)) Snoc Nil <*> m
  {-# INLINE (>>=) #-}

  (>>) = (*>)
  {-# INLINE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/folds-0.7.1/src/Data/Fold/L1.hs
Applicative instance: 


instance Applicative (L1 a) where
  pure x = L1 (\() -> x) (\() _ -> ()) (\_ -> ())
  {-# INLINE pure #-}
  L1 kf hf zf <*> L1 ka ha za = L1
    (\(Pair' x y) -> kf x (ka y))
    (\(Pair' x y) a -> Pair' (hf x a) (ha y a))
    (\a -> Pair' (zf a) (za a))
  (<*) m = \ _ -> m
  {-# INLINE (<*) #-}
  _ *> m = m
  {-# INLINE (*>) #-}
Monad instance: 


instance Monad (L1 a) where
  return = pure
  {-# INLINE return #-}
  m >>= f = L1 (\xs a -> walk xs (f a)) Snoc1 First <*> m
  {-# INLINE (>>=) #-}
  (>>) = (*>)
  {-# INLINE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/folds-0.7.1/src/Data/Fold/R1.hs
Applicative instance: 


instance Applicative (R1 a) where
  pure x = R1 (\() -> x) (\_ () -> ()) (\_ -> ())
  {-# INLINE pure #-}
  R1 kf hf zf <*> R1 ka ha za = R1
    (\(Pair' x y) -> kf x (ka y))
    (\a ~(Pair' x y) -> Pair' (hf a x) (ha a y))
    (\a -> Pair' (zf a) (za a))
  (<*) m = \ _ -> m
  {-# INLINE (<*) #-}
  _ *> m = m
  {-# INLINE (*>) #-}
Monad instance: 


instance Monad (R1 a) where
  return = pure
  {-# INLINE return #-}
  m >>= f = R1 (\xs a -> walk xs (f a)) Cons1 Last <*> m
  {-# INLINE (>>=) #-}
  (>>) = (*>)
  {-# INLINE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/folds-0.7.1/src/Data/Fold/M1.hs
Applicative instance: 


instance Applicative (M1 a) where
  pure x = M1 (\() -> x) (\_ -> ()) (\() () -> ())
  {-# INLINE pure #-}
  M1 kf hf mf <*> M1 ka ha ma = M1
    (\(Pair' x y) -> kf x (ka y))
    (\a -> Pair' (hf a) (ha a))
    (\(Pair' x1 y1) (Pair' x2 y2) -> Pair' (mf x1 x2) (ma y1 y2))
  (<*) m = \ _ -> m
  {-# INLINE (<*) #-}
  _ *> m = m
  {-# INLINE (*>) #-}
Monad instance: 


instance Monad (M1 a) where
  return = pure
  {-# INLINE return #-}
  m >>= f = M1 (\xs a -> walk xs (f a)) Tip1 Bin1 <*> m
  {-# INLINE (>>=) #-}
  (>>) = (*>)
  {-# INLINE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/folds-0.7.1/src/Data/Fold/M.hs
Applicative instance: 


instance Applicative (M a) where
  pure b = M (\() -> b) (\_ -> ()) (\() () -> ()) ()
  {-# INLINE pure #-}

  M xf bx xx xz <*> M ya by yy yz = M
    (\(Pair' x y) -> xf x $ ya y)
    (\b -> Pair' (bx b) (by b))
    (\(Pair' x1 y1) (Pair' x2 y2) -> Pair' (xx x1 x2) (yy y1 y2))
    (Pair' xz yz)
  {-# INLINE (<*>) #-}

  (<*) m = \_ -> m
  {-# INLINE (<*) #-}

  _ *> m = m
  {-# INLINE (*>) #-}
Monad instance: 


instance Monad (M a) where
  return = pure
  {-# INLINE return #-}

  -- TODO: exploit observable sharing?
  m >>= f = M (\xs a -> run xs (f a)) One Two Zero <*> m
  {-# INLINE (>>=) #-}

  (>>) = (*>)
  {-# INLINE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/flat-maybe-0.1.0.0/Data/Maybe/Flat.hs
Applicative instance: 


instance Applicative Maybe where
    pure = Just

    Just f  <*> m       = fmap f m
    x       <*> _m      = unsafeCoerce# x

    Just _m1 *> m2      = m2
    x        *> _m2     = unsafeCoerce# x
Monad instance: 


instance  Monad Maybe  where
    (Just x) >>= k      = k x
    x        >>= _      = unsafeCoerce# x

    (>>) = (*>)

    return              = Just
    fail _              = Nothing
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/containers-0.5.8.1/tests/seq-properties.hs
Applicative instance: 


instance Applicative M where
    pure x = Action 0 x
    Action m f <*> Action n x = Action (m+n) (f x)
Monad instance: 


instance Monad M where
    return x = Action 0 x
    Action m x >>= f = let Action n y = f x in Action (m+n) y
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/incremental-parser-0.2.4.1/Test/TestIncrementalParser.hs
Applicative instance: 


instance Applicative (TestParser a) where
   pure x = TestParser (Described "pure ?" (pure x))
   TestParser (Described d1 p1) <*> TestParser (Described d2 p2) =
      TestParser (Described (d1 ++ " <*> " ++ d2) (p1 <*> p2))
Monad instance: 


instance Monad (TestParser a) where
   return x = TestParser (Described "return ?" (return x))
   TestParser (Described d1 p1) >>= f =
      TestParser (Described (d1 ++ " >>= ?") (p1 >>= describedParser . f))
   TestParser (Described d1 p1) >> TestParser (Described d2 p2) =
      TestParser (Described (d1 ++ " >> " ++ d2) (p1 >> p2))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/incremental-parser-0.2.4.1/Text/ParserCombinators/Incremental.hs
Applicative instance: 


-- | The '<*>' combinator requires its both arguments to provide complete parsing results, whereas '*>' and '<*'
-- preserve the incremental results.
instance Monoid s => Applicative (Parser t s) where
   pure = Result mempty
   Result s r <*> p = r <$> feed s p
   p1 <*> p2 = apply (<*> p2) p1

   Result s _ *> p = feed s p
   ResultPart _ e f *> p | isInfallible p = ResultPart id (e *> p) ((*> p) . f)
                         | otherwise = Delay (e *> p) ((*> p) . f)
   p1 *> p2 = apply (*> p2) p1

   Result s r <* p = feed s p *> pure r
   ResultPart r e f <* p | isInfallible p = ResultPart r (e <* p) ((<* p) . f)
   p1 <* p2 = apply (<* p2) p1
Monad instance: 


-- | Usage of '>>=' destroys the incrementality of its left argument's parsing results, but '>>' is safe to use.
instance Monoid s => Monad (Parser t s) where
   return = pure
   Result s r >>= f = feed s (f r)
   p >>= f = apply (>>= f) p
   (>>) = (*>)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/digestive-functors-0.8.1.0/src/Text/Digestive/Types.hs
Applicative instance: 



--------------------------------------------------------------------------------
instance Monoid v => Applicative (Result v) where
    pure x                  = Success x
    Error x   <*> Error y   = Error $ mappend x y
    Error x   <*> Success _ = Error x
    Success _ <*> Error y   = Error y
    Success x <*> Success y = Success (x y)
Monad instance: 



--------------------------------------------------------------------------------
instance Monoid v => Monad (Result v) where
    return x          = Success x
    (Error x)   >>= _ = Error x
    (Success x) >>= f = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/digestive-functors-0.8.1.0/src/Text/Digestive/Form/Internal.hs
Applicative instance: 



--------------------------------------------------------------------------------
instance (Monad m, Monoid v) => Applicative (FormTree t v m) where
    pure x  = Pure (Singleton x)
    x <*> y = App x y
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/applicative-fail-1.1.1/src/Control/Applicative/Fail.hs
Applicative instance: 


instance (Monoid e) => Applicative (Fail e) where
    pure a = Success a
    (Success f) <*> a = fmap f a
    (Fail e1 f) <*> (Fail e2 a) = Fail (e1 <> e2) (f <*> a)
    (Fail e f) <*> (Success a) = Fail e (fmap ($ a) f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/simple-form-0.5.0/SimpleForm/Digestive/Internal.hs
Applicative instance: 


instance Applicative (SimpleForm r) where
        pure = return
        (<*>) = ap
Monad instance: 


instance Monad (SimpleForm r) where
        return = SimpleForm . return
        (SimpleForm x) >>= f = SimpleForm (x >>= (\v -> let SimpleForm r = f v in r))
        fail = SimpleForm . fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/flickr-0.3.3/Flickr/Monad.hs
Monad instance: 


instance Monad FM where
  return x = FM (\ _ -> return x)
  (FM a) >>= k = FM $ \ env -> do
      v <- a env
      case k v of
        (FM b) ->  b env
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/purescript-0.9.3/src/Control/Monad/Logger.hs
Applicative instance: 


instance (Monoid w) => Applicative (Logger w) where
  pure = Logger . const . pure
  (<*>) = ap
Monad instance: 


instance (Monoid w) => Monad (Logger w) where
  return = pure
  Logger l >>= f = Logger $ \r -> l r >>= \a -> runLogger (f a) r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/stgi-1.0.1/src/Stg/Util.hs
Applicative instance: 


-- | Return success or the accumulation of all failures
instance Monoid a => Applicative (Validate a) where
    pure = Success
    Success f <*> Success x = Success (f x)
    Success _ <*> Failure x = Failure x
    Failure x <*> Failure y = Failure (x <> y)
    Failure x <*> Success _ = Failure x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/test-framework-0.8.1.1/Test/Framework/Improving.hs
Applicative instance: 


instance Applicative (ImprovingIO i f) where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad (ImprovingIO i f) where
    return x = IIO (const $ return x)
    ma >>= f = IIO $ \chan -> do
                    a <- unIIO ma chan
                    unIIO (f a) chan
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/transformers-free-1.0.1/Control/Monad/Trans/Free.hs
Applicative instance: 


instance (Functor f, Monad m) => Applicative (FreeT f m) where
    pure  = return
    (<*>) = ap
Monad instance: 


instance (Functor f, Monad m) => Monad (FreeT f m) where
    return  = FreeT . return . Pure
    m >>= f = FreeT $ do
        x <- runFreeT m
        runFreeT $ case x of
            Pure a -> f a
            Free w -> wrap $ fmap (>>= f) w
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reform-0.2.7.1/Text/Reform/Result.hs
Monad instance: 


instance Monad (Result e) where
    return = Ok
    Error x >>= _ = Error x
    Ok x    >>= f = f x
Applicative instance: 


instance Applicative (Result e) where
    pure = Ok
    Error x <*> Error y = Error $ x ++ y
    Error x <*> Ok _    = Error x
    Ok _    <*> Error y = Error y
    Ok x    <*> Ok y    = Ok $ x y
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reform-0.2.7.1/Text/Reform/Core.hs
Applicative instance: 



instance (Functor m, Monoid view, Monad m) => Applicative (Form m input error view ()) where
    pure a =
      Form $
        do i <- getFormId
           return (View $ const $ mempty, return $ Ok $ Proved { proofs    = ()
                                                               , pos       = FormRange i i
                                                               , unProved  = a
                                                               })
    -- this coud be defined in terms of <<*>> if we just changed the proof of frmF to (() -> ())
    (Form frmF) <*> (Form frmA) =
       Form $
         do ((view1, mfok), (view2, maok)) <- bracketState $
              do res1 <- frmF
                 incFormId
                 res2 <- frmA
                 return (res1, res2)
            fok <- lift $ lift $ mfok
            aok <- lift $ lift $ maok
            case (fok, aok) of
              (Error errs1, Error errs2) -> return (view1 `mappend` view2, return $ Error $ errs1 ++ errs2)
              (Error errs1, _)           -> return (view1 `mappend` view2, return $ Error $ errs1)
              (_          , Error errs2) -> return (view1 `mappend` view2, return $ Error $ errs2)
              (Ok (Proved p (FormRange x _) f), Ok (Proved q (FormRange _ y) a)) ->
                  return (view1 `mappend` view2, return $ Ok $ Proved { proofs   = ()
                                                                      , pos      = FormRange x y
                                                                      , unProved = f a
                                                                      })
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fclabels-2.0.3/src/Data/Label/Point.hs
Applicative instance: 


instance Arrow arr => Applicative (Point arr f i f) where
  pure a  = Point (const a) (arr snd)
  a <*> b = Point (arr app . (get a &&& get b)) $
    proc (t, p) -> do (f, v) <- get a &&& get b -< p
                      q <- modify a             -< (t . arr ($ v), p)
                      modify b                  -< (t . arr f, q)
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
Applicative instance: 


-- | Missing Applicative instance for Kleisli.

instance Applicative f => Applicative (Kleisli f i) where
  pure a = Kleisli (const (pure a))
  Kleisli a <*> Kleisli b = Kleisli ((<*>) <$> a <*> b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactive-banana-1.1.0.1/src/Reactive/Banana/Model.hs
Applicative instance: 


instance Applicative Behavior where
    pure x          = B $ repeat x
    (B f) <*> (B x) = B $ zipWith ($) f x
Applicative instance: 

instance Applicative Moment where
    pure   = M . const
    (<*>)  = ap
Monad instance: 

instance Monad Moment where
    return = pure
    (M m) >>= k = M $ \time -> unM (k $ m time) time
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactive-banana-1.1.0.1/src/Reactive/Banana/Types.hs
Applicative instance: 


-- | The function 'pure' returns a value that is constant in time. Semantically,
--
-- > pure     :: a -> Behavior a
-- > pure x    = \time -> x
--
-- The combinator '<*>' applies a time-varying function to a time-varying value.
--
-- > (<*>)    :: Behavior (a -> b) -> Behavior a -> Behavior b
-- > fx <*> bx = \time -> fx time $ bx time
instance Applicative Behavior where
    pure x    = B $ Prim.pureB x
    bf <*> bx = B $ Prim.applyB (unB bf) (unB bx)
Monad instance: 


instance Monad Future where
    return  = F . return
    m >>= g = F $ unF m >>= unF . g
Applicative instance: 


instance Applicative Future where
    pure    = F . pure
    f <*> a = F $ unF f <*> unF a
Monad instance: 

instance Monad Moment where
    return  = M . return
    m >>= g = M $ unM m >>= unM . g
Applicative instance: 

instance Applicative Moment where
    pure    = M . pure
    f <*> a = M $ unM f <*> unM a
Monad instance: 

instance Monad MomentIO where
    return  = MIO . return
    m >>= g = MIO $ unMIO m >>= unMIO . g
Applicative instance: 

instance Applicative MomentIO where
    pure    = MIO . pure
    f <*> a = MIO $ unMIO f <*> unMIO a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactive-banana-1.1.0.1/src/Reactive/Banana/Test/Plumbing.hs
Applicative instance: 

instance Applicative Behavior where pure = pureB; (<*>) = applyB
Applicative instance: 

instance Applicative Moment where
    pure  = return
    (<*>) = ap
Monad instance: 

instance Monad Moment where
    return a = M (return a) (return a)
    ~(M x y) >>= g = M (x >>= fstM . g) (y >>= sndM . g)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactive-banana-1.1.0.1/src/Control/Monad/Trans/ReaderWriterIO.hs
Applicative instance: 


instance Applicative m => Applicative (ReaderWriterIOT r w m) where
    pure  = pureR
    (<*>) = apR
Monad instance: 


instance Monad m => Monad (ReaderWriterIOT r w m) where
    return = returnR
    (>>=)  = bindR
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactive-banana-1.1.0.1/src/Control/Monad/Trans/RWSIO.hs
Applicative instance: 


instance Applicative m => Applicative (RWSIOT r w s m) where
    pure  = pureR
    (<*>) = apR
Monad instance: 


instance Monad m => Monad (RWSIOT r w s m) where
    return = returnR
    (>>=)  = bindR
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tsession-0.1/Control/TSession.hs
Monad instance: 


instance Monad (Trans k v status) where
  return = Trans . return . Success
  x >>= f = Trans $ do
    res <- runTransactionPart x
    case res of
      Success a ->
        runTransactionPart $ f a
      Exception e -> return $ Exception e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/log-domain-0.9.3/src/Numeric/Log.hs
Applicative instance: 


instance Applicative Log where
  pure = Exp
  {-# INLINE pure #-}
  Exp f <*> Exp a = Exp (f a)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Log where
  return = Exp
  {-# INLINE return #-}
  Exp a >>= f = f a
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/diagrams-lib-1.3.1.4/src/Diagrams/Angle.hs
Applicative instance: 


instance Applicative Angle where
  pure = Radians
  {-# INLINE pure #-}
  Radians f <*> Radians x = Radians (f x)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/anticiv-0.1.0.5/Network/Anticiv/Modules/Ironforge.hs
Monad instance: 


instance Monad m => Monad (MonoPrinterT m) where
  return = MonoPrinter . return
  (MonoPrinter m) >>= f = MonoPrinter $ m >>= runMonoPrinter . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/anticiv-0.1.0.5/Network/Anticiv/Monad.hs
Applicative instance: 


instance (Functor f, Monad f) => Applicative (BotT f) where
  pure = return
  fm <*> fa = do
    f <- fm
    a <- fa
    return (f a)
Monad instance: 


instance Monad m => Monad (BotT m) where
  return a = BotT $ \s -> return (a,s)
  m >>= f = BotT $ \s -> do (a,s') <- runBotT m s; runBotT (f a) s'
Monad instance: 


instance Monad Packciv where
  return a = Anticiv $ return a
  m >>= f = Anticiv $ runAnticiv m >>= runAnticiv . f
Applicative instance: 


instance (Functor f, Monad f) => Applicative (OutPlexT f) where
  pure = return
  fm <*> fa = do
    f <- fm
    a <- fa
    return (f a)
Monad instance: 


instance Monad m => Monad (OutPlexT m) where
  return a = OutPlex $ \h ts -> return (a,ts)
  m >>= f = OutPlex $ \h ts -> do
    (a,ts') <- runOutPlex m h ts
    runOutPlex (f a) h ts'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/explicit-exception-0.1.8/src/Control/Monad/Label.hs
Applicative instance: 


{-
instance Functor (Label l) where
   fmap f m = Label $ \l -> f (runLabelPriv m l)

instance Monad (Label l) where
   return a = Label $ \_ -> a
   m >>= k  = Label $ \l -> runLabelPriv (k (runLabelPriv m l)) l

instance MonadFix (Label l) where
   mfix f = Label $ \l -> let a = runLabelPriv (f a) l in a
-}

instance Applicative (Label l) where
   pure  = return
   (<*>) = ap
Applicative instance: 


instance Applicative m => Applicative (LabelT l m) where
   pure a  = LabelT $ pureReaderT a
   f <*> x = LabelT $ runLabelPrivT f `apReaderT` runLabelPrivT x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/explicit-exception-0.1.8/src/Control/Monad/Exception/Synchronous.hs
Applicative instance: 


instance Applicative (Exceptional e) where
   pure = Success
   f <*> x =
      case f of
         Exception e -> Exception e
         Success g ->
            case x of
               Success a   -> Success (g a)
               Exception e -> Exception e
Monad instance: 


instance Monad (Exceptional e) where
   return = Success
   fail _msg = Exception (error "Exception.Synchronous: Monad.fail method is not supported")
   x >>= f =
      case x of
         Exception e -> Exception e
         Success y -> f y
Applicative instance: 


instance Applicative m => Applicative (ExceptionalT e m) where
   pure = ExceptionalT . pure . pure
   ExceptionalT f <*> ExceptionalT x =
      ExceptionalT (fmap (<*>) f <*> x)
Monad instance: 


instance Monad m => Monad (ExceptionalT e m) where
   return = ExceptionalT . return . return
   x0 >>= f =
      ExceptionalT $
         runExceptionalT x0 >>= \x1 ->
         case x1 of
            Exception e -> return (Exception e)
            Success x -> runExceptionalT $ f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/explicit-exception-0.1.8/src/Control/Monad/Exception/Warning.hs
Applicative instance: 


instance Applicative (Warnable e) where
   pure = Warnable [] -- [Nothing]?
   f <*> x =
      case f of
         Warnable e0 g ->
            case x of
               Warnable e1 y -> Warnable (mplus e0 e1) (g y)
Monad instance: 


instance Monad (Warnable e) where
   return = Warnable [] -- [Nothing]?
   fail _msg =
      Warnable
         [Just (error "Warning.fail exception")]
         (error "Warning.fail result")
   x >>= f =
      case x of
         Warnable e0 y ->
            case f y of
               Warnable e1 z -> Warnable (e0 ++ e1) z
Applicative instance: 


instance Applicative m => Applicative (WarnableT e m) where
   pure = WarnableT . pure . pure
   WarnableT f <*> WarnableT x =
      WarnableT (fmap (<*>) f <*> x)
Monad instance: 


instance Monad m => Monad (WarnableT e m) where
   return = WarnableT . return . return
   x0 >>= f =
      WarnableT $
      do Warnable ex x <- runWarnableT x0
         Warnable ey y <- runWarnableT (f x)
         return $ Warnable (ex ++ ey) y
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mmorph-1.0.6/src/Control/Monad/Trans/Compose.hs
Applicative instance: 


instance Applicative (f (g m)) => Applicative (ComposeT f g m) where
    pure a = ComposeT (pure a)
    ComposeT f <*> ComposeT a = ComposeT (f <*> a)
    ComposeT a *> ComposeT b = ComposeT (a *> b)
    ComposeT a <* ComposeT b = ComposeT (a <* b)
Monad instance: 


instance Monad (f (g m)) => Monad (ComposeT f g m) where
    return a = ComposeT (return a)
    m >>= f  = ComposeT (getComposeT m >>= \x -> getComposeT (f x))
    fail e   = ComposeT (fail e)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reflex-orphans-0.1.0.2/src/Reflex/Orphans.hs
Applicative instance: 


instance Reflex t => Applicative (Dynamic t) where
    pure = constDyn
    f <*> x = unsafeDynamic
              ((current f) <*> (current x))
              (push (\case
                        This a -> (Just . a) <$> (sample . current $ x)
                        That b -> (Just . ($ b)) <$> (sample . current $ f)
                        These a b -> return . Just $ a b) $ align (updated f) (updated x))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/safe-lazy-io-0.1/System/IO/Lazy/Input/Internals.hs
Applicative instance: 


instance Applicative Finalized where
   pure x = x `Finally` return ()
   (f `Finally` finalizeF) <*> (x `Finally` finalizeX) = f x `Finally` (finalizeF >> finalizeX)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sgf-0.1.3.1/Data/SGF/Parse/Encodings.hs
Applicative instance: 


instance Applicative (MyEither a) where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad (MyEither a) where
    return = MyEither . Right
    (MyEither (Right x)) >>= f = f x
    (MyEither (Left  x)) >>= f = MyEither (Left x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/libzfs-0.1.0.2/src/System/Zfs/Types.hs
Applicative instance: 


instance Monad m => Applicative (ZfsT z m) where
  (<*>) = ap
  pure = return
Monad instance: 


instance Monad m => Monad (ZfsT z m) where
  return = Zfs . const . return . Right
  m >>= f = Zfs $ \z -> do
    a <- runZfs' m z
    case a of
      Right a' -> runZfs' (f a') z
      Left e -> return $ Left e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/control-monad-loop-0.1/Control/Monad/Trans/Loop.hs
Applicative instance: 


instance Applicative (LoopT c e m) where
    pure a    = LoopT $ \_    _   cont -> cont a
    f1 <*> f2 = LoopT $ \next fin cont ->
                runLoopT f1 next fin $ \f ->
                runLoopT f2 next fin (cont . f)
Monad instance: 


instance Monad (LoopT c e m) where
    return a = LoopT $ \_    _   cont -> cont a
    m >>= k  = LoopT $ \next fin cont ->
               runLoopT m next fin $ \a ->
               runLoopT (k a) next fin cont
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pqueue-1.3.1.1/Control/Applicative/Identity.hs
Applicative instance: 


instance Applicative Identity where
  pure = Identity
  Identity f <*> Identity x = Identity (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/validation-0.5.3/src/Data/Validation.hs
Applicative instance: 


instance Semigroup err => Applicative (AccValidation err) where
  pure =
    AccSuccess
  (<*>) =
    (<.>)
Applicative instance: 


instance Applicative (Validation err) where
  pure =
    Success
  (<*>) =
    apValidation
Monad instance: 


instance Monad (Validation err) where
  return =
    Success
  (>>=) =
    bindValidation
Applicative instance: 


instance Applicative m => Applicative (ValidationT err m) where
  pure =
    pureValidationT
  (<*>) =
    aplValidationT
Monad instance: 


instance Monad m => Monad (ValidationT err m) where
  return =
    returnValidationT
  (>>=) =
    bindValidationT
Applicative instance: 


instance Applicative m => Applicative (ValidationB m err) where
  pure =
    pureValidationB
  (<*>) =
    aplValidationB
Monad instance: 


instance Monad m => Monad (ValidationB m err) where
  return =
    returnValidationB
  (>>=) =
    bindValidationB
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/MaybeT-0.1.2/Control/Monad/Maybe.hs
Monad instance: 


instance (Monad m) => Monad (MaybeT m) where
  fail _ = MaybeT (return Nothing)
  return = lift . return
  x >>= f = MaybeT (runMaybeT x >>= maybe (return Nothing) (runMaybeT . f))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CC-delcont-ref-tf-0.1.0.2/Bench_nondet.hs
Monad instance: 


instance Monad CPS where
    return x = CPS $ \k -> k x
    m >>= f  = CPS $ \k -> unCPS m (\a -> unCPS (f a) k)
Monad instance: 


instance Monad m => Monad (CCR m) where
    return x = CCR $ \_ -> return x
    m >>= f  = CCR $ \p -> unCCR m p >>= \v -> unCCR (f v) p
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CC-delcont-ref-tf-0.1.0.2/Control/Monad/CC/CCRef.hs
Monad instance: 

-- hence, the rest of scAPI is irrelevant:
-- copy_stack_fragment and push_stack_fragment do nothing at all

-- --------------------------------------------------------------------
-- | CC monad: general monadic operations

instance Monad m => Monad (CC m) where
    return x = CC $ \k _ -> k x
    m >>= f  = CC $ \k ptop -> unCC m (\v -> unCC (f v) k ptop) ptop
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pugixml-0.3.2/Text/XML/Pugi/Mutable.hs
Applicative instance: 


instance Applicative Modify where
    pure      = Modify . return . Right
    mf <*> ma = Modify $ runModify mf >>= \case
        Left  e -> return (Left e)
        Right f -> runModify ma >>= \case
            Left  e -> return (Left e)
            Right a -> return (Right (f a))
Monad instance: 


instance Monad Modify where
    return = pure
    ma >>= g = Modify $ runModify ma >>= \case
        Left  e -> return (Left e)
        Right a -> runModify $ g a
    fail = Modify . return . Left
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/transformers-compat-0.5.1.4/0.3/Control/Monad/Trans/Except.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (ExceptT e m) where
    pure a = ExceptT $ return (Right a)
    ExceptT f <*> ExceptT v = ExceptT $ do
        mf <- f
        case mf of
            Left e -> return (Left e)
            Right k -> do
                mv <- v
                case mv of
                    Left e -> return (Left e)
                    Right x -> return (Right (k x))
Monad instance: 


instance (Monad m) => Monad (ExceptT e m) where
    return a = ExceptT $ return (Right a)
    m >>= k = ExceptT $ do
        a <- runExceptT m
        case a of
            Left e -> return (Left e)
            Right x -> runExceptT (k x)
    fail = ExceptT . fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/transformers-compat-0.5.1.4/0.2/Control/Applicative/Backwards.hs
Applicative instance: 


-- | Apply @f@-actions in the reverse order.
instance (Applicative f) => Applicative (Backwards f) where
    pure a = Backwards (pure a)
    Backwards f <*> Backwards a = Backwards (a <**> f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/transformers-compat-0.5.1.4/0.2/Control/Applicative/Lift.hs
Applicative instance: 


-- | A combination is 'Pure' only if both parts are.
instance (Applicative f) => Applicative (Lift f) where
    pure = Pure
    Pure f <*> Pure x = Pure (f x)
    Pure f <*> Other y = Other (f <$> y)
    Other f <*> Pure x = Other (($ x) <$> f)
    Other f <*> Other y = Other (f <*> y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/transformers-compat-0.5.1.4/0.2/Data/Functor/Reverse.hs
Applicative instance: 


-- | Derived instance.
instance (Applicative f) => Applicative (Reverse f) where
    pure a = Reverse (pure a)
    Reverse f <*> Reverse a = Reverse (f <*> a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rcu-0.1/unstable/Control/Concurrent/RCU/STM/Internal.hs
Applicative instance: 


instance Applicative (WritingRCU s) where
  pure a = WritingRCU $ \ _ -> pure a
  WritingRCU mf <*> WritingRCU ma = WritingRCU $ \c -> mf c <*> ma c
Monad instance: 


instance Monad (WritingRCU s) where
  return a = WritingRCU $ \ _ -> pure a
  WritingRCU m >>= f = WritingRCU $ \ c -> do
    a <- m c
    runWritingRCU (f a) c
  fail s = WritingRCU $ \ _ -> fail s
Applicative instance: 


instance Applicative (RCU s) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad (RCU s) where
  return a = RCU $ \ _ -> return a
  RCU m >>= f = RCU $ \s -> do
    a <- m s
    unRCU (f a) s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rcu-0.1/src/Control/Concurrent/RCU/QSBR/Internal.hs
Applicative instance: 


instance Applicative (ReadingRCU s) where
  pure a = ReadingRCU $ \ _ -> pure a
  ReadingRCU mf <*> ReadingRCU ma = ReadingRCU $ \ s -> mf s <*> ma s
Monad instance: 


instance Monad (ReadingRCU s) where
  return a = ReadingRCU $ \ _ -> pure a
  ReadingRCU m >>= f = ReadingRCU $ \ s -> do
    a <- m s
    runReadingRCU (f a) s
  fail s = ReadingRCU $ \ _ -> fail s
Applicative instance: 


instance Applicative (WritingRCU s) where
  pure a = WritingRCU $ \ _ -> pure a
  WritingRCU mf <*> WritingRCU ma = WritingRCU $ \ s -> mf s <*> ma s
Monad instance: 


instance Monad (WritingRCU s) where
  return a = WritingRCU $ \ _ -> pure a
  WritingRCU m >>= f = WritingRCU $ \ s -> do
    a <- m s
    runWritingRCU (f a) s
  fail s = WritingRCU $ \ _ -> fail s
Applicative instance: 


instance Applicative (RCU s) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad (RCU s) where
  return a = RCU $ \ _ -> return a
  RCU m >>= f = RCU $ \s -> do
    a <- m s
    unRCU (f a) s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fast-builder-0.0.0.6/benchmarks/vector.hs
Applicative instance: 

instance Applicative Box where
  pure = return
  (<*>) = ap
Monad instance: 

instance Monad Box where
  return = Box
  Box a >>= f = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fast-builder-0.0.0.6/Data/ByteString/FastBuilder/Internal.hs
Applicative instance: 


instance Applicative BuildM where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad BuildM where
  return x = BuildM $ \k -> k x
  {-# INLINE return #-}
  BuildM b >>= f = BuildM $ \k -> b $ \r -> runBuildM (f r) k
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-midi-0.6.0.3/src/Synthesizer/MIDI/Value/BendModulation.hs
Applicative instance: 


-- useful for defining 'peek' instance
instance Applicative T where
   {-# INLINE pure #-}
   pure a = Cons a a
   {-# INLINE (<*>) #-}
   (Cons fb fm) <*> (Cons b m) =
      Cons (fb b) (fm m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-midi-0.6.0.3/src/Synthesizer/MIDI/Dimensional.hs
Applicative instance: 


instance Applicative (Filter event s u t) where
   pure x = Filter (pure (pure x))
   Filter f <*> Filter x =
      Filter (liftA2 (<*>) f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactivity-0.3.2.4/src/FRP/Reactivity/Measurement.hs
Monad instance: 


instance Monad Measurement where
        return x = Measurement (return ()) (return (Just (x, 0)))
        meas >>= f = Measurement
                (getValue meas >>= wait . f . fst)
                (stmAction meas >>= maybe
                        (return Nothing)
                        (\(x, t) -> liftM (fmap (\(y, t') -> (y, max t t'))) (stmAction (f x))))
        fail _ = mzero
Applicative instance: 


instance Applicative Measurement where
        pure = return
        (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactivity-0.3.2.4/src/FRP/Reactivity/MeasurementWrapper.hs
Monad instance: 


instance Monad MeasurementWrapper where
        return x = MeasurementWrapper [return x]
        MeasurementWrapper (x:xs) >>= f = f (copoint x) `mplus` (MeasurementWrapper xs >>= f)
        MeasurementWrapper [] >>= _ = mzero
        fail _ = mzero
Applicative instance: 


instance Applicative MeasurementWrapper where
        pure = return
        (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactivity-0.3.2.4/src/FRP/Reactivity/Combinators.hs
Applicative instance: 


instance (EventStream e) => Applicative (Behavior e) where
        pure x = Switcher (const x) mzero
        Switcher f e <*> Switcher f2 e2 = Switcher (f <*> f2)
                $ fmap (uncurry (<*>))
                $ zipE e f e2 f2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactivity-0.3.2.4/src/FRP/Reactivity/RPC.hs
Monad instance: 


instance Monad RPC where
        return = RPC . return
        m >>= f = RPC $ unRPC m >>= unRPC . f
        fail = RPC . fail
Applicative instance: 


instance Applicative RPC where
        pure = return
        (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactivity-0.3.2.4/src/FRP/Reactivity/AlternateEvent.hs
Monad instance: 


instance Monad Event where
        return x = Event (\f -> f x 0 >> return (return ()))
        Event f >>= g = Event (\h -> do
                -- Lots of machinery to track all subscriptions...
                ref <- _nonDispatchedIO (newIORef (return ()))
                liftM (\m -> m >> join (_nonDispatchedIO (readIORef ref))) (f (get2 ref h))) where
                get h t x' t' = h x' (max t t')
                get2 ref h x t = unEvent (g x) (get h t) >>= \m -> _nonDispatchedIO (atomicModifyIORef ref (\m2 -> (m2 >> m, ())))
        fail _ = mzero
Applicative instance: 


instance Applicative Event where
        pure = return
        (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chuchu-0.4.5/src/Test/Chuchu/Types.hs
Monad instance: 


instance Monad (ChuchuM m) where
  return _ = Nil
  step >>= k = Cons step $ k $ error "(>>=): ChuchuM does not support 'return'."
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sync-mht-0.3.8.5/src/Sync/MerkleTree/Util/RequestMonad.hs
Applicative instance: 


instance Applicative (RequestMonadT ByteString) where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad (RequestMonadT ByteString) where
    return = Return
    fail = Fail
    (>>=) = bindImpl
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/StrategyLib-4.0.0.0/library/Control/Monad/Maybe.hs
Monad instance: 


instance (Monad m) => Monad (MaybeT m) where
        return a = MaybeT $ return (Just  a)
        m >>= k  = MaybeT $ do
                a <- runMaybeT m
                case a of
                        Nothing -> return (Nothing)
                        Just  r -> runMaybeT (k r)
        fail msg = MaybeT $ return (Nothing)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haste-gapi-0.1.0.1/Haste/GAPI/Request/RequestM.hs
Monad instance: 


-- | RequestM is a monad
instance Monad RequestM where
  fail err = Req . return . Left $ J.pack err
  return a = Req . return $ Right a
  (Req a) >>= f = Req $ do
    a' <- a
    case a' of
      Right good -> unR $ f good
      Left  bad  -> do
        return $ Left bad
Applicative instance: 


-- | Applicative is defined so that it builds under GHC 7.8 
instance Applicative RequestM where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cmdtheline-0.2.3/src/System/Console/CmdTheLine/Common.hs
Applicative instance: 


instance Applicative Term where
  pure v = Term [] (\ _ _ -> return v)

  (Term args f) <*> (Term args' v) = Term (args ++ args') wrapped
    where
    wrapped ei cl = f ei cl <*> v ei cl
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/acme-hq9plus-0.1/Acme/HQ9Plus.hs
Applicative instance: 


instance Applicative HQ where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad HQ where
    m >>= k  = Bind m k
    return a = Return a
Monad instance: 


instance Monad HQM where
    return x = HQM $ \_ acc -> (x, acc, id, id)
    m >>= k = HQM $ \src acc0 ->
        let (x1, acc1, insts1, out1) = runHQM m      src acc0
            (x2, acc2, insts2, out2) = runHQM (k x1) src acc1
         in (x2, acc2, insts1 . insts2, out1 . out2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/simgi-0.3/src/TokenParser.hs
Applicative instance: 



{- Definitions for Applicative Parsec instance -}

-- | Applicative instance for Monad
instance Applicative (GenParser s a) where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/iteratee-mtl-0.5.0.0/src/Data/Iteratee/Base.hs
Applicative instance: 


instance (Functor m, Monad m, Nullable s) => Applicative (Iteratee s m) where
    pure x  = idone x (Chunk empty)
    m <*> a = m >>= flip fmap a
Monad instance: 


instance (Monad m, Nullable s) => Monad (Iteratee s m) where
  {-# INLINE return #-}
  return x = Iteratee $ \onDone _ -> onDone x (Chunk empty)
  {-# INLINE (>>=) #-}
  m >>= f = Iteratee $ \onDone onCont ->
     let m_done a (Chunk s)
           | null s      = runIter (f a) onDone onCont
         m_done a stream = runIter (f a) (const . flip onDone stream) f_cont
           where f_cont k Nothing = runIter (k stream) onDone onCont
                 f_cont k e       = onCont k e
     in runIter m m_done (onCont . ((>>= f) .))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/blaze-markup-0.7.1.0/src/Text/Blaze/Internal.hs
Applicative instance: 


instance Applicative MarkupM where
    pure _ = Empty
    {-# INLINE pure #-}
    (<*>) = Append
    {-# INLINE (<*>) #-}
    (*>) = Append
    {-# INLINE (*>) #-}
    (<*) = Append
    {-# INLINE (<*) #-}
Monad instance: 


instance Monad MarkupM where
    return _ = Empty
    {-# INLINE return #-}
    (>>) = Append
    {-# INLINE (>>) #-}
    h1 >>= f = h1 >> f
        (error "Text.Blaze.Internal.MarkupM: invalid use of monadic bind")
    {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/c2hs-0.28.1/src/Control/StateTrans.hs
Applicative instance: 


instance Applicative (STB bs gs) where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad (STB bs gs) where
  return = yield
  (>>=)  = (+>=)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/c2hs-0.28.1/src/Control/StateBase.hs
Applicative instance: 


instance Applicative (PreCST e s) where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad (PreCST e s) where
  return = yield
  (>>=)  = (+>=)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monadiccp-0.7.6/Control/CP/SearchTree.hs
Monad instance: 


instance Solver s => Monad (Tree s) where
  return = Return
  (>>=)  = bindTree
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monadiccp-0.7.6/Control/Monatron/AutoInstances.hs
Monad instance: 


------------------------------------------------------------------
instance (Monad m, MonadT t) => Monad (t m) where
    return = treturn
    fail   = lift . fail
    (>>=)  = tbind
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monadiccp-0.7.6/Control/Monatron/Monad.hs
Monad instance: 


instance Monad Id where
    return  = Id
    fail    = error
    m >>= f = f (runId m)
Monad instance: 


instance Monad Lift where
  return x  = L x
  fail x    = error x
  L x >>= k = k x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/errors-2.1.2/Data/EitherR.hs
Applicative instance: 


instance Applicative (EitherR r) where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad (EitherR r) where
    return e = EitherR (Left e)
    EitherR m >>= f = case m of
        Left  e -> f e
        Right r -> EitherR (Right r)
Applicative instance: 


instance (Monad m) => Applicative (ExceptRT r m) where
    pure  = return
    (<*>) = ap
Monad instance: 


instance (Monad m) => Monad (ExceptRT r m) where
    return e = ExceptRT (throwE e)
    m >>= f = ExceptRT $ ExceptT $ do
        x <- runExceptT $ runExceptRT m
        runExceptT $ runExceptRT $ case x of
            Left  e -> f e
            Right r -> ExceptRT (return r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/simple-conduit-0.5.1/Conduit/Simple/Core.hs
Applicative instance: 


instance Applicative (Source m) where
    pure  = return
    f <*> x = source $ \z yield ->
        runSource f z (\r f' -> runSource x r (\s x' -> yield s (f' x')))
Monad instance: 


instance Monad (Source m) where
    return x = Source $ return x
    Source m >>= f = Source $ join (liftM (getSource . f) m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/MicrosoftTranslator-0.1.0.1/src/Language/Bing.hs
Monad instance: 


instance (Monad m, MonadIO m) => Monad (BingMonad m) where
  m >>= f = BM (\ctx' -> do
                   ctx <- checkToken ctx'
                   res <- runBing m ctx
                   runBing (f res) ctx)

  return a = BM $ \ctx -> return a
Applicative instance: 


instance (Monad m, MonadIO m) => Applicative (BingMonad m) where
  pure a = return a
  a <*> b = do
    a' <- a
    b' <- b
    return (a' b')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wai-routes-0.9.8/src/Util/Free.hs
Applicative instance: 

instance Functor f => Applicative (F f) where
  pure a = F (\kp _ -> kp a)
  F f <*> F g = F (\kp kf -> f (\a -> g (kp . a) kf) kf)
Monad instance: 

instance Functor f => Monad (F f) where
  return a = F (\kp _ -> kp a)
  F m >>= f = F (\kp kf -> m (\a -> runF (f a) kp kf) kf)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pappy-0.1.0.2/src/Parse.hs
Monad instance: 
           -- unconditional error labeling

-- Standard monadic combinators
instance Derivs d => Monad (Parser d) where

        -- Sequencing combinator
        (Parser p1) >>= f = Parser parse

                where parse dvs = first (p1 dvs)

                      first (Parsed val rem err) =
                        let Parser p2 = f val
                        in second err (p2 rem)
                      first (NoParse err) = NoParse err

                      second err1 (Parsed val rem err) =
                        Parsed val rem (joinErrors err1 err)
                      second err1 (NoParse err) =
                        NoParse (joinErrors err1 err)

        -- Result-producing combinator
        return x = Parser (\dvs -> Parsed x dvs (nullError dvs))

        -- Failure combinator
        fail [] = Parser (\dvs -> NoParse (nullError dvs))
        fail msg = Parser (\dvs -> NoParse (msgError (dvPos dvs) msg))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hplayground-0.1.3.1/src/Haste/HPlay/View.hs
Applicative instance: 


instance (Monoid view,Functor m, Monad m,Monad (View view m)) => Applicative (View view m) where
  pure a  = View  .  return . FormElm mempty $ Just a
  View f <*> View g= View $
                   f >>= \(FormElm form1 k) ->
                   g >>= \(FormElm form2 x) ->
                   return $ FormElm (form1 `mappend` form2) (k <*> x)
Monad instance: 


instance Monad (View Perch IO) where
    x >>= f = View $ do
       fix <- gets fixed
       id1 <- genNewId
       contold <- setEventCont x  f  id1
       FormElm form1 mk <- runView x
       resetEventCont contold
       case mk of
         Just k  -> do
            FormElm form2 mk <- runView $ f k
            return $ FormElm (form1 <> maybeSpan fix id1 form2) mk
         Nothing ->
            return $ FormElm  (form1 <> maybeSpan fix id1 noHtml)  Nothing
       where
       maybeSpan True id1 form= form
       maybeSpan False id1 form= span ! id id1 $ form



    return = View .  return . FormElm  mempty . Just
    fail msg= View . return $ FormElm (inred $ fromStr msg) Nothing
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bound-1.0.7/examples/Overkill.hs
Applicative instance: 


instance Applicative Exp where
  pure = Var
  (<*>) = ap
Monad instance: 


instance Monad Exp where
  return         = Var
  Var a    >>= f = f a
  (x :@ y) >>= f = (x >>= f) :@ (y >>= f)
  Lam p e  >>= f = Lam (p >>>= f) (e >>>= f)
  Let bs e >>= f = Let (fmap (>>>= f) bs) (e >>>= f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bound-1.0.7/examples/Simple.hs
Applicative instance: 


instance Applicative Exp where
  pure  = V
  (<*>) = ap
Monad instance: 


instance Monad Exp where
  return = V
  V a      >>= f = f a
  (x :@ y) >>= f = (x >>= f) :@ (y >>= f)
  Lam e    >>= f = Lam (e >>>= f)
  Let bs b >>= f = Let (map (>>>= f) bs) (b >>>= f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bound-1.0.7/examples/Deriving.hs
Applicative instance: 


instance Applicative Exp where
  pure = V
  (<*>) = ap
Monad instance: 


instance Monad Exp where
  return = V
  V a        >>= f = f a
  (x :@ y)   >>= f = (x >>= f) :@ (y >>= f)
  Lam n p e  >>= f = Lam n (p >>>= f) (e >>>= f)
  Let n bs e >>= f = Let n (map (>>>= f) bs) (e >>>= f)
  Case e as  >>= f = Case (e >>= f) (map (>>>= f) as)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bound-1.0.7/src/Bound/Var.hs
Applicative instance: 


instance Applicative (Var b) where
  pure = F
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad (Var b) where
  return = pure
  {-# INLINE return #-}
  F a >>= f = f a
  B b >>= _ = B b
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bound-1.0.7/src/Bound/Scope.hs
Applicative instance: 


instance (Functor f, Monad f) => Applicative (Scope b f) where
  pure a = Scope (return (F (return a)))
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}
Monad instance: 


-- | The monad permits substitution on free variables, while preserving
-- bound variables
instance Monad f => Monad (Scope b f) where
#if __GLASGOW_HASKELL__ < 710
  return a = Scope (return (F (return a)))
  {-# INLINE return #-}
#endif
  Scope e >>= f = Scope $ e >>= \v -> case v of
    B b -> return (B b)
    F ea -> ea >>= unscope . f
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bound-1.0.7/src/Bound/Scope/Simple.hs
Applicative instance: 


instance (Functor f, Monad f) => Applicative (Scope b f) where
  pure a = Scope (return (F a))
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}
Monad instance: 


-- | The monad permits substitution on free variables, while preserving
-- bound variables
instance Monad f => Monad (Scope b f) where
#if __GLASGOW_HASKELL__ < 710
  return a = Scope (return (F a))
  {-# INLINE return #-}
#endif
  Scope e >>= f = Scope $ e >>= \v -> case v of
    B b -> return (B b)
    F a -> unscope (f a)
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/doc-review-0.7.1/src/Config/GetOpt.hs
Monad instance: 

instance Monad Err where
    return        = Val
    fail          = Err . return
    (Err s) >>= _ = Err s
    (Val x) >>= f = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wires-0.1.0/Control/Wire/Internal.hs
Applicative instance: 


instance (Applicative m) => Applicative (Wire m a) where
    pure x = let w = Wire (\_ -> pure (x, w)) in w

    wf' <*> wx' =
        Wire $ \x' ->
            (\(f, wf) (x, wx) -> (f x, wf <*> wx))
            <$> stepWire wf' x'
            <*> stepWire wx' x'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ftree-0.1.3/src/Data/FTree/BottomUp.hs
Applicative instance: 


instance (IsNat n, Applicative f) => Applicative (f :^ n) where
  pure = pureN nat
  (<*>) = inT2 ($) (liftA2 (<*>))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ftree-0.1.3/src/Data/FTree/TopDown.hs
Applicative instance: 


instance (IsNat n, Applicative f) => Applicative (f :^ n) where
  pure = pureN nat
  (<*>) = inT2 ($) (liftA2 (<*>))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dom-lt-0.1.3/Data/Graph/Dom.hs
Monad instance: 

instance Monad (S z s) where
  return a = S (\k -> k a)
  S g >>= f = S (\k -> g (\a -> unS (f a) k))
Applicative instance: 

instance Applicative (S z s) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/TreeT-0.0/Control/TreeT.hs
Monad instance: 


instance Monad m => Monad (TreeT m) where
   return m =  TreeT $ return $ Node m []
   tmb_v >>= f = TreeT $ runTreeT tmb_v >>= onone f
          where onone f (Node b_ex b_ets) = do
                   Node ex ets <- runTreeT (f b_ex)
                   ets_ <- mapM (onone f) b_ets
                   return $ Node ex (ets_ ++ ets)
Applicative instance: 


instance Applicative m => Applicative (TreeT m)where
    pure = treeT0 . pure . pure
    (<*>) = treeT2 . liftA2 . liftA2 $ id
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/expiring-cache-map-0.0.6.1/Caching/ExpiringCacheMap/Utils/TestSequence.hs
Applicative instance: 


instance Applicative (TestSequence a) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad (TestSequence a) where
  TestSequence fun >>= k =
    TestSequence
      (\state -> let (state', ret) = (fun state)
                     TestSequence fun' = k ret
                  in fun' state')
  return ret =
    TestSequence $
      \(TestSequenceState (timer, hl, testsvar)) ->
       (TestSequenceState (timer+1,hl, testsvar), ret)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/keystore-0.8.0.0/src/Data/KeyStore/Sections.hs
Applicative instance: 


instance Applicative Munch where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad Munch where
  return x  = Munch $ \s -> Just (x,s)
  (>>=) m f = Munch $ \s -> _Munch m s >>= \(x,s') -> _Munch (f x) s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactive-thread-0.3.2.1/Reactive/Thread/Internal/Thread.hs
Monad instance: 


instance (Monad m) => Monad (Thread v o m) where
  return = Pure

  Pure x >>= f = f x
  Lift m >>= f = Lift (m >>= \ t -> return (t >>= f))
  Yield x m >>= f = Yield x (m >>= f)
  Fork thread var m >>= f = Fork thread var (m >>= f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/freesect-0.8/HSE/ParseMonad.hs
Applicative instance: 


instance Applicative ParseResult where
  pure = ParseOk
  ParseOk f           <*> x = f <$> x
  ParseFailed loc msg <*> _ = ParseFailed loc msg
Monad instance: 


instance Monad ParseResult where
  return = ParseOk
  ParseOk x           >>= f = f x
  ParseFailed loc msg >>= _ = ParseFailed loc msg
Monad instance: 


instance Monad P where
    return a = P $ \_i _x _y _l s _m -> Ok s a
    P m >>= k = P $ \i x y l s mode ->
        case m i x y l s mode of
            Failed loc msg -> Failed loc msg
            Ok s' a -> runP (k a) i x y l s' mode
    fail s = P $ \_r _col _line loc _stk _m -> Failed loc s
Monad instance: 


instance Monad (Lex r) where
    return a = Lex $ \k -> k a
    Lex v >>= f = Lex $ \k -> v (\a -> runL (f a) k)
    Lex v >> Lex w = Lex $ \k -> v (\_ -> w k)
    fail s = Lex $ \_ -> fail s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/freesect-0.8/HSE/Annotated/ExactPrint.hs
Monad instance: 


instance Monad EP where
  return x = EP $ \l cs -> (x, l, cs, id)

  EP m >>= k = EP $ \l0 c0 -> let
        (a, l1, c1, s1) = m l0 c0
        EP f = k a
        (b, l2, c2, s2) = f l1 c1
    in (b, l2, c2, s1 . s2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/freesect-0.8/HSE/Pretty.hs
Monad instance: 


instance Monad (DocM s) where
        (>>=) = thenDocM
        (>>) = then_DocM
        return = retDocM
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/crypto-classical-0.2.0/Crypto/Classical/Cipher/Affine.hs
Applicative instance: 


instance Applicative Affine where
  pure = Affine
  Affine f <*> Affine a = Affine $ f a
Monad instance: 


instance Monad Affine where
  return = pure
  Affine a >>= f = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/crypto-classical-0.2.0/Crypto/Classical/Cipher/Enigma.hs
Applicative instance: 


instance Applicative Enigma where
  pure = Enigma
  Enigma f <*> Enigma a = Enigma $ f a
Monad instance: 


instance Monad Enigma where
  return = pure
  Enigma a >>= f = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/crypto-classical-0.2.0/Crypto/Classical/Cipher/Stream.hs
Applicative instance: 


instance Applicative Stream where
  pure = Stream
  Stream f <*> Stream a = Stream $ f a
Monad instance: 


instance Monad Stream where
  return = pure
  Stream a >>= f = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/crypto-classical-0.2.0/Crypto/Classical/Cipher/Caesar.hs
Applicative instance: 


instance Applicative Caesar where
  pure = Caesar
  Caesar f <*> Caesar a = Caesar $ f a
Monad instance: 


instance Monad Caesar where
  return = pure
  Caesar a >>= f = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/crypto-classical-0.2.0/Crypto/Classical/Cipher/Vigenere.hs
Applicative instance: 


instance Applicative Vigenère where
  pure = Vigenère
  Vigenère f <*> Vigenère a = Vigenère $ f a
Monad instance: 


instance Monad Vigenère where
  return = pure
  Vigenère a >>= f = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/crypto-classical-0.2.0/Crypto/Classical/Cipher/Substitution.hs
Applicative instance: 


instance Applicative Substitution where
  pure = Substitution
  Substitution f <*> Substitution a = Substitution $ f a
Monad instance: 


instance Monad Substitution where
  return = pure
  Substitution a >>= f = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/remote-0.1.1/Remote/Task.hs
Monad instance: 


instance Monad TaskM where
   m >>= k = TaskM $ \ts -> do
                (ts',a) <- runTaskM m ts
                (ts'',a') <- runTaskM (k a) (ts')
                return (ts'',a')
   return x = TaskM $ \ts -> return $ (ts,x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/remote-0.1.1/Remote/Process.hs
Monad instance: 


instance Monad ProcessM where
    m >>= k = ProcessM $ (\p -> (runProcessM m) p >>= (\(news,newa) -> runProcessM (k newa) news))
    return x = ProcessM $ \s -> return (s,x)
Monad instance: 


instance Monad (MatchM q) where
    m >>= k = MatchM $ \mbi -> do
                (mb,a) <- runMatchM m mbi
                (mb',a2) <- runMatchM (k a) (fst mb)
                return (mb',a2)

    return x = MatchM $ \mb -> return $ ((mb,Nothing),x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/yoko-2.0/Examples/LambdaLift/LLBasics.hs
Applicative instance: 

instance Applicative M where pure = return; (<*>) = ap
Monad instance: 

instance Monad M where
  return a = M $ \_ -> (a, [])
  m >>= k = M $ \(tys, rn, sh) ->
    -- NB backwards state: a and w' are circular
    let (a, w)  = runM m     (tys, rn, sh + length w')
        (b, w') = runM (k a) (tys, rn, sh)
    in (b, w ++ w')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/MFlow-0.4.6.0/src/MFlow/Forms/Internals.hs
Applicative instance: 


instance Applicative FailBack where
  pure x = NoBack x
  _ <*> GoBack = GoBack
  GoBack <*> _ = GoBack
  k <*> x = NoBack $ (fromFailBack k)  (fromFailBack x)
Monad instance: 




instance (Supervise s m)=> Monad (Sup  m) where
    fail   _ = Sup . return $ GoBack
    return x = Sup . return $ NoBack x
    x >>= f  = Sup $ loop
     where
     loop = do
        s <- get
        v <- supervise $ runSup x                         -- !> "loop"
        case v of
            NoBack y -> supervise $ runSup (f y)          -- !> "runback"
            BackPoint y  -> do
                 z <- supervise $ runSup (f y)            -- !> "BACK"
                 case z of
                  GoBack  -> supBack s >> loop            -- !> "BACKTRACKING"
                  other   -> return other
            GoBack  ->  return  $ GoBack
Applicative instance: 


instance (Monad m,Applicative m) => Applicative (Sup m) where
   pure x = Sup . return $ NoBack x
   f <*> g= Sup $ do
       k <- runSup f
       x <- runSup g
       return $ k <*> x
Applicative instance: 



instance (Monoid view,Functor m, Monad m) => Applicative (View view m) where
  pure a  = View  .  return . FormElm mempty $ Just a
  View f <*> View g= View $
                   f >>= \(FormElm form1 k) ->
                   g >>= \(FormElm form2 x) ->
                   return $ FormElm (form1 `mappend` form2) (k <*> x)
Monad instance: 



instance  (FormInput view, Monad m) => Monad (View view m) where
    View x >>= f = View $ do
           FormElm form1 mk <- x
           case mk of
             Just k  -> do
                st'' <- get
                let st = st''{ linkMatched = False  }
                put st
                FormElm form2 mk <- runView $ f k
                st' <- get
                (mix, hasform) <- controlForms st st' form1 form2
                when hasform $ put st'{needForm= HasForm}

                return $ FormElm mix mk
             Nothing ->
                return $ FormElm form1 Nothing


    return = View .  return . FormElm  mempty . Just
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-resumption-0.1.2.0/Control/Monad/Resumption.hs
Monad instance: 


instance Monad m => Monad (ResT m) where
  return x = ResT $ return $ Left x
  ResT m >>= f =  ResT $ do
                          x <- m
                          case x of
                             Left  val -> return $ Right $ f val
                             Right res -> return $ Right $ res >>= f
Applicative instance: 


instance Monad m => Applicative (ResT m) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-resumption-0.1.2.0/Control/Monad/Resumption/Reactive.hs
Monad instance: 


instance Monad m => Monad (ReacT input output m) where
  return = ReacT . return . Left
  ReacT comp >>= f = ReacT $ do
                                inner <- comp
                                case inner of
                                    Left v                 -> deReacT (f v)
                                    Right (output, resume) -> return (Right (output,\ p -> resume p >>= f))
Applicative instance: 


instance Monad m => Applicative (ReacT input output m) where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HLearn-datastructures-1.1.0/src/HLearn/DataStructures/SortedVector.hs
Applicative instance: 


instance CK.Applicative SortedVector where
    (<*>) = undefined
Monad instance: 


instance CK.Monad SortedVector where
--     type MonadConstraint SortedVector a = Ord a
    return = SortedVector . V.singleton
    (>>=) = flip concatMapa
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ord-adhoc-0.0.0.1/Data/Ord/Bounded.hs
Applicative instance: 


instance Applicative (GBounded min max) where
    pure = ValueB
    ValueB f <*> ValueB x = ValueB (f x)
    MinimumB v <*> _ = MinimumB v
    MaximumB v <*> _ = MaximumB v
Monad instance: 


instance Monad (GBounded min max) where
    return = ValueB
    ValueB x >>= k = k x
    MinimumB v >>= _ = MinimumB v
    MaximumB v >>= _ = MaximumB v
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactive-banana-wx-1.1.1.0/src/Tidings.hs
Applicative instance: 


-- | The applicative instance combines 'rumors'
-- and uses 'facts' when some of the 'rumors' are not available.
instance Applicative Tidings where
    pure x  = T (pure x) never
    f <*> x = uncurry ($) <$> pair f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/eventstore-0.9.1.3/Database/EventStore/Internal/Operation.hs
Applicative instance: 


--------------------------------------------------------------------------------
instance Applicative (SM o) where
    pure = return
    (<*>) = ap
Monad instance: 


--------------------------------------------------------------------------------
instance Monad (SM o) where
    return = Return

    Return a          >>= f = f a
    Yield o n         >>= f = Yield o (n >>= f)
    FreshId k         >>= f = FreshId ((f =<<) . k)
    SendPkg ci co p k >>= f = SendPkg ci co p ((f =<<) . k)
    Failure e         >>= _ = Failure e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/toysolver-0.4.0/src/ToySolver/Data/BoolExpr.hs
Applicative instance: 


instance Applicative BoolExpr where
  pure = Atom
  (<*>) = ap
Monad instance: 


instance Monad BoolExpr where
  return = pure
  m >>= f = fold f m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bytestring-trie-0.2.4.1/src/Data/Trie/Internal.hs
Monad instance: 



#ifdef APPLICATIVE_IN_BASE
instance Foldable Trie where
    -- If our definition of foldr is so much faster than the Endo
    -- default, then maybe we should remove this and use the default
    -- foldMap based on foldr
    foldMap f = go
        where
        go Empty              = mempty
        go (Arc _ Nothing  t) = go t
        go (Arc _ (Just v) t) = f v `mappend` go t
        go (Branch _ _ l r)   = go l `mappend` go r

    {- This definition is much faster, but it's also wrong
    -- (or at least different than foldrWithKey)
    foldr f = \z t -> go t id z
        where
        go Empty              k x = k x
        go (Branch _ _ l r)   k x = go r (go l k) x
        go (Arc _ Nothing t)  k x = go t k x
        go (Arc _ (Just v) t) k x = go t k (f v x)
    
    foldl f = \z t -> go t id z
        where
        go Empty              k x = k x
        go (Branch _ _ l r)   k x = go l (go r k) x
        go (Arc _ Nothing t)  k x = go t k x
        go (Arc _ (Just v) t) k x = go t k (f x v)
    -}

-- TODO: newtype Keys = K Trie  ; instance Foldable Keys
-- TODO: newtype Assoc = A Trie ; instance Foldable Assoc

instance Traversable Trie where
    traverse f = go
        where
        go Empty              = pure Empty
        go (Arc k Nothing  t) = Arc k Nothing        <$> go t
        go (Arc k (Just v) t) = Arc k . Just <$> f v <*> go t
        go (Branch p m l r)   = Branch p m <$> go l <*> go r

instance Applicative Trie where
    pure  = return
    (<*>) = ap
#endif

-- Does this even make sense? It's not nondeterminism like lists
-- and sets. If no keys were prefixes of other keys it'd make sense
-- as a decision-tree; but since keys /can/ prefix, tries formed
-- from shorter keys can shadow the results from longer keys due
-- to the 'unionL'. It does seem to follow the laws though... What
-- computation could this possibly represent?
--
--  1. return x >>= f  == f x
--  2. m >>= return    == m
--  3. (m >>= f) >>= g == m >>= (\x -> f x >>= g)
instance Monad Trie where
    return = singleton S.empty

    (>>=) Empty              _ = empty
    (>>=) (Branch p m l r)   f = branch p m (l >>= f) (r >>= f)
    (>>=) (Arc k Nothing  t) f = arc k Nothing (t >>= f)
    (>>=) (Arc k (Just v) t) f = arc k Nothing (f v `unionL` (t >>= f))
                               where
                               unionL = mergeBy (\x _ -> Just x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hypher-0.1.5/src/Database/Neo4j/Types.hs
Monad instance: 


instance Monad Neo4j where
    return x = Neo4j (const (return x))
    (Neo4j cmd) >>= f = Neo4j $ \con -> do
                            a <- cmd con
                            runNeo4j (f a) con
Applicative instance: 


instance Applicative Neo4j where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dependent-sum-template-0.0.0.5/src/Data/GADT/Compare/TH.hs
Monad instance: 

instance Monad (GComparing a b) where
    return = GComparing . Right
    GComparing (Left  x) >>= f = GComparing (Left x)
    GComparing (Right x) >>= f = f x
Applicative instance: 

instance Applicative (GComparing a b) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HAppSHelpers-0.9/HAppS/Server/CookieFixer.hs
Applicative instance: 


instance Applicative (GenParser s a) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hommage-0.0.6/Sound/Hommage/Rand.hs
Monad instance: 


instance Monad R where
 return = R . const
 R g >>= f = R $ \s -> let (s1,s2) = split s in unR (f (g s1)) s2
Applicative instance: 



instance Applicative R where
 R gf <*> R ga = R $ \s -> let (s1,s2) = split s in gf s1 (ga s2)
 pure = R . const
Monad instance: 


instance Monad RM where
 return a = RM $ const $ note a
 RM g >>= f = RM $ \s -> let (s1,s2) = split s in g s1 >>= \a-> unRM (f a) s2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hommage-0.0.6/Sound/Hommage/Play.hs
Monad instance: 


--returnPlay :: a -> Play a
--returnPlay a = PLAY $ \dur env -> case env of
-- Environment (0, []) -> a
-- Environment _       -> a

instance Monad Play where
 return a = PLAY $ \dur env -> a --returnPlay a
 PLAY g >>= f = PLAY $ \dur env -> unPlay (f $ g dur env) dur env
Monad instance: 


instance Monad Song where
 return a = SONG $ \_ e -> (a,e)
 SONG g >>= f = SONG $ \d e -> let (a,e') = g d e in unSong (f a) d e'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/yhccore-0.9.1/Yhc/Core/FreeVar2.hs
Monad instance: 


instance Monad FreeVar where
    return a = FreeVar (return a)
    (FreeVar x) >>= f = FreeVar (x >>= fromFreeVar . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rivers-0.1.0/Data/Rivers/Streams.hs
Monad instance: 


instance Monad S where
  return = srepeat
  xs >>= f = join (fmap f xs)
    where
      join ~(Cons zs xss) = Cons (shead zs) (join (smap stail xss))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ethereum-client-haskell-0.0.4/src/Blockchain/JCommand.hs
Applicative instance: 


instance Applicative Unique where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad Unique where
    (Unique runner) >>= f = Unique $ \val -> let (val', x') = runner val
                                                 Unique g = f x'
                                             in g val'
    return x = Unique $ \val -> (val, x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-coroutine-0.9.0.3/Control/Monad/Coroutine.hs
Applicative instance: 


instance (Functor s, Functor m, Monad m) => Applicative (Coroutine s m) where
   pure = return
   (<*>) = ap
Monad instance: 


instance (Functor s, Monad m) => Monad (Coroutine s m) where
   return x = Coroutine (return (Right x))
   t >>= f = Coroutine (resume t >>= apply f)
      where apply fc (Right x) = resume (fc x)
            apply fc (Left s) = return (Left (fmap (>>= fc) s))
   t >> f = Coroutine (resume t >>= apply f)
      where apply fc (Right _) = resume fc
            apply fc (Left s) = return (Left (fmap (>> fc) s))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mvc-updates-1.2.0/src/MVC/Updates.hs
Applicative instance: 


instance Applicative Updatable where
    pure a = Updatable (pure (pure (pure a)))

    Updatable mL <*> Updatable mR = Updatable (liftA2 f mL mR)
      where
        f (controllerL, foldL) (controllerR, foldR) = (controllerT, foldT)
          where
            foldT = L.pretraverseM _Left foldL <*> L.pretraverseM _Right foldR

            controllerT = fmap Left controllerL <> fmap Right controllerR
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/base-orphans-0.5.4/test/Control/Applicative/OrphansSpec.hs
Applicative instance: 


instance Applicative Identity where
  pure     = Identity
  Identity f <*> x = f <$> x
Monad instance: 


instance Monad Identity where
  return = Identity
  m >>= k  = k (runIdentity m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hsc2hs-0.68/CrossCodegen.hs
Applicative instance: 


instance Applicative TestMonad where
    pure a = TestMonad (\_ c -> pure (Right a, c))
    (<*>) = ap
Monad instance: 


instance Monad TestMonad where
    return = AP.pure
    x >>= fn = TestMonad (\e c -> (runTest x e c) >>=
                                      (\(a,c') -> either (\err -> return (Left err, c'))
                                                         (\result -> runTest (fn result) e c')
                                                         a))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hsc2hs-0.68/HSCParser.hs
Applicative instance: 


instance Applicative Parser where
    pure a = Parser $ \pos s -> Success pos [] s a
    (<*>) = ap
Monad instance: 


instance Monad Parser where
    return = pure
    Parser m >>= k =
        Parser $ \pos s -> case m pos s of
            Success pos' out1 s' a -> case k a of
                Parser k' -> case k' pos' s' of
                    Success pos'' out2 imp'' b ->
                        Success pos'' (out1++out2) imp'' b
                    Failure pos'' msg -> Failure pos'' msg
            Failure pos' msg -> Failure pos' msg
    fail msg = Parser $ \pos _ -> Failure pos msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fit-0.5.2/src/Fit/Internal/Architecture.hs
Applicative instance: 


instance Applicative (WithArch a) where
  pure = WithArch
  (WithArch f) <*> (WithArch x) = WithArch (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/control-monad-exception-0.9.1/Control/Monad/Exception/Base.hs
Monad instance: 


instance Monad m => Monad (EMT l m) where
  return = EMT . return . Right

  fail s = EMT $ return $ Left ([], CheckedException $ toException $ FailException s)

  emt >>= f = EMT $ do
                v <- unEMT emt
                case v of
                  Left e  -> return (Left e)
                  Right x -> unEMT (f x)
Applicative instance: 


instance Monad m => Applicative (EMT l m) where
  pure  = return
  (<*>) = ap
Monad instance: 

instance Monad Identity where
  return = Identity
  Identity a >>= f = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/noise-0.0.1/src/Text/Noise/Compiler/Function.hs
Applicative instance: 


instance Applicative Function where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Function where
  return x = Function $ \args -> Success x args
  Function r >>= f = Function $ \args ->
    case r args of
      Failure err -> Failure err
      Success x args' ->
        let Function r' = f x
        in  r' args'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/URLT-0.14/URLT/Base.hs
Applicative instance: 


-- NOTE: the Monad m requirement comes from the Functor ReaderT instance
instance (Applicative m, Monad m) => Applicative (URLT url m) where
    pure = return
    (URLT (ReaderT f)) <*> (URLT (ReaderT a))
        = URLT $ ReaderT $ \env -> (f env) <*> (a env)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/scotty-view-1.0.0/HtmlPageBuilder.hs
Applicative instance: 



------------------------------------------------------------------------------
--                            Library functions                             --
------------------------------------------------------------------------------

instance Applicative (HtmlPageBuilder m)
Monad instance: 


instance Monad m => Monad (HtmlPageBuilder m) where
  -- | Returns a new HtmlPageBuilder from a given result.
  return result = HtmlPageBuilder $ \state -> return (result, state)

  -- | Returns a new HtmlPageBuilder from a given HtmlPageBuilder and
  -- function.
  HtmlPageBuilder builder >>= function = HtmlPageBuilder $ \state1 -> do
    (result, state2) <- builder state1
    let HtmlPageBuilder builder2 = function result in builder2 state2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tremulous-query-1.0.7/Network/Tremulous/StrictMaybe.hs
Monad instance: 


instance Monad Maybe where
    Nothing >>= _   = Nothing
    Just a  >>= f   = f a
    return          = Just
    fail _          = Nothing
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sodium-0.9.0.0/src/FRP/Sodium/Plain.hs
Applicative instance: 


instance Applicative (R.Reactive Plain) where
    pure a = Reactive $ return a
    rf <*> rm = Reactive $ unReactive rf <*> unReactive rm
Monad instance: 


instance Monad (R.Reactive Plain) where
    return a = Reactive $ return a
    rma >>= kmb = Reactive $ do
        a <- unReactive rma
        unReactive (kmb a)
Applicative instance: 


instance Applicative (R.Behavior Plain) where
    pure = constant
    b1@(Behavior e1 s1) <*> b2@(Behavior e2 s2) = Behavior u s
      where
        cacheRef = unsafeNewIORef Nothing s2
        u = Event gl cacheRef (dep (e1,e2))
        s1' = unSample s1
        s2' = unSample s2
        gl = do
            fRef <- ioReactive $ newIORef =<< unSample s1
            aRef <- ioReactive $ newIORef =<< unSample s2
            (l, push, nodeRef) <- ioReactive newEventImpl
            unlistener <- later $ do
                un1 <- linkedListen e1 (Just nodeRef) False $ \f -> do
                    ioReactive $ writeIORef fRef f
                    a <- ioReactive $ readIORef aRef
                    push (f a)
                un2 <- linkedListen e2 (Just nodeRef) False $ \a -> do
                    f <- ioReactive $ readIORef fRef
                    ioReactive $ writeIORef aRef a
                    push (f a)
                return (un1 >> un2)
            addCleanup_Listen unlistener l
        s = s1' `seq` s2' `seq` Sample (($) <$> s1' <*> s2') (dep (s1, s2))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kan-extensions-5.0.1/src/Control/Comonad/Density.hs
Applicative instance: 


instance Applicative f => Applicative (Density f) where
  pure a = Density (const a) (pure ())
  {-# INLINE pure #-}
  Density kxf x <*> Density kya y =
    Density (\k -> kxf (fmap fst k) (kya (fmap snd k))) (liftA2 (,) x y)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kan-extensions-5.0.1/src/Control/Monad/Codensity.hs
Applicative instance: 


instance Applicative (Codensity f) where
  pure x = Codensity (\k -> k x)
  {-# INLINE pure #-}
  Codensity f <*> Codensity g = Codensity (\bfr -> f (\ab -> g (bfr . ab)))
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad (Codensity f) where
  return = pure
  {-# INLINE return #-}
  m >>= k = Codensity (\c -> runCodensity m (\a -> runCodensity (k a) c))
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kan-extensions-5.0.1/src/Control/Monad/Co.hs
Applicative instance: 


instance Comonad w => Applicative (CoT w m) where
  pure a = CoT (`extract` a)
  mf <*> ma = mf >>= \f -> fmap f ma
Monad instance: 


instance Comonad w => Monad (CoT w m) where
  return = pure
  CoT k >>= f = CoT (k . extend (\wa a -> runCoT (f a) wa))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kan-extensions-5.0.1/src/Data/Functor/Kan/Lan.hs
Applicative instance: 


instance (Functor g, Applicative h) => Applicative (Lan g h) where
  pure a = Lan (const a) (pure ())
  {-# INLINE pure #-}
  Lan kxf x <*> Lan kya y =
    Lan (\k -> kxf (fmap fst k) (kya (fmap snd k))) (liftA2 (,) x y)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kan-extensions-5.0.1/src/Data/Functor/Coyoneda.hs
Applicative instance: 


instance Applicative f => Applicative (Coyoneda f) where
  pure = liftCoyoneda . pure
  {-# INLINE pure #-}
  m <*> n = liftCoyoneda $ lowerCoyoneda m <*> lowerCoyoneda n
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad m => Monad (Coyoneda m) where
#if __GLASGOW_HASKELL__ < 710
  return = Coyoneda id . return
  {-# INLINE return #-}
#endif
  Coyoneda f v >>= k = lift (v >>= lowerM . k . f)
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kan-extensions-5.0.1/src/Data/Functor/Day.hs
Applicative instance: 


instance (Applicative f, Applicative g) => Applicative (Day f g) where
  pure x = Day (pure ()) (pure ()) (\_ _ -> x)
  (Day fa fb u) <*> (Day gc gd v) =
    Day ((,) <$> fa <*> gc) ((,) <$> fb <*> gd)
        (\(a,c) (b,d) -> u a b (v c d))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kan-extensions-5.0.1/src/Data/Functor/Yoneda.hs
Applicative instance: 


instance Applicative f => Applicative (Yoneda f) where
  pure a = Yoneda (\f -> pure (f a))
  Yoneda m <*> Yoneda n = Yoneda (\f -> m (f .) <*> n id)
Monad instance: 


instance Monad m => Monad (Yoneda m) where
#if __GLASGOW_HASKELL__ < 710
  return a = Yoneda (\f -> return (f a))
#endif
  Yoneda m >>= k = Yoneda (\f -> m id >>= \a -> runYoneda (k a) f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kan-extensions-5.0.1/src/Data/Functor/Day/Curried.hs
Applicative instance: 


instance (Functor g, g ~ h) => Applicative (Curried g h) where
  pure a = Curried (fmap ($a))
  {-# INLINE pure #-}
  Curried mf <*> Curried ma = Curried (ma . mf . fmap (.))
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskore-supercollider-0.3/src/Haskore/Interface/SuperCollider/Schedule/Channel.hs
Applicative instance: 


instance Applicative Environment where
   (<*>) = ap
   pure = return
Monad instance: 


instance Monad Environment where
   x >>= y  = Environment $ unwrapEnvironment . y =<< unwrapEnvironment x
   return   = Environment . return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskore-supercollider-0.3/src/Haskore/Interface/SuperCollider/Schedule/Install.hs
Applicative instance: 


instance Applicative Environment where
   (<*>) = ap
   pure = return
Monad instance: 


instance Monad Environment where
   x >>= y  = Environment $ unwrapEnvironment . y =<< unwrapEnvironment x
   return   = Environment . return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/nettle-openflow-0.2.0/src/Nettle/OpenFlow/StrictPut.hs
Monad instance: 


instance Monad PutM where
  return x = PutM (\ptr -> return (x, ptr))
  {-# INLINE return #-}
  (PutM m) >>= f = PutM (\(!ptr) -> do { (a, ptr') <- m ptr ; let (PutM g) = f a in g ptr' } )
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/blas-hs-0.1.1.0/tests/TestUtils.hs
Applicative instance: 


instance Applicative Test where
  pure      = return
  mf <*> mx = do
    f <- mf
    x <- mx
    return (f x)
Monad instance: 


instance Monad Test where
  return x     = Test $ \ s -> return (x, s)
  Test f >>= u = Test $ \ s -> do
    (x, s') <- f s
    runTestM (u x) s'
  fail msg     = do
    failTest "aborted"
    liftIO (fail msg)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fingertree-0.1.1.0/tests/ft-properties.hs
Monad instance: 


instance Monad M where
    return x = M $ \ n -> (n, x)
    M u >>= f = M $ \ m -> let (n, x) = u m in runM (f x) n
Applicative instance: 


instance Applicative M where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tagged-exception-core-2.2.0.0/src/Control/Monad/TaggedException/Internal/Throws.hs
Applicative instance: 


instance Applicative f => Applicative (Throws e f) where
    pure = Throws . pure
    Throws x <*> Throws y = Throws (x <*> y)
    Throws x *> Throws y = Throws (x *> y)
    Throws x <* Throws y = Throws (x <* y)
Monad instance: 


instance Monad m => Monad (Throws e m) where
    return = Throws . return
    Throws ma >>= f = Throws (ma >>= hideException . f)
    Throws ma >> Throws na = Throws (ma >> na)
    fail = Throws . fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/asn1-parse-0.9.4/Data/ASN1/Parse.hs
Applicative instance: 

instance Applicative ParseASN1 where
    pure a = P $ \s -> Right (a, s)
    (<*>) mf ma = P $ \s ->
        case runP mf s of
            Left err      -> Left err
            Right (f, s2) ->
                case runP ma s2 of
                    Left err      -> Left err
                    Right (a, s3) -> Right (f a, s3)
Monad instance: 

instance Monad ParseASN1 where
    return a    = pure a
    (>>=) m1 m2 = P $ \s ->
        case runP m1 s of
            Left err      -> Left err
            Right (a, s2) -> runP (m2 a) s2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/neural-0.3.0.0/src/Numeric/Neural/Model.hs
Applicative instance: 


instance Applicative (ParamFun s t a) where pure = pureArr; (<*>) = apArr
Applicative instance: 


instance Applicative Empty where

    pure = const Empty

    Empty <*> Empty = Empty
Applicative instance: 


instance (Applicative s, Applicative t) => Applicative (Pair s t) where

    pure x = Pair (pure x) (pure x)

    Pair f g <*> Pair x y = Pair (f <*> x) (g <*> y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/neural-0.3.0.0/src/Data/Utils/Matrix.hs
Applicative instance: 


instance (KnownNat m, KnownNat n) => Applicative (Matrix m n) where

    pure x = Matrix $ pure (pure x)

    Matrix fs <*> Matrix xs = Matrix $ (<*>) <$> fs <*> xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/neural-0.3.0.0/src/Data/Utils/Vector.hs
Applicative instance: 


instance forall n. KnownNat n => Applicative (Vector n) where

    pure x = let n = natVal (Proxy :: Proxy n) in Vector (V.replicate (fromIntegral n) x)

    Vector fs <*> Vector xs = Vector (V.zipWith ($) fs xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/microspec-0.1.0.0/Test/Microspec.hs
Applicative instance: 

instance Applicative Microspec where
   pure a = Microspec [] a
   f <*> a =
      let Microspec forest0 f' = f
          Microspec forest1 a' = a
      in Microspec (forest0 ++ forest1) (f' a')
Monad instance: 

instance Monad Microspec where
   return = pure
   ma >>= f =
      let Microspec forest0 a = ma
          Microspec forest1 b = f a
      in Microspec (forest0 ++ forest1) b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mutable-iter-0.6.1/src/Data/MutableIter.hs
Monad instance: 


instance (MonadIO m, Storable el) => Monad (MIteratee (IOBuffer r el) m) where
  {-# INLINE return #-}
  return x = MIteratee (I.Iteratee $ \onDone _ -> onDone x (I.Chunk empty))
  -- {-# INLINE (>>=) #-} -- this inline makes things a bit slower with 6.12.  Seems fixed in ghc-7
  m >>= f = MIteratee (I.Iteratee $ \onDone onCont ->
    let mDone a str = do
          isNull <- isNullChunk str
          if isNull
            then I.runIter (unwrap $ f a) onDone onCont
            else I.runIter (unwrap $ f a) (const . flip onDone str) (fCont str)
        fCont str k Nothing = I.runIter (k str) onDone onCont
        fCont _   k e       = onCont k e
    in I.runIter (unwrap m) mDone (\k -> onCont (unwrap . (>>= f) . MIteratee . k)))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/named-formlet-0.2/src/Text/Formlet.hs
Applicative instance: 


instance Applicative Formlet where
  pure a = Formlet { formletValue = const (return a)
                   , formletHtml  = const mempty
                   , formletName  = Nothing
                   }
  Formlet f n fhtml <*> Formlet v n' vhtml =
    Formlet { formletValue = \params ->
                case v params of
                  Right x -> f params <*> Right x
                  Left e  -> case f params <*> Left [] of
                               Right x -> return x
                               Left e' -> Left $ e' ++ e
            , formletHtml  = \params -> fhtml params ++ vhtml params
            , formletName  = case (n,n') of
                               (Just{},Just{}) -> Nothing
                               _               -> n `mplus` n'
            }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/text-lips-0.1/src/Text/Lips.hs
Applicative instance: 


instance Applicative Parser where
  pure a = Parser $ \c _ _ _ → c a
  {-# INLINE pure #-}
  Parser p₁ <*> Parser p₂ = Parser $ \c cc h ch →
    p₁ (\f → p₂ (c . f) (cc . f) h ch) (\f → p₂ (cc . f) (cc . f) ch ch) h ch
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Parser where
  return = pure
  {-# INLINE return #-}
  Parser p >>= f = Parser $ \c cc h ch →
    p (\a → runParser (f a) c cc h ch) (\a → runParser (f a) cc cc ch ch) h ch
  {-# INLINE (>>=) #-}
  fail msg = Parser $ \_ _ h _ ctx pl nl →
               h (Error nl ctx msg) ctx pl nl
  {-# INLINE fail #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/verdict-0.0.0.0/src/Verdict/Failure.hs
Applicative instance: 


instance Monoid e => Applicative (Failure e) where
    pure                            = Success
    Failure msgs  <*> Failure msgs' = Failure (msgs <> msgs')
    Success _     <*> Failure msgs' = Failure msgs'
    Failure msgs' <*> Success _     = Failure msgs'
    Success f     <*> Success x     = Success (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/verdict-0.0.0.0/src/Verdict/Val.hs
Applicative instance: 


instance Applicative (Validated ()) where
    pure  = Validated
    (<*>) = coerce
Monad instance: 


instance Monad (Validated ()) where
    return = Validated
    m >>= k = k (getVal m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/atp-haskell-1.9/src/Data/Logic/ATP/Lib.hs
Monad instance: 


-- Declare a Monad instance for Failing so we can chain a series of
-- Failing actions with >> or >>=.  If any action fails the subsequent
-- actions in the chain will be aborted.
instance Monad Failing where
  return = Success
  m >>= f =
      case m of
        (Failure errs) -> (Failure errs)
        (Success a) -> f a
  fail errMsg = Failure [errMsg]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/data-result-1.0/src/Data/Result.hs
Applicative instance: 


-- Basic instances 

instance Applicative Ok where pure = Ok
                              Ok f <*> Ok a = Ok $ f a
Monad instance: 


instance Monad       Ok where return = Ok
                              Ok a >>= f = f a
Applicative instance: 

instance Applicative (Error e) where pure _   = Error
                                     _ <*> _  = Error
Monad instance: 


instance Monad       (Error e) where return _ = Error
                                     _ >>= f  = Error
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/null-canvas-0.2.7/Graphics/Blank/Canvas.hs
Monad instance: 


instance Monad Canvas where
        return = Return
        (>>=) = Bind
Applicative instance: 


instance Applicative Canvas where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/inchworm-1.0.2.1/Text/Lexer/Inchworm/Scanner.hs
Applicative instance: 



instance Monad m
      => Applicative (Scanner m loc input) where
 pure x
  = Scanner $ \_ -> return (Just x)

 (<*>) (Scanner loadF) (Scanner loadX)
  =  Scanner $ \ss
  -> do mf      <- loadF ss
        case mf of
         Nothing
          -> return Nothing

         Just f
          -> do mx      <- loadX ss
                case mx of
                 Nothing        -> return Nothing
                 Just x         -> return $ Just (f x)
Monad instance: 


instance Monad m
      => Monad (Scanner m loc input) where
 return x
  = Scanner $ \_ -> return (Just x)

 (>>=) (Scanner loadX) f
  =  Scanner $ \ss
  -> do mx        <- loadX ss
        case mx of
         Nothing  -> return Nothing
         Just x   -> runScanner (f x) ss
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/network-dns-1.0.0.1/src/Network/DNS.hs
Applicative instance: 


instance Monad μ ⇒ Applicative (StateT k v μ) where
  pure = return
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad μ ⇒ Monad (StateT k v μ) where
  return = lift . return
  {-# INLINE return #-}
  m >>= f = StateT $ \ptrs offset → do
              (ptrs', offset', x) ← runStateT m ptrs offset
              runStateT (f x) ptrs' offset'
  {-# INLINE (>>=) #-}
  fail msg = lift $ fail msg
  {-# INLINE fail #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/textocat-api-0.1.0.0/src/Network/Textocat/Monadic.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (TextocatM m) where
  pure x = TextocatM $ pure x
  TextocatM f <*> TextocatM x = TextocatM $ f <*> x
Monad instance: 


instance (Functor m, MonadIO m) => Monad (TextocatM m) where
  return = pure
  TextocatM ma >>= f = TextocatM $ ma >>= unTextocatM . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/histogram-fill-0.8.4.1/Data/Histogram/Fill.hs
Applicative instance: 

instance Monad m => Applicative (HBuilderM m a) where
    pure x = HBuilderM { hbInput  = const $ return ()
                       , hbOutput = return x
                       }
    f <*> g = HBuilderM { hbInput  = \a -> hbInput f a >> hbInput g a
                        , hbOutput = do a <- hbOutput f
                                        b <- hbOutput g
                                        return (a b)
                        }
Applicative instance: 

instance Applicative (HBuilder a) where
    pure x  = HBuilder (return $ pure x)
    (HBuilder f) <*> (HBuilder g) = HBuilder $ liftM2 (<*>) f g
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/multipass-0.1.0.2/Data/Pass/Env.hs
Applicative instance: 


instance Applicative Id where
  pure = Id
  Id a <*> Id b = Id (a b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/multipass-0.1.0.2/Data/Pass/Calc.hs
Applicative instance: 


instance Applicative (Calc k a) where
  pure = Stop
  Stop f      <*> Stop a      = Stop (f a)
  Stop f      <*> (fb :& kba) = fb :& fmap f . kba
  Stop f      <*> Rank fb kba = Rank fb $ fmap f . kba
  (fg :& kgf) <*> Rank fb kba = fg :& \g -> Rank fb $ \b -> kgf g <*> kba b
  (fg :& kgf) <*> Stop a      = fg :& fmap ($a) . kgf
  (fg :& kgf) <*> (fb :& kba) = liftA2 (,) fg fb :& \(g,b) -> kgf g <*> kba b
  Rank fg kgf <*> (fb :& kba) = fb :& \b -> Rank fg $ \g -> kgf g <*> kba b
  Rank fg kgf <*> Stop a      = Rank fg $ fmap ($a) . kgf
  Rank fg kgf <*> Rank fb kba = Rank fg $ \g -> Rank fb $ \b -> kgf g <*> kba b
  _ *> b = b
  a <* _ = a
Monad instance: 


instance Monad (Calc k a) where
  return = Stop
  Stop a      >>= f = f a
  (fb :& kba) >>= f = fb :& (>>= f) . kba
  Rank fb kba >>= f = Rank fb $ (>>= f) . kba
  (>>) = (*>)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/multipass-0.1.0.2/Data/Pass/Type.hs
Applicative instance: 


instance Applicative (Pass k a) where
  pure          = Pure
  Pure f <*> xs = fmap f xs
  fs <*> Pure x = fmap ($x) fs
  fs <*> xs     = Ap id fs xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/djembe-0.1.1.2/src/Types.hs
Applicative instance: 


instance Applicative Composition where
  pure  = return
  (<*>) = ap
Monad instance: 


-- | This is basically a specialized instance of the writer monad
-- for composing compositions in series.
instance Monad Composition where
  return a = Composition (None, a)
  Composition (b, a) >>= k =
    let (Composition (b', a')) = k a
    in Composition (Series b b', a')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/happy-1.19.5/examples/igloo/ParserM.hs
Monad instance: 


instance Monad ParserM where
    ParserM m >>= k = ParserM $ \i -> do (i', x) <- m i
                                         case k x of
                                             ParserM y -> y i'
    return a = ParserM $ \i -> return (i, a)
    fail err = ParserM $ \_ -> fail err
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/BNFC-meta-0.4.0.3/Language/LBNF/Runtime.hs
Monad instance: 


instance Monad ParseMonad where
  return      = Ok
  fail        = Bad
  Ok a  >>= f = f a
  Bad s >>= f = Bad s
Applicative instance: 


instance Applicative ParseMonad where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/multiarg-0.8.0.0/System/Console/MultiArg/Prim.hs
Monad instance: 


instance Monad Parser where
  (>>=) = bind
  return = good
  fail = failString
Applicative instance: 


instance Applicative Parser where
  (<*>) = Control.Monad.ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uu-interleaved-0.2.0.0/src/Control/Applicative/Interleaved.hs
Applicative instance: 


-- | The left hand side operand is gradually transformed so we get access to its first component
instance Functor f => Applicative (Gram f) where
  pure a = Gram [] (Just a)
  Gram lb2a mb2a  <*> ~gb@(Gram lb mb)
    =   Gram  (map (`fwdby` gb) lb2a ++ [b2a <$> fb | Just b2a <- [mb2a], fb <- lb]) (mb2a <*> mb)
        where (fc2b2a `Seq`  gc) `fwdby` gb = (uncurry <$> fc2b2a)  `Seq`  ((,) <$> gc <*> gb)
              (fc `Bind` c2gb2a) `fwdby` gb = fc  `Bind` (\b -> c2gb2a b               <*> gb)
Monad instance: 



-- * `Gram` is a `Monad`
instance  Functor f =>  Monad (Gram f) where
  return a = Gram [] (Just a)
  Gram lb mb >>= b2g_a =
     let -- bindto :: Functor f => Alt f b -> (b -> Gram f a) -> Alt f a
         (f_c2b `Seq`  g_c)   `bindto` b2g_a = f_c2b `Bind` \ c2b  -> c2b <$> g_c   >>= b2g_a
         (f_c   `Bind` c2g_b) `bindto` b2g_a = f_c   `Bind` \ c    -> c2g_b c       >>= b2g_a
         la = map (`bindto` b2g_a) lb
     in case mb of
        Nothing -> Gram la Nothing
        Just b  -> let Gram lra ma =  b2g_a b
                   in  Gram (la ++ lra) ma
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/oneormore-0.1.0.3/src/Data/OneOrMore/Definition.hs
Applicative instance: 


instance Applicative OneOrMore where
  pure = One
  functions <*> args = fromList [f x | f <- toList functions, x <- toList args]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskell-src-1.0.2.0/Language/Haskell/ParseMonad.hs
Applicative instance: 


instance Applicative ParseResult where
  pure = ParseOk
  ParseOk f           <*> x = f <$> x
  ParseFailed loc msg <*> _ = ParseFailed loc msg
Monad instance: 


instance Monad ParseResult where
  return = ParseOk
  ParseOk x           >>= f = f x
  ParseFailed loc msg >>= _ = ParseFailed loc msg
Applicative instance: 


instance Applicative P where
        pure  = return
        (<*>) = ap
Monad instance: 


instance Monad P where
        return a = P $ \_i _x _y _l s _m -> Ok s a
        P m >>= k = P $ \i x y l s mode ->
                case m i x y l s mode of
                    Failed loc msg -> Failed loc msg
                    Ok s' a -> runP (k a) i x y l s' mode
        fail s = P $ \_r _col _line loc _stk _m -> Failed loc s
Applicative instance: 


instance Applicative (Lex r) where
        pure  = return
        (<*>) = ap
Monad instance: 


instance Monad (Lex r) where
        return a = Lex $ \k -> k a
        Lex v >>= f = Lex $ \k -> v (\a -> runL (f a) k)
        Lex v >> Lex w = Lex $ \k -> v (\_ -> w k)
        fail s = Lex $ \_ -> fail s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskell-src-1.0.2.0/Language/Haskell/Pretty.hs
Applicative instance: 


instance Applicative (DocM s) where
        pure = return
        (<*>) = ap
Monad instance: 


instance Monad (DocM s) where
        (>>=) = thenDocM
        (>>) = then_DocM
        return = retDocM
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-graphics-1.2/Data/Vertex.hs
Applicative instance: 

instance Applicative V2 where
  V2 fx fy <*> V2 x y = V2 (fx x) (fy y)
Applicative instance: 

instance Applicative V3 where
  V3 fx fy fz <*> V3 x y z = V3 (fx x) (fy y) (fz z)
Applicative instance: 

instance Applicative V4 where
  V4 fx fy fz fw <*> V4 x y z w = V4 (fx x) (fy y) (fz z) (fw w)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-graphics-1.2/IO/Graphics.hs
Applicative instance: 

instance Applicative Vector3 where
  Vector3 fx fy fz <*> Vector3 x y z = Vector3 (fx x) (fy y) (fz z)
Applicative instance: 

instance Applicative Vertex3 where
  Vertex3 fx fy fz <*> Vertex3 x y z = Vertex3 (fx x) (fy y) (fz z)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liboleg-2010.1.9.0/System/IterateeM.hs
Monad instance: 


-- | It turns out, IterateeGM form a monad. We can use the familiar do
-- notation for composing Iteratees
--
instance Monad m => Monad (IterateeGM el m) where
    return x = liftI  $ IE_done  x (Chunk [])
    m >>= f = m >>== docase
     where
     docase (IE_done a (Chunk [])) = f a
     docase (IE_done a stream) = f a >>== (\r -> case r of
                                IE_done x _  -> liftI $ IE_done x stream
                                IE_cont k    -> k stream)
     docase (IE_cont k) = liftI $ IE_cont ((>>= f) . k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liboleg-2010.1.9.0/System/RandomIO.hs
Monad instance: 


instance Monad RBIO where
    return  = RBIO . const . return
    m >>= f = RBIO( \env -> unRBIO m env >>= (\x -> unRBIO (f x) env) )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liboleg-2010.1.9.0/Language/CB98.hs
Monad instance: 


-- | Could be automatically derived by GHC. But we stick to Haskell98
instance Monad m => Monad (SName m) where
    return = SN . return
    m >>= f = SN $ unSN m >>= unSN . f
Monad instance: 


-- | Could be automatically derived by GHC. 
instance Monad m => Monad (SValue m) where
    return = SV . return
    m >>= f = SV $ unSV m >>= unSV . f
Monad instance: 


-- | Could be automatically derived by GHC. 
instance Monad m => Monad (SLazy m) where
    return = SL . return
    m >>= f = SL $ unSL m >>= unSL . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liboleg-2010.1.9.0/Control/Generator2.hs
Monad instance: 


instance Monad Identity where
    return = Identity
    m >>= f = f $ runIdentity m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liboleg-2010.1.9.0/Control/CCRef.hs
Monad instance: 

-- hence, the rest of scAPI is irrelevant:
-- copy_stack_fragment and push_stack_fragment do nothing at all

-- --------------------------------------------------------------------
-- | CC monad: general monadic operations
--
instance Monad m => Monad (CC m) where
    return x = CC $ \k _ -> k x
    m >>= f  = CC $ \k ptop -> unCC m (\v -> unCC (f v) k ptop) ptop
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liboleg-2010.1.9.0/Control/CCCxe.hs
Monad instance: 



-- --------------------------------------------------------------------
-- | CC monad: general monadic operations
--
instance Monad m => Monad (CC p m) where
    return x = CC $ \ki kd -> ki x

    m >>= f = CC $ \ki kd -> unCC m
                              (\a -> unCC (f a) ki kd)
                              (\ctx -> kd (\x -> ctx x >>= f))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liboleg-2010.1.9.0/Control/StateAlgebra.hs
Monad instance: 


instance Monad (Statte s) where
    (Statte m) >>= f = Statte (Bind m (\x -> f x))
    return = Statte . Return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/liboleg-2010.1.9.0/Control/CCExc.hs
Monad instance: 



--
-- |CC monad: general monadic operations
--
instance Monad m => Monad (CC p m) where
    return = CC . return . Iru

    m >>= f = CC $ unCC m >>= check
        where check (Iru a)         = unCC $ f a
              check (Deru ctx body) = return $ Deru (\x -> ctx x >>= f) body
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/agum-2.6/src/Algebra/AbelianGroup/Main.hs
Applicative instance: 


instance Applicative (AnsErr) where
    pure          = Ans
    Err e <*> _ = Err e
    Ans f <*> r = fmap f r
Monad instance: 


instance Monad AnsErr where
    (Ans x) >>= k = k x
    (Err s) >>= _ = Err s
    return        = Ans
    fail          = Err
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HAppS-Server-0.9.3.1/src/HAppS/Server/SimpleHTTP.hs
Monad instance: 


instance (Monad m) => Monad (ServerPartT m) where
    f >>= g = ServerPartT $ \rq ->
              do a <- unServerPartT f rq
                 unServerPartT (g a) rq
    return x = ServerPartT $ \_ -> return x
Monad instance: 


instance Monad m => Monad (WebT m) where
    f >>= g = WebT $ do r <- unWebT f
                        case r of
                          NoHandle    -> return NoHandle
                          Escape resp -> return $ Escape resp
                          Ok out a    -> do r' <- unWebT (g a)
                                            case r' of
                                              NoHandle    -> return NoHandle
                                              Escape resp -> return $ Escape resp
                                              Ok out' a'  -> return $ Ok (out' . out) a'
    return x = WebT $ return (Ok id x)
Applicative instance: 


instance (Monad m, Functor m) => Applicative (ServerPartT m) where
    pure = return
    (<*>) = ap
Applicative instance: 


instance (Monad m, Functor m) => Applicative (WebT m) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sifflet-2.3.0/lib/Language/Sifflet/Util.hs
Applicative instance: 


instance Applicative SuccFail where
  pure = Succ
  Succ f <*> Succ v = Succ (f v)
  Fail s <*> _ = Fail s
  Succ _ <*> Fail s = Fail s
Monad instance: 


instance Monad SuccFail where
  Succ val >>= f = f val
  Fail err >>= _f = Fail err
  return = Succ
  fail = Fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sifflet-2.3.0/lib/Language/Sifflet/Expr.hs
Applicative instance: 


instance Applicative EvalRes where
  pure = EvalOk
  EvalOk f <*> EvalOk v = EvalOk (f v)
  EvalOk _ <*> EvalError s = EvalError s
  EvalOk _ <*> EvalUntried = EvalUntried

  -- It seems that the other cases should be consistent
  -- with evalWithLimit for ECall below,
  -- whatever that means ...
  EvalError s <*> _ = EvalError s
  EvalUntried <*> _ = EvalUntried
Monad instance: 


instance Monad EvalRes where
  EvalOk value >>= f = f value
  EvalError e >>= _f = EvalError e
  EvalUntried >>= _f = EvalUntried
  return = EvalOk
  fail = EvalError
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/these-0.7.2/Control/Monad/Trans/Chronicle.hs
Applicative instance: 


instance (Semigroup c, Applicative m) => Applicative (ChronicleT c m) where
    pure = ChronicleT . pure . pure
    ChronicleT f <*> ChronicleT x = ChronicleT (liftA2 (<*>) f x)
Monad instance: 


instance (Semigroup c, Monad m) => Monad (ChronicleT c m) where
    return = ChronicleT . return . return
    m >>= k = ChronicleT $
        do cx <- runChronicleT m
           case cx of
               This  a   -> return (This a)
               That    x -> runChronicleT (k x)
               These a x -> do cy <- runChronicleT (k x)
                               return $ case cy of
                                            This  b   -> This (a <> b)
                                            That    y -> These a y
                                            These b y -> These (a <> b) y
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/csound-expression-typed-0.0.9.3/src/Csound/Typed/Gui/BoxModel.hs
Applicative instance: 


instance Applicative (Scene ctx) where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad (Scene ctx) where
    return = Prim
    ma >>= mf = joinScene $ fmap mf ma
        where
            joinScene :: Scene ctx (Scene ctx a) -> Scene ctx a
            joinScene x = case x of
                Prim rec    -> rec
                Space       -> Space
                Scale   d a -> Scale   d (joinScene a)
                Hor     o a -> Hor     o (fmap joinScene a)
                Ver     o a -> Ver     o (fmap joinScene a)
                Context c a -> Context c (joinScene a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/csound-expression-typed-0.0.9.3/src/Csound/Typed/GlobalState/GE.hs
Applicative instance: 


instance Applicative GE where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad GE where
    return = GE . return
    ma >>= mf = GE $ unGE ma >>= unGE . mf
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/csound-expression-typed-0.0.9.3/src/Csound/Typed/GlobalState/SE.hs
Applicative instance: 


instance Applicative SE where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad SE where
    return = SE . return
    ma >>= mf = SE $ unSE ma >>= unSE . mf
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Moe-0.1/FRP/Moe/Core.hs
Applicative instance: 


instance Applicative (SF a) where
  -- ^ Input:  [i1, i2, ...] (ignored)

  -- ^ Output: [x,  x,  ...]         
  pure x = sfArr (const x)
  -- ^ Input of sff:  [x1, x2, ...]

  -- ^ Output of sff: [f1, f2, ...]

  -- ^ Input of sfy:  [x1, x2, ...]

  -- ^ Output of sfy: [y1, y2, ...]

  -- ^ Input:         [x1, x2, ...]

  -- ^ Output:        [f1 y1, f2 y2, ...]
  sff <*> sfy = MkSF (\dt x -> let (f, sff') = runSF sff dt x
                                   (y, sfy') = runSF sfy dt x
                               in (f y, sff' <*> sfy'))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cryptol-2.4.0/src/Cryptol/Parser/NoInclude.hs
Applicative instance: 


instance A.Applicative NoIncM where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad NoIncM where
  return x = M (return x)
  m >>= f  = M (unM m >>= unM . f)
  fail x   = M (fail x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cryptol-2.4.0/src/Cryptol/Parser/NoPat.hs
Applicative instance: 

instance Applicative NoPatM where pure = return; (<*>) = ap
Monad instance: 

instance Monad NoPatM where
  return x  = M (return x)
  fail x    = M (fail x)
  M x >>= k = M (x >>= unM . k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cryptol-2.4.0/src/Cryptol/Parser/ParserUtils.hs
Monad instance: 


instance Monad ParseM where
  return a  = P (\_ _ s -> Right (a,s))
  fail s    = panic "[Parser] fail" [s]
  m >>= k   = P (\cfg p s1 -> case unP m cfg p s1 of
                            Left e       -> Left e
                            Right (a,s2) -> unP (k a) cfg p s2)
Applicative instance: 


instance Applicative ParseM where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cryptol-2.4.0/src/Cryptol/TypeCheck/Solver/Numeric/AST.hs
Monad instance: 


instance Monad (IfExpr' p) where
  return  = Return
  fail _  = Impossible
  m >>= k = case m of
              Impossible -> Impossible
              Return a   -> k a
              If p t e   -> If p (t >>= k) (e >>= k)
Applicative instance: 


instance A.Applicative (IfExpr' p) where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cryptol-2.4.0/src/Cryptol/TypeCheck/Sanity.hs
Applicative instance: 


instance A.Applicative TcM where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad TcM where
  return a    = TcM (return a)
  fail x      = TcM (fail x)
  TcM m >>= f = TcM (do a <- m
                        let TcM m1 = f a
                        m1)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cryptol-2.4.0/src/Cryptol/TypeCheck/Unify.hs
Applicative instance: 


instance Applicative Result where
  pure = OK

  OK f     <*> OK x    = OK (f x)
  OK _     <*> Error e = Error e
  Error e  <*> _       = Error e
Monad instance: 


instance Monad Result where
  return a      = OK a

  OK a >>= k    = k a
  Error x >>= _ = Error x

  fail x        = panic "Cryptol.TypeCheck.Unify.fail" [x]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cryptol-2.4.0/src/Cryptol/TypeCheck/Monad.hs
Applicative instance: 


instance A.Applicative InferM where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad InferM where
  return x      = IM (return x)
  fail x        = IM (fail x)
  IM m >>= f    = IM (m >>= unIM . f)
Applicative instance: 


instance A.Applicative KindM where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad KindM where
  return x      = KM (return x)
  fail x        = KM (fail x)
  KM m >>= k    = KM (m >>= unKM . k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cryptol-2.4.0/src/Cryptol/Eval.hs
Applicative instance: 


instance Applicative ZList where
  pure x = Pure x
  Pure f <*> Pure x = Pure (f x)
  Pure f <*> Zip xs = Zip (map f xs)
  Zip fs <*> Pure x = Zip (map ($ x) fs)
  Zip fs <*> Zip xs = Zip (zipWith ($) fs xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cryptol-2.4.0/src/Cryptol/REPL/Monad.hs
Applicative instance: 


instance Applicative REPL where
  {-# INLINE pure #-}
  pure = return
  {-# INLINE (<*>) #-}
  (<*>) = ap
Monad instance: 


instance Monad REPL where
  {-# INLINE return #-}
  return x = REPL (\_ -> return x)

  {-# INLINE (>>=) #-}
  m >>= f = REPL $ \ref -> do
    x <- unREPL m ref
    unREPL (f x) ref
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cryptol-2.4.0/src/Cryptol/ModuleSystem/Name.hs
Applicative instance: 


instance Monad m => Applicative (SupplyT m) where
  pure x = SupplyT (pure x)
  {-# INLINE pure #-}

  f <*> g = SupplyT (unSupply f <*> unSupply g)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad m => Monad (SupplyT m) where
  return = pure
  {-# INLINE return #-}

  m >>= f = SupplyT (unSupply m >>= unSupply . f)
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cryptol-2.4.0/src/Cryptol/ModuleSystem/Renamer.hs
Applicative instance: 


instance Applicative RenameM where
  {-# INLINE pure #-}
  pure x        = RenameM (pure x)

  {-# INLINE (<*>) #-}
  l <*> r       = RenameM (unRenameM l <*> unRenameM r)
Monad instance: 


instance Monad RenameM where
  {-# INLINE return #-}
  return x      = RenameM (return x)

  {-# INLINE (>>=) #-}
  m >>= k       = RenameM (unRenameM m >>= unRenameM . k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cryptol-2.4.0/src/Cryptol/ModuleSystem/Monad.hs
Applicative instance: 


instance Monad m => Applicative (ModuleT m) where
  {-# INLINE pure #-}
  pure x = ModuleT (pure x)

  {-# INLINE (<*>) #-}
  l <*> r = ModuleT (unModuleT l <*> unModuleT r)
Monad instance: 


instance Monad m => Monad (ModuleT m) where
  {-# INLINE return #-}
  return x      = ModuleT (return x)

  {-# INLINE (>>=) #-}
  m >>= f       = ModuleT (unModuleT m >>= unModuleT . f)
  {-# INLINE fail #-}
  fail          = ModuleT . raise . OtherFailure
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pack-0.4.0/Data/Pack/Packet.hs
Applicative instance: 


instance Applicative (Packet e) where
  pure a = Packet
    ( \_ _ p -> return (p, Right a)
    , id
    , \_ _ p -> return p)
  {-# INLINE pure #-}
  Packet (fg, fs, fp) <*> Packet (get, size, put) = Packet
    ( \t b p ->
      fg t b p >>= \(p', ef) ->
      either (\l -> return (p', Left l)) (\f ->
        get t b p' >>= \(p'', ev) ->
        either (\l -> return (p'', Left l)) (\v ->
          return (p'', Right $ f v)
          ) ev
        ) ef
    , size . fs
    , \t b p -> fp t b p >>= put t b
    )
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad (Packet e) where
  return = pure
  {-# INLINE return #-}
  Packet (mg, ms, mp) >>= f =
    let Packet (_, size, set) = f (error "packer cannot touch do-bindings")
    in Packet
    ( \t b p ->
      mg t b p >>= \(p', eg) ->
      either (\r -> return (p', Left r)) (\v ->
        let Packet (get, _, _) = f v
        in get t b p'
        ) eg
    , size . ms
    , \t b p -> mp t b p >>= set t b
    )
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/peggy-0.3.2/Text/Peggy/Prim.hs
Monad instance: 


instance Monad (Parser tbl str s) where
  return v = Parser $ \_ pos p s -> return $ Parsed pos p s v
  p >>= f = Parser $ \tbl pos prev s -> do
    res <- unParser p tbl pos prev s
    case res of
      Parsed qos q t x ->
        unParser (f x) tbl qos q t
      Failed err ->
        return $ Failed err
Applicative instance: 


instance Applicative (Parser tbl str s) where
  pure = return
  p <*> q = do
    f <- p
    x <- q
    return $ f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cypher-0.8.1/Database/Cypher.hs
Monad instance: 


instance Monad Cypher where
        return a = Cypher (const (return a))
        (Cypher  cmd) >>= f =
                Cypher $ \con-> do
                        a <- cmd con
                        uncypher (f a) con
Applicative instance: 


instance Applicative Cypher where
        pure = Cypher . const . return
        Cypher f <*> Cypher x = Cypher $ \d-> do
                func <- f d
                arg <- x d
                return $ func arg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sox-0.2.2.6/src/Sound/Sox/Information.hs
Applicative instance: 


instance Applicative T where
   {-# INLINE pure #-}
   {-# INLINE (<*>) #-}
   pure = Cons . pure
   (Cons f) <*> (Cons x) = Cons (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sox-0.2.2.6/src/Sound/Sox/Private/Information.hs
Applicative instance: 


instance Applicative T where
   {-# INLINE pure #-}
   {-# INLINE (<*>) #-}
   pure = Cons . pure
   (Cons f) <*> (Cons x) = Cons (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/json-togo-0.1.1.0/src/Data/JSON/ToGo.hs
Applicative instance: 


instance Monad m => Applicative (ValueT m) where
  pure = NullM . return
  (<*>) = apply
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/DPM-0.3.0.0/src/DPM/Core/DPM_Monad.hs
Monad instance: 


instance Monad DPM where
    DPM a >>= f = DPM (a >>= (unDPM . f))
    return = DPM . return
    fail errMsg = liftIO' $ throwIO (DPMException errMsg)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskelldb-2.2.4/src/Database/HaskellDB/Query.hs
Monad instance: 


instance Monad Query where
  return x              = Query (\q0 -> (x,q0))
  (Query g) >>= f       = Query (\q0 -> let (x,q1)    = g q0
                                            (Query h) = f x
                                        in  (h q1))
Applicative instance: 


instance Applicative Query where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sdl2-2.1.3/src/SDL/Internal/Vect.hs
Applicative instance: 


instance Applicative V2 where
  pure a = V2 a a
  {-# INLINE pure #-}
  V2 a b <*> V2 d e = V2 (a d) (b e)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad V2 where
  return a = V2 a a
  {-# INLINE return #-}
  V2 a b >>= f = V2 a' b' where
    V2 a' _ = f a
    V2 _ b' = f b
  {-# INLINE (>>=) #-}
Applicative instance: 


instance Applicative V3 where
  pure a = V3 a a a
  {-# INLINE pure #-}
  V3 a b c <*> V3 d e f = V3 (a d) (b e) (c f)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad V3 where
  return a = V3 a a a
  {-# INLINE return #-}
  V3 a b c >>= f = V3 a' b' c' where
    V3 a' _ _ = f a
    V3 _ b' _ = f b
    V3 _ _ c' = f c
  {-# INLINE (>>=) #-}
Applicative instance: 


instance Applicative V4 where
  pure a = V4 a a a a
  {-# INLINE pure #-}
  V4 a b c d <*> V4 e f g h = V4 (a e) (b f) (c g) (d h)
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad V4 where
  return a = V4 a a a a
  {-# INLINE return #-}
  V4 a b c d >>= f = V4 a' b' c' d' where
    V4 a' _ _ _ = f a
    V4 _ b' _ _ = f b
    V4 _ _ c' _ = f c
    V4 _ _ _ d' = f d
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/blazeMarker-0.1.0.0/Control/Monad/FreeMarker.hs
Applicative instance: 


instance Applicative FM where
    pure = return
    (FM f1) <*> (FM f2) = r
      where
        r = FM (\v -> let
                          (s2,v2,a2) = f1 v
                          (s3,v3,a3) = f2 v in
               ( s2 ++ s3 , v2 + v3 , a2 a3 ))
Monad instance: 


instance Monad FM where
    return x = FM (\v -> ("", v, x) )
    (FM fm1) >>= f = FM (\v ->
      let
         (s,v2,a1)  = fm1 v
         (FM fm2)   = f a1
         (s2,v3,a2) = fm2 v2
       in
      ( s ++ "\n" ++ s2 , v3, a2 )
     )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ideas-math-1.2/src/Domain/Math/Data/WithBool.hs
Monad instance: 


instance Monad WithBool where
   return  = singleton
   m >>= f = either fromBool f (fromWithBool m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/data-msgpack-0.0.2/src/Data/MessagePack/Result.hs
Applicative instance: 



instance Applicative Result where
  pure = Success

  Success f   <*> x = fmap f x
  Failure msg <*> _ = Failure msg
Monad instance: 



instance Monad Result where
  return = pure
  fail = Failure

  Success x   >>= f = f x
  Failure msg >>= _ = Failure msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/vinyl-plus-0.1.1/src/Data/Vinyl/Types.hs
Applicative instance: 


instance Applicative (FunctorRec '[]) where
  pure _ = FunctorRec RNil
  FunctorRec RNil <*> FunctorRec RNil = FunctorRec RNil
Applicative instance: 


instance (Applicative r, Applicative (FunctorRec rs)) => Applicative (FunctorRec (r ': rs)) where
  pure a = FunctorRec (Flap (pure a) :& getFunctorRec (pure a))
  FunctorRec (Flap f :& fs) <*> FunctorRec (Flap a :& as) =
    FunctorRec (Flap (f <*> a) :& getFunctorRec (FunctorRec fs <*> FunctorRec as))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fixfile-0.5.0.0/src/Data/FixFile.hs
Applicative instance: 


instance Applicative (Transaction f s) where
    pure = Transaction . pure
    Transaction a <*> Transaction b = Transaction $ a <*> b
Monad instance: 


instance Monad (Transaction f s) where
    return = pure
    Transaction t >>= f = Transaction $ RWS.RWST $ \ffh root -> do
        (a, root', w) <- RWS.runRWST t ffh root
        (a', root'', w') <- RWS.runRWST (runRT $ f a) ffh root'
        return (a', root'', w `mappend` w')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/parconc-examples-0.4.3/parinfer/InferMonad.hs
Applicative instance: 


instance Applicative Infer where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Infer where
  return = returnI
  (>>=) = thenI
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/parconc-examples-0.4.3/findpar5.hs
Applicative instance: 


instance Applicative EParIO where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad EParIO where
  return a = E (return (Right a))
  E m >>= k = E $ do
    r <- m
    case r of
      Left e -> return (Left e)
      Right a -> unE (k a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mcm-0.6.4.10/InterpretState.hs
Monad instance: 


instance Monad Interpret where
    Interpret c1 >>= fc2  = Interpret (\s0 -> let (r,s1) = c1 s0
                                                  Interpret c2 = fc2 r
                                              in c2 s1)
    return k              = Interpret (\s -> (k,s))
Applicative instance: 


instance Applicative Interpret where
    pure  = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tidal-0.8.1/Sound/Tidal/Pattern.hs
Applicative instance: 


-- | @pure a@ returns a pattern with an event with value @a@, which
-- has a duration of one cycle, and repeats every cycle.
instance Applicative Pattern where
  pure x = Pattern $ \(s, e) -> map
                                (\t -> ((t%1, (t+1)%1),
                                        (t%1, (t+1)%1),
                                        x
                                       )
                                )
                                [floor s .. ((ceiling e) - 1)]
  (Pattern fs) <*> (Pattern xs) =
    Pattern $ \a -> concatMap applyX (fs a)
    where applyX ((s,e), (s', e'), f) =
            map (\(_, _, x) -> ((s,e), (s', e'), f x))
                (filter
                 (\(_, a', _) -> isIn a' s)
                 (xs (s',e'))
                )
Monad instance: 


instance Monad Pattern where
  return = pure
  -- Pattern a -> (a -> Pattern b) -> Pattern b
  -- Pattern Char -> (Char -> Pattern String) -> Pattern String

  p >>= f = unwrap (f <$> p)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/guarded-rewriting-0.1/performance/Common/LogicStrategies.hs
Monad instance: 


instance MonadPlus m => Monad (S m) where
  return x = S x mzero
  (S x xs) >>= k
    = S r (rs1 `mplus` rs2)
      where
        S r rs1 = k x
        rs2 = do x <- xs
                 let S r _ = k x
                 return r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/frown-0.6.2.3/GParser2.hs
Applicative instance: 


  instance (Applicative m, Monad m) => Applicative (Lex m) where
      pure a                    = Lex (\ k -> k a)
      (<*>)                     = ap
Monad instance: 


  instance (Monad m) => Monad (Lex m) where
      return a                  =  Lex (\ cont -> cont a)
      m >>= k                   =  Lex (\ cont -> unLex m (\ a -> unLex (k a) cont))
      fail s                    =  lift (fail s)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/frown-0.6.2.3/Examples/Haskell/Input/GParser2.hs
Monad instance: 


  instance (Monad m) => Monad (Lex m) where
      return a                  =  Lex (\ cont -> cont a)
      m >>= k                   =  Lex (\ cont -> unLex m (\ a -> unLex (k a) cont))
      fail s                    =  lift (fail s)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/edenmodules-1.2.0.0/Control/Parallel/Eden/EdenConcHs.hs
Monad instance: 


instance Monad PA where
 return b       = PA $ return b
 (PA ioX) >>= f = PA $ do
   x  <- ioX
   fromPA $ f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/result-0.2.3.0/src/Control/Monad/Trans/Result.hs
Applicative instance: 



instance Applicative f => Applicative (ResultT e f) where
  pure a =
    ResultT (pure (pure a))

  (ResultT mf) <*> (ResultT ma) =
    ResultT $
      liftA2 (<*>) mf ma
Monad instance: 



instance Monad m => Monad (ResultT e m) where
  return =
    pure

  (ResultT m) >>= f =
    ResultT $
      m >>= fmap join . traverse (runResultT . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/result-0.2.3.0/src/Data/Result.hs
Applicative instance: 



instance Applicative (AccumulatingResult e) where
  pure a =
    AccRes (pure a)

  x <*> y =
    AccRes (getResult x `zap` getResult y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unexceptionalio-0.3.0/UnexceptionalIO.hs
Applicative instance: 


instance Applicative UIO where
        pure = return
        (<*>) = ap
Monad instance: 


instance Monad UIO where
        return = UIO . return
        (UIO x) >>= f = UIO (x >>= runUIO . f)

        fail s = error $ "UnexceptionalIO cannot fail (" ++ s ++ ")"
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/implicit-0.0.5/Graphics/Implicit/ExtOpenScad/Util/ArgParser.hs
Applicative instance: 


instance Applicative ArgParser where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad ArgParser where

    -- return is easy: if we want an ArgParser that just gives us a, that is 
    -- ArgParserTerminator a
    return a = APTerminator a

    -- Now things get more interesting. We need to describe how (>>=) works.
    -- Let's get the hard ones out of the way first.
    -- ArgParser actually 
    (AP str fallback doc f) >>= g = AP str fallback doc (\a -> (f a) >>= g)
    (APFailIf b errmsg child) >>= g = APFailIf b errmsg (child >>= g)
    -- These next to is easy, they just pass the work along to their child
    (APExample str child) >>= g = APExample str (child >>= g)
    (APTest str tests child) >>= g = APTest str tests (child >>= g)
    -- And an ArgParserTerminator happily gives away the value it contains
    (APTerminator a) >>= g = g a
    (APBranch bs) >>= g = APBranch $ map (>>= g) bs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/vision-0.0.5.0/src/Control/Monad/EnvIO.hs
Monad instance: 


instance Monad (EnvIO e) where
  return a = EnvIO $ const $ return a
  m >>= n  = EnvIO $ \e -> do
    a <- runEnvIO m e
    runEnvIO (n a) e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/varying-0.5.0.3/src/Control/Varying/Event.hs
Monad instance: 


instance Monad Event where
   return = Event
   (Event a) >>= f = f a
   _ >>= _ = NoEvent
Applicative instance: 


instance Applicative Event where
    pure = Event
    (<*>) (Event f) (Event a) = Event $ f a
    (<*>) _ _ = NoEvent
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/varying-0.5.0.3/src/Control/Varying/Core.hs
Applicative instance: 


-- | Streams are applicative.
--
-- >  (,) <$> pure True <*> var "Applicative"
instance (Applicative m, Monad m) => Applicative (VarT m a) where
    pure = done
    vf <*> va = VarT $ \a -> do (f, vf') <- runVarT vf a
                                (b, va') <- runVarT va a
                                return (f b, vf' <*> va')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/phooey-2.0.0.1/src/Graphics/UI/Phooey/Monad.hs
Applicative instance: 


-- Standard monad-as-applicative instance
instance Applicative UI where { pure = return ; (<*>) = ap }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/genericserialize-0.1/Data/Generics/Serialization/Streams.hs
Monad instance: 


instance Monad (ListBuild e) where
    return x = LB id x
    (LB l1 _) >> (LB l2 a) = LB (l1 . l2) a
    (LB l1 x) >>= fn = case fn x of (LB l2 y) -> LB (l1 . l2) y
Monad instance: 

instance Monad (ListRead e) where
    fail _ = LR (\_ -> Nothing)
    return x = LR (\l -> Just (l, x))
    (LR th) >>= fn = LR (\l -> case th l of Just (l', x) -> unLR (fn x) l'
                                            Nothing      -> Nothing)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bytestringreadp-0.2/src/Text/ParserCombinators/ReadP/ByteString.hs
Monad instance: 
 -- invariant: list is non-empty!-- invariant: list is non-empty!

-- Monad, MonadPlus-- Monad, MonadPlus

instance Monad (P) where
  return x = Result x Fail

  (Skip n f)   >>= k = Skip n (f >>= k)
  (Look f)     >>= k = Look (\s -> f s >>= k)
  Fail         >>= k = Fail
  (Result x p) >>= k = k x `mplus` (p >>= k)
  (Final r)    >>= k = final [ys' | (x,s) <- r, ys' <- run (k x) s]

  fail _ = Fail
Monad instance: 


instance Monad (ReadP) where
  return x  = R (\k -> k x)
  fail _    = R (\_ -> Fail)
  R m >>= f = R (\k -> m (\a -> let R m' = f a in m' k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/scotty-resource-0.1.1.0/src/Web/Scotty/Resource/Trans.hs
Applicative instance: 

instance Applicative (WebResource e m) where
  pure = W []
  W l f <*> W r a = W (l <> r) (f a)
Monad instance: 

instance Monad (WebResource e m) where
  return = W []
  W methods a >>= f =
    let W newMethods b = f a
    in W (methods <> newMethods) b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Encode-1.3.8/PureFP/Parsers/Standard.hs
Applicative instance: 



instance Applicative (Standard s) where
  pure a = Std (\inp -> [(inp,a)])
  (<*>)  = ap
Monad instance: 



instance Monad (Standard s) where
  return      = pure
  Std p >>= k = Std (\inp -> concat [ q inp' |
                                      (inp', a) <- p inp,
                                      let Std q = k a ])
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Encode-1.3.8/PureFP/Parsers/Trie.hs
Applicative instance: 



instance Ord s => Applicative (Trie s) where
  pure a = a ::: zero
  (<*>)  = ap
Monad instance: 


instance Ord s => Monad (Trie s) where
  return           = pure

  (a ::: p)  >>= k = k a <+> (p >>= k)
  Shift pmap >>= k = Shift (mapMap (>>=k) pmap)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Encode-1.3.8/PureFP/Parsers/AmbTrie.hs
Applicative instance: 



instance Ord s => Applicative (AmbTrie s) where
  pure a = [a] :&: emptyMap
  (<*>)  = ap
Monad instance: 



instance Ord s => Monad (AmbTrie s) where
  return            = pure

  (as:&:pmap) >>= k = foldr (<+>) ([]:&:mapMap (>>=k) pmap) (map k as)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Encode-1.3.8/PureFP/Parsers/Stream.hs
Applicative instance: 



instance Applicative (Stream s) where
  pure a = a ::: Nil
  (<*>)  = ap
Monad instance: 



instance Monad (Stream s) where
  return         = pure

  Shift f  >>= k = Shift (\s -> f s >>= k)
  (a:::as) >>= k = k a <+> (as >>= k)
  Nil      >>= k = Nil
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Encode-1.3.8/PureFP/Parsers/PairTrie.hs
Applicative instance: 



instance (Ord s, Monad m, Applicative m) => Applicative (PairTrie m s) where
  pure a = (p ::: zero) :&: p
    where p = pure a
  (<*>)  = ap
Monad instance: 



instance (Ord s, Monad m, Applicative m) => Monad (PairTrie m s) where
  return = pure

  (>>=)  = error "PairTrie: (>>=) is not implemented"
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Encode-1.3.8/Encode/Extend.hs
Applicative instance: 



instance Applicative (Extend e s) where
  pure a = Ext (\ inp -> [(inp, a)])
  (<*>)  = ap
Monad instance: 



instance Monad (Extend e s) where
  return      = pure
  Ext p >>= k = Ext (\ inp -> concat [ q inp' | (inp', a) <- p inp,
                                                 let Ext q = k a ])
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/either-4.4.1.1/src/Data/Either/Validation.hs
Applicative instance: 


instance Semigroup e => Applicative (Validation e) where
  pure = Success
  Failure e1 <*> Failure e2 = Failure (e1 <> e2)
  Failure e1 <*> Success _  = Failure e1
  Success _  <*> Failure e2 = Failure e2
  Success f  <*> Success a  = Success (f a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/libjenkins-0.8.3/src/Jenkins/Rest/Internal.hs
Applicative instance: 


instance Applicative (JenkinsT m) where
  pure = JenkinsT . pure
  JenkinsT f <*> JenkinsT x = JenkinsT (f <*> x)
Monad instance: 


instance Monad (JenkinsT m) where
  return = JenkinsT . return
  JenkinsT m >>= k = JenkinsT (m >>= unJenkinsT . k)
Applicative instance: 


instance (Functor m, Monad m) => Applicative (InterpT m) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad m => Monad (InterpT m) where
  return = InterpT . return . return
  InterpT m >>= k = InterpT (\req -> m req >>= \a -> runInterpT (k a) req)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/xml-picklers-0.3.6/src/Data/XML/Pickle/Basic.hs
Applicative instance: 



instance Applicative (UnpickleResult t) where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad (UnpickleResult t) where
    return x = Result x Nothing
    Result x r >>= f = case f x of
        Result y r' -> Result y (if isJust r then r else r')
        y -> y
    UnpickleError e >>= _ = UnpickleError e
    NoResult e >>= _ = NoResult e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rvar-0.2.0.3/src/Data/RVar.hs
Monad instance: 


instance Monad (RVarT n) where
    return x = RVarT (return $! x)
    fail s   = RVarT (fail s)
    (RVarT m) >>= k = RVarT (m >>= \x -> x `seq` unRVarT (k x))
Applicative instance: 


instance Applicative (RVarT n) where
    pure  = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tamarin-prover-term-0.8.5.1/src/Term/VTerm.hs
Applicative instance: 


-- | Applicative instance in the variable.
instance Applicative (Lit c) where
    pure = Var
    (Var f)  <*> (Var x)  = Var (f x)
    (Var _)  <*> (Con n) = Con n
    (Con n) <*> _        = Con n
Monad instance: 


-- | Monad instance in the variable
instance Monad (Lit c) where
    return         = Var
    (Var x)  >>= f = f x
    (Con n)  >>= _ = Con n
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tamarin-prover-term-0.8.5.1/src/Term/Rewriting/Definitions.hs
Applicative instance: 


instance Applicative Equal where
    pure x                        = Equal x x
    (Equal fl fr) <*> (Equal l r) = Equal (fl l) (fr r)
Applicative instance: 


instance Applicative RRule where
    pure x                        = RRule x x
    (RRule fl fr) <*> (RRule l r) = RRule (fl l) (fr r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tamarin-prover-term-0.8.5.1/src/Term/LTerm.hs
Applicative instance: 


instance Applicative BVar where
   pure  = return
   (<*>) = ap
Monad instance: 


instance Monad BVar where
    return  = Free
    m >>= f = foldBVar Bound f m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/deka-tests-0.6.0.2/dectest/TestLog.hs
Monad instance: 


instance Monad TestLog where
  return a = TestLog (S.empty, Good a)
  (TestLog (ss, st)) >>= f = TestLog $ case st of
    Failed -> (ss, Failed)
    Bypass -> (ss, Bypass)
    Good a -> let (ss', st') = unTestLog $ f a in
      (ss <> ss', st')
Applicative instance: 


instance Applicative TestLog where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chatty-0.7.0.0/System/Chatty/Spawn/Overlay.hs
Monad instance: 


instance Monad m => Monad (SpawnOverlayT m) where
  return a = SpawnOverlay $ \o -> return (a,o)
  (SpawnOverlay o) >>= f = SpawnOverlay $ \s -> do (a,s') <- o s; runSpawnOverlayT (f a) s'
Applicative instance: 


instance Monad m => Applicative (SpawnOverlayT m) where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chatty-0.7.0.0/System/Chatty/Filesystem.hs
Monad instance: 


instance Monad m => Monad (FilePrinterT m) where
  return a = FilePrinter $ \_ -> return a
  m >>= f = FilePrinter $ \d -> do a <- runFilePrinterT m d; runFilePrinterT (f a) d
Monad instance: 


instance Monad m => Monad (FileScannerT m) where
  return a = FileScanner $ \_ -> return a
  m >>= f = FileScanner $ \d -> do a <- runFileScannerT m d; runFileScannerT (f a) d
Applicative instance: 


instance (Functor m, Monad m) => Applicative (FilePrinterT m) where
  (<*>) = ap
  pure = return
Applicative instance: 


instance (Functor m, Monad m) => Applicative (FileScannerT m) where
  (<*>) = ap
  pure = return
Monad instance: 


instance Monad m => Monad (NullFsT m) where
  return a = NullFs $ \p ms -> return (a,p,ms)
  m >>= f = NullFs $ \p ms -> do (a,p',ms') <- runNullFsT m p ms; runNullFsT (f a) p' ms'
Applicative instance: 


instance (Functor m, Monad m) => Applicative (NullFsT m) where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chatty-0.7.0.0/Text/Chatty/Channel/Printer.hs
Monad instance: 


instance Monad m => Monad (ArchiverT c m) where
  return a = Archiver $ \s -> return (a,s)
  (Archiver r) >>= f = Archiver $ \s -> do (a,s') <- r s; runArchiverT' (f a) s'
Applicative instance: 


instance Monad m => Applicative (ArchiverT c m) where
  (<*>) = ap
  pure = return
Monad instance: 


instance Monad m => Monad (FilterT c m) where
  return a = Filter $ \(c,s) -> return (a,s)
  (Filter g) >>= f = Filter $ \(c,s) -> do (a,s') <- g (c,s); runFilterT (f a) (c,s')
Applicative instance: 


instance Monad m => Applicative (FilterT c m) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad m => Monad (JoinerT m) where
  return a = Joiner $ return a
  (Joiner j) >>= f = Joiner $ do a <- j; runJoinerT (f a)
Applicative instance: 


instance (Functor m, Monad m) => Applicative (JoinerT m) where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chatty-0.7.0.0/Text/Chatty/Expansion.hs
Monad instance: 


instance Monad m => Monad (NullExpanderT m) where
  return = NullExpander . return
  (NullExpander ne) >>= f = NullExpander $ do ne' <- ne; runNullExpanderT (f ne')
Applicative instance: 


instance (Functor m, Monad m) => Applicative (NullExpanderT m) where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chatty-0.7.0.0/Text/Chatty/Extended/ANSI.hs
Monad instance: 


instance Monad m => Monad (AnsiPrinterT m) where
  return a = AnsiPrinter $ \s -> return (a,s)
  (AnsiPrinter p) >>= f = AnsiPrinter $ \s -> do (a,s') <- p s; runAnsiPrinterT (f a) s'
Applicative instance: 


instance Monad m => Applicative (AnsiPrinterT m) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chatty-0.7.0.0/Text/Chatty/Extended/HTML.hs
Monad instance: 


instance Monad m => Monad (HtmlPrinterT m) where
  return = HtmlPrinter . return
  (HtmlPrinter p) >>= f = HtmlPrinter $ do p' <- p; runHtmlPrinterT (f p')
Applicative instance: 


instance (Functor m, Monad m) => Applicative (HtmlPrinterT m) where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chatty-0.7.0.0/Text/Chatty/Finalizer.hs
Monad instance: 


instance Monad m => Monad (HandleCloserT m) where
  return a = HandleCloser $ \hs -> return (a,hs)
  (HandleCloser m) >>= f = HandleCloser $ \hs -> do (a,hs') <- m hs; runHandleCloserT (f a) hs'
Applicative instance: 


instance Monad m => Applicative (HandleCloserT m) where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chatty-0.7.0.0/Text/Chatty/Scanner/Buffered.hs
Monad instance: 


instance Monad m => Monad (ScannerBufferT m) where
  return a = ScannerBuffer $ \s -> return (a,s)
  (ScannerBuffer c) >>= f = ScannerBuffer $ \s -> do (a,s') <- c s; runScannerBufferT (f a) s'
Applicative instance: 


instance Monad m => Applicative (ScannerBufferT m) where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chatty-0.7.0.0/Text/Chatty/Printer.hs
Monad instance: 


instance Monad m => Monad (DeafT m) where
  return = Deaf . return
  (Deaf d) >>= f = Deaf $ do d' <- d; runDeafT (f d')
Applicative instance: 


instance (Functor m, Monad m) => Applicative (DeafT m) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad m => Monad (OutRedirT m) where
  return a = OutRedir $ \h -> return a
  (OutRedir r) >>= f = OutRedir $ \h -> do a <- r h; runOutRedirT (f a) h
Applicative instance: 


instance Monad m => Applicative (OutRedirT m) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad m => Monad (RecorderT m) where
  return a = Recorder $ return (a,[])
  (Recorder r) >>= f = Recorder $ do
    (a,s) <- r
    (a',s') <- runRecorderT' (f a)
    return (a', s'++s)
Applicative instance: 


instance Monad m => Applicative (RecorderT m) where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chatty-0.7.0.0/Text/Chatty/Scanner.hs
Monad instance: 


instance Monad m => Monad (HereStringT m) where
  return a = HereString $ \s -> return (a,s)
  (HereString h) >>= f = HereString $ \s -> do (a,s') <- h s; runHereStringT (f a) s'
Applicative instance: 


instance Monad m => Applicative (HereStringT m) where
  (<*>) = ap
  pure = return
Monad instance: 


instance Monad m => Monad (QuietT m) where
  return = Quiet . return
  (Quiet q) >>= f = Quiet $ do q' <- q; runQuietT (f q')
Applicative instance: 


instance (Functor m, Monad m) => Applicative (QuietT m) where
  (<*>) = ap
  pure = return
Monad instance: 


instance Monad m => Monad (InRedirT m) where
  return a = InRedir $ \h -> return a
  (InRedir r) >>= f = InRedir $ \h -> do a <- r h; runInRedirT (f a) h
Applicative instance: 


instance Monad m => Applicative (InRedirT m) where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chatty-0.7.0.0/Text/Chatty/Expansion/Vars.hs
Monad instance: 


instance Monad m => Monad (ExpanderT m) where
  return a = Expander $ \vs -> return (a,vs)
  (Expander e) >>= f = Expander $ \vs -> do (a,vs') <- e vs; runExpanderT (f a) vs'
Applicative instance: 


instance Monad m => Applicative (ExpanderT m) where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chatty-0.7.0.0/Text/Chatty/Expansion/History.hs
Monad instance: 


instance Monad m => Monad (HistoryT m) where
  return a = History $ \s -> return (a,s)
  (History h) >>= f = History $ \s -> do (a,s') <- h s; runHistoryT (f a) s'
Applicative instance: 


instance Monad m => Applicative (HistoryT m) where
  (<*>) = ap
  pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/extensible-effects-1.9.2.2/src/Control/Monad/Free/Reflection.hs
Applicative instance: 

instance Functor f => P.Applicative (Free f) where
  pure = return
  (<*>) = ap
Monad instance: 

instance Functor f => Monad (Free f) where
  return = freePure
  mx >>= f = mx ^>>= tsingleton (Kleisli f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Control-Monad-MultiPass-0.1.0.0/src/Control/Monad/MultiPass.hs
Monad instance: 


instance Monad On where
  return x = On x
  On x >>= f = f x
Monad instance: 


instance Monad Off where
  return _ = Off
  Off >>= _ = Off
Monad instance: 


instance Monad (MultiPassBase r w tc) where
  return x = MultiPassBase $ return x

  MultiPassBase m >>= f =
    MultiPassBase $
    do x <- m
       unwrapMultiPassBase (f x)
Monad instance: 


instance Monad (MultiPass r w tc) where
  return x = MultiPass $ return x

  MultiPass m >>= f =
    MultiPass $
    do x <- m
       unwrapMultiPass (f x)
Monad instance: 


instance Monad (MultiPassPrologue r w tc) where
  return x = MultiPassPrologue $ return x

  MultiPassPrologue m >>= f =
    MultiPassPrologue $
    do x <- m
       unwrapMultiPassPrologue (f x)
Monad instance: 


instance Monad (MultiPassEpilogue r w tc) where
  return x = MultiPassEpilogue $ return x

  MultiPassEpilogue m >>= f =
    MultiPassEpilogue $
    do x <- m
       unwrapMultiPassEpilogue (f x)
Monad instance: 


instance Monad WrapInstrument where
  return x = WrapInstrument x
  WrapInstrument x >>= f = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/syntax-printer-1.0.0.0/Data/Syntax/Printer/Consumer.hs
Applicative instance: 


instance Monoid m => Applicative (Consumer m) where
    pure x = Consumer $ Right (mempty, x)
    f <*> x = Consumer $ bilift2 (flip (<>)) ($) <$> runConsumer f <*> runConsumer x
Monad instance: 


instance Monoid m => Monad (Consumer m) where
    return = pure
    m >>= f = Consumer $ do
        (m1, x) <- runConsumer m
        (m2, y) <- runConsumer (f x)
        return (m2 <> m1, y)
    fail = Consumer . Left
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/optional-args-1.0.1/src/Data/Optional.hs
Applicative instance: 


instance Applicative Optional where
    pure = Specific

    Specific f <*> Specific x = Specific (f x)
    _          <*> _          = Default
Monad instance: 


instance Monad Optional where
    return = Specific

    Default    >>= _ = Default
    Specific x >>= f = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/drClickOn-0.1/Control/MonadicFRP.hs
Monad instance: 


instance Monad (React e) where
  return              = Done
  (Await e c)  >>= f  = Await e ((>>= f) . c)
  (Done v)     >>= f  = f v
Monad instance: 


instance Monad (Sig e a) where
  return a = emitAll (End a)
  (Sig l) >>= f = Sig (l >>= ib)
   where  ib (h :| t)  = return (h :| (t >>= f))
          ib (End a)   = let Sig x = f a in x
Monad instance: 


instance Monad (ISig e a) where
  return = End
  (End a)   >>= f = f a
  (h :| t)  >>= f = h :| (t >>= emitAll . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wai-routing-0.9.1/src/Network/Wai/Routing/Route.hs
Applicative instance: 


instance Applicative (Routes a m) where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad (Routes a m) where
    return  = Routes . return
    m >>= f = Routes $ _unroutes m >>= _unroutes . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tempus-0.1.0/Tempus/Lexer.hs
Monad instance: 


instance Monad Parser where
    return a = Parser $ \_ _   -> Right a
    p >>= f  = Parser $ \s loc -> case runParser p s loc of
                                      Left e  -> Left e
                                      Right a -> runParser (f a) s loc
    fail s   = Parser $ \_ loc -> Left $ Loc loc s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/for-free-0.1/Control/ForFree.hs
Applicative instance: 


  instance Functor f => Applicative (Free f) where {
    pure = Pure;
    Pure a <*> Pure b = Pure (a b);
    Pure a <*> Free b = Free (fmap a <$> b);
    Free a <*> b = Free ((<*> b) <$> a);
  };
Monad instance: 


  instance Functor f => Monad (Free f) where {
    return = Pure;
    Pure a >>= f = f a;
    Free m >>= f = Free ((>>= f) <$> m);
  };
Applicative instance: 


  instance Applicative f => Applicative (Cofree f) where {
    pure x = x :< pure (pure x);
    (f :< fs) <*> (a :< as) = f a :< ((<*>) <$> fs <*> as);
    (f :< fs) <* (_ :< as) = f :< ((<*) <$> fs <*> as);
    (_ :< fs) *> (a :< as) = a :< ((*>) <$> fs <*> as);
  };
Monad instance: 


  instance (Functor f, Monad m) => Monad (FreeT f m) where {
    return = FreeT . return . Left;
    FreeT m >>= f = FreeT (m >>= either (runFreeT . f) (return . Right . fmap (>>= f)));
  };
Applicative instance: 

  -- {-# RULES "join=joinFreeT" join = joinFreeT #-};

  instance (Functor f, Applicative m, Monad m) => Applicative (FreeT f m) where {
    pure = return;
    (<*>) = ap;
  };
Monad instance: 


  instance Monad (Codensity f) where {
    return x = Codensity ($ x);
    m >>= k = Codensity (\c -> runCodensity m (\a -> runCodensity (k a) c));
  };
Applicative instance: 


  instance Applicative (Codensity f) where {
    pure x = Codensity ($ x);
    (<*>) = ap;
  };
Applicative instance: 


  instance Applicative f => Applicative (Density f) where {
    pure x = Density (const x) (pure ());
    Density f x <*> Density a y = Density (\k -> f (fst <$> k) (a (snd <$> k))) (liftA2 (,) x y);
  };
Monad instance: 


  instance Monad (CodensityAskT w m) where {
    return x = CodensityAskT (\_ f -> f x);
    CodensityAskT m >>= f = CodensityAskT (\q k -> m q (\a -> runCodensityAskT (f a) q k));
  };
Applicative instance: 


  instance Applicative (CodensityAskT w f) where {
    pure = return;
    (<*>) = ap;
  };
Monad instance: 


  instance Monad (CodensityAsk w) where {
    return x = CodensityAsk (\_ f -> f x);
    CodensityAsk m >>= f = CodensityAsk (\q k -> m q (\a -> runCodensityAsk (f a) q k));
  };
Applicative instance: 


  instance Applicative (CodensityAsk w) where {
    pure = return;
    (<*>) = ap;
  };
Applicative instance: 


  instance Comonad w => Applicative (CoT w m) where {
    pure x = CoT (flip extract x);
    f <*> x = f >>= flip fmap x;
  };
Monad instance: 


  instance Comonad w => Monad (CoT w m) where {
    return x = CoT (flip extract x);
    CoT k >>= f = CoT (k . extend (\w a -> runCoT (f a) w))
  };
Applicative instance: 


  instance Applicative Finalize where {
    pure _ = Finalize;
    Finalize <*> Finalize = Finalize;
  };
Monad instance: 


  instance Monad Finalize where {
    return _ = Finalize;
    Finalize >>= _ = Finalize;
  };
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/streaming-bytestring-0.1.4.4/Data/ByteString/Streaming/Internal.hs
Applicative instance: 


instance Monad m => Applicative (ByteString m) where
  pure = Empty
  (<*>) = ap
Monad instance: 


instance Monad m => Monad (ByteString m) where
  return = Empty
  {-#INLINE return #-}
  x0 >> y = loop SPEC x0 where
    loop !_ x = case x of   -- this seems to be insanely effective
      Empty _ -> y
      Chunk a b -> Chunk a (loop SPEC b)
      Go m -> Go (liftM (loop SPEC) m)
  {-#INLINEABLE (>>)#-}
  x >>= f =
    -- case x of
    --   Empty a -> f a
    --   Chunk bs bss -> Chunk bs (bss >>= f)
    --   Go mbss      -> Go (liftM (>>= f) mbss)
    loop SPEC2 x where -- unlike >> this SPEC seems pointless 
      loop !_ y = case y of
        Empty a -> f a
        Chunk bs bss -> Chunk bs (loop SPEC bss)
        Go mbss      -> Go (liftM (loop SPEC) mbss)
  {-#INLINEABLE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/servant-ede-0.5.1/src/Servant/EDE/Internal/Validate.hs
Applicative instance: 


instance Semigroup e => Applicative (Validated e) where
  pure x = OK x

  OK f    <*> OK x     = OK (f x)
  OK _    <*> NotOK e  = NotOK e
  NotOK e <*> OK _     = NotOK e
  NotOK e <*> NotOK e' = NotOK (e <> e')
Applicative instance: 


instance (Applicative m, Semigroup e) => Applicative (ValidateT e m) where
  pure = VT . pure . pure

  VT f <*> VT x = VT . getCompose $ Compose f <*> Compose x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/derive-gadt-0.1.1/lib/Language/Haskell/Derive/Gadt/Unify.hs
Monad instance: 

instance Monad Q where
  return a = Q (return a)
  Q io >>= k = Q (runQ . k =<< io)
Applicative instance: 

instance Applicative Q where
  pure = return
  (<*>) = ap
Monad instance: 

instance Monad (S s) where
  return a = S (\k -> k a)
  S g >>= f = S (\k -> g (\a -> unS (f a) k))
Applicative instance: 

instance Applicative (S s) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/stable-heap-0.1.0.0/src/Data/Heap/Stable.hs
Applicative instance: 


-- | Same semantics as @WriterT k []@
instance (Monoid k, Ord k) => Applicative (Heap k) where
  pure = singleton mempty
  Empty <*> _ = Empty
  _ <*> Empty = Empty
  (Heap fl fls fk f frs fr) <*> xs
    =  (fl  <*>         xs)
    <> (fls <*>         xs)
    <> (bimap (fk <>) f xs)
    <> (frs <*>         xs)
    <> (fr  <*>         xs)
Monad instance: 


-- | Same semantics as @WriterT k []@
instance (Monoid k, Ord k) => Monad (Heap k) where
  return = pure
  Empty >>= _ = Empty
  Heap xl xls xk x xrs xr >>= f
    =  (xl  >>= f)
    <> (xls >>= f)
    <> (mapKeys (xk <>) (f x))
    <> (xrs >>= f)
    <> (xr  >>= f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tubes-2.1.1.0/Tubes/Source.hs
Applicative instance: 


instance Monad m => Applicative (Source m) where
    pure x = Source $ yield x

    srcF <*> srcA = Source $
        for (sample srcF) $ \f ->
            for (sample srcA) $ \a ->
                yield (f a)
Monad instance: 


instance (Monad m) => Monad (Source m) where
    return = pure
    ma >>= f = Source $ for (sample ma) $ \a -> sample (f a)
    fail _ = mzero
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/constrained-normal-1.0.2/Control/Monad/ConstrainedNormal.hs
Applicative instance: 


instance Applicative (NM c t) where
  pure :: a -> NM c t a
  pure = return

  (<*>) :: NM c t (a -> b) -> NM c t a -> NM c t b
  (<*>) = ap
Monad instance: 


instance Monad (NM c t) where
  return :: a -> NM c t a
  return = Return

  (>>=) :: NM c t a -> (a -> NM c t b) -> NM c t b
  (Return a)   >>= k  = k a                         -- left-identity law
  (Bind ta h)  >>= k  = Bind ta (\ a -> h a >>= k)
Applicative instance: 


instance Applicative (NMP c t) where
  pure :: a -> NMP c t a
  pure = return

  (<*>) :: NMP c t (a -> b) -> NMP c t a -> NMP c t b
  (<*>) = ap
Monad instance: 
 -- right-unit law

instance Monad (NMP c t) where
  return :: a -> NMP c t a
  return a = toNMP (MPReturn a)

  (>>=) :: NMP c t a -> (a -> NMP c t b) -> NMP c t b
  MZero         >>= _  = MZero                             -- left-zero law
  MPlus n1 n2   >>= k  = mplus (bindNMP' n1 k) (n2 >>= k)
Applicative instance: 


instance Applicative (NAF c t) where
  pure :: a -> NAF c t a
  pure = Pure

  (<*>) :: NAF c t (a -> b) -> NAF c t a -> NAF c t b
  (Pure g) <*> (Pure a)  = Pure (g a)                  -- homomorphism law
  n1 <*> (Pure a)    = Pure (\ g -> g a) <*> n1        -- interchange law
  n1 <*> (Ap n2 tx)  = Ap (Pure (.) <*> n1 <*> n2) tx
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/resumable-exceptions-0.0.0.20100920/Control/Monad/Resumable.hs
Monad instance: 


instance Monad m => Monad (ResumableT scope req res m) where
  return = lift . return
  ResumableT m >>= f = ResumableT $
    m >>= either (return . Left . Arrow.second (f <=<)) (unResumableT . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/flite-0.1.2/Flite/WriterState.hs
Monad instance: 


instance Monad (WriterState w s) where
  return a = WS $ \s -> (s, [], a)
  m >>= f = WS $ \s -> let (s0, w0, a) = runWS m s
                           (s1, w1, b) = runWS (f a) s0
                       in  (s1, w0 ++ w1, b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/flite-0.1.2/Flite/State.hs
Monad instance: 


instance Monad (State s) where
  return a = S (\s -> (s, a))
  m >>= f = S (\s -> case runState m s of
                       (s', a) -> runState (f a) s')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/flite-0.1.2/Flite/Parsec/Parse.hs
Applicative instance: 


        instance Applicative (GenParser s a) where
            pure  = return
            (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/flite-0.1.2/Flite/Identity.hs
Monad instance: 


instance Monad Identity where
  return a = I a
  I a >>= f = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/flite-0.1.2/Flite/Writer.hs
Monad instance: 


instance Monad (Writer w) where
  return a = W [] a
  W w0 a0 >>= f = case f a0 of W w1 a1 -> W (w0 ++ w1) a1
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/flite-0.1.2/Flite/Predex.hs
Monad instance: 


instance Monad Count where
  return a = Count $ \n -> (n, a)
  x >>= f = Count $ \n -> case runCount x n of (m, y) -> runCount (f y) m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/flite-0.1.2/Flite/Fresh.hs
Monad instance: 


instance Monad Fresh where
  return a = Fresh (\s i -> (i, a))
  m >>= f  = Fresh (\s i -> case runFresh m s i of
                              (j, a) -> runFresh (f a) s j)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/idris-0.9.9.3/src/Idris/AbsSyntax.hs
Monad instance: 


instance Monad (EitherErr a) where
    return = RightOK

    (LeftErr e) >>= k = LeftErr e
    RightOK v   >>= k = k v
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/idris-0.9.9.3/src/Core/TT.hs
Monad instance: 


-- at some point, this instance should also carry type checking options
-- (e.g. Type:Type)

instance Monad TC where
    return = OK
    x >>= k = case x of
                OK v -> k v
                Error e -> Error e
    fail e = Error (InternalMsg e)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/profunctors-5.2/src/Data/Profunctor/Traversing.hs
Applicative instance: 


instance Applicative (Bazaar a b) where
  pure a = Bazaar $ \_ -> pure a
  mf <*> ma = Bazaar $ \k -> runBazaar mf k <*> runBazaar ma k
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/profunctors-5.2/src/Data/Profunctor/Types.hs
Applicative instance: 


instance Applicative f => Applicative (Star f a) where
  pure a = Star $ \_ -> pure a
  Star ff <*> Star fx = Star $ \a -> ff a <*> fx a
  Star ff  *> Star fx = Star $ \a -> ff a  *> fx a
  Star ff <*  Star fx = Star $ \a -> ff a <*  fx a
Monad instance: 


instance Monad f => Monad (Star f a) where
#if __GLASGOW_HASKELL__ < 710
  return a = Star $ \_ -> return a
#endif
  Star m >>= f = Star $ \ e -> do
    a <- m e
    runStar (f a) e
Applicative instance: 


instance Applicative (Costar f a) where
  pure a = Costar $ \_ -> a
  Costar ff <*> Costar fx = Costar $ \a -> ff a (fx a)
  _ *> m = m
  m <* _ = m
Monad instance: 


instance Monad (Costar f a) where
  return = pure
  Costar m >>= f = Costar $ \ x -> runCostar (f (m x)) x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/profunctors-5.2/src/Data/Profunctor/Closed.hs
Applicative instance: 


instance (Profunctor p, Arrow p) => Applicative (Closure p a) where
  pure x = arr (const x)
  f <*> g = arr (uncurry id) . (f &&& g)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/profunctors-5.2/src/Data/Profunctor/Strong.hs
Applicative instance: 


instance (Profunctor p, Arrow p) => Applicative (Tambara p a) where
  pure x = arr (const x)
  f <*> g = arr (uncurry id) . (f &&& g)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/profunctors-5.2/src/Data/Profunctor/Rep.hs
Applicative instance: 


instance (Applicative (Rep p), Representable p) => Applicative (Prep p) where
  pure a = Prep () $ tabulate $ const $ pure a
  Prep xf pf <*> Prep xa pa = Prep (xf,xa) (tabulate go) where
    go (xf',xa') = sieve pf xf' <*> sieve pa xa'
Monad instance: 


instance (Monad (Rep p), Representable p) => Monad (Prep p) where
  return a = Prep () $ tabulate $ const $ return a
  Prep xa pa >>= f = Prep xa $ tabulate $ \xa' -> sieve pa xa' >>= \a -> case f a of
    Prep xb pb -> sieve pb xb
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/smtlib2-0.3.1/Language/SMTLib2/Internals.hs
Monad instance: 


instance Monad m => Monad (SMT' m) where
  return x = SMT $ \b -> return (x,b)
  (SMT f) >>= g = SMT $ \b -> do
    (r,b1) <- f b
    case g r of
     SMT act -> act b1
Applicative instance: 


instance (Monad m,Functor m) => Applicative (SMT' m) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lucid-2.9.6/src/Lucid/Base.hs
Applicative instance: 


-- | Based on the monad instance.
instance Monad m => Applicative (HtmlT m) where
  pure = return
  (<*>) = ap
Monad instance: 


-- | Basically acts like Writer.
instance Monad m => Monad (HtmlT m) where
  return a = HtmlT (return (mempty,a))
  m >>= f =
    HtmlT (do ~(g,a) <- runHtmlT m
              ~(h,b) <- runHtmlT (f a)
              return (g <> h,b))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/decimal-arithmetic-0.4.0.0/src/Numeric/Decimal/Arithmetic.hs
Applicative instance: 


instance Applicative (Arith p r) where
  pure = Arith . pure
  Arith f <*> Arith e = Arith (f <*> e)
Monad instance: 


instance Monad (Arith p r) where
  Arith e >>= f = Arith (e >>= g)
    where g x = let Arith t = f x in t
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/accuerr-0.2.0.2/lib/Accuerr.hs
Applicative instance: 


instance Semigroup e => Applicative (Accuerr e) where
  pure = AccSuccess
  AccFailure e1 <*> AccFailure e2 = AccFailure (e1 <> e2)
  AccFailure e1 <*> AccSuccess _ = AccFailure e1
  AccSuccess _ <*> AccFailure e2 = AccFailure e2
  AccSuccess f <*> AccSuccess a = AccSuccess (f a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/type-combinators-0.2.4.3/src/Data/Type/Combinator.hs
Applicative instance: 


instance Applicative I where
  pure = I
  I f <*> I a = I $ f a
Monad instance: 


instance Monad I where
  I a >>= f = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/type-combinators-0.2.4.3/src/Data/Type/Vector.hs
Applicative instance: 


instance (Applicative f, Known Nat n) => Applicative (VecT n f) where
  pure  = vrep . pure
  (<*>) = vap (<*>)
Monad instance: 


instance (Monad f, Known Nat n) => Monad (VecT n f) where
  v >>= f = imap (\x -> (>>= index x . f)) v
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/QIO-1.2/QIO/Qio.hs
Monad instance: 


-- | Prob forms a Monad
instance Monad Prob where
    return = Prob . return
    (Prob ps) >>= f = Prob (ps >>= unProb . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/QIO-1.2/QIO/QioSyn.hs
Monad instance: 



-- | The "QIO" type forms a Monad
instance Monad QIO where
    return = QReturn
    (QReturn a) >>= f = f a
    (MkQbit b g) >>= f = MkQbit b (\ x -> g x >>= f)
    (ApplyU u q) >>= f = ApplyU u (q >>= f)
    (Meas x g) >>= f = Meas x (\ b -> g b >>= f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/QIO-1.2/QIO/VecEq.hs
Monad instance: 


-- | We can define an AsMonad over an EqMonad, as a Monad
instance EqMonad m => Monad (AsMonad m) where
   return = Return
   (>>=) = Bind
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/QIO-1.2/QIO/Vec.hs
Monad instance: 


-- | Vectors, over Numeric types, can be defined as a Monad.
instance Num n => Monad (Vec n) where
    return a = Vec [(a,1)]
    (Vec ms) >>= f = Vec [(b,i*j) | (a,i) <- ms, (b,j) <- unVec (f a)]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cmonad-0.1.1.1/src/Language/CMonad/Prim.hs
Monad instance: 


-- |r-values form a monad.
instance (Monad m) => Monad (E' RValue m) where
    {-# INLINE return #-}
    return x = E $ return x
    {-# INLINE (>>=) #-}
    x >>= f = E $ do
        x' <- runE x
        runE (f x')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lhc-0.8/lhc-pkg/Main.hs
Monad instance: 


instance Monad Validate where
   return a = V $ return (a, [])
   m >>= k = V $ do
      (a, es) <- runValidate m
      (b, es') <- runValidate (k a)
      return (b,es++es')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bustle-0.5.4/Bustle/Renderer.hs
Applicative instance: 


instance Applicative Renderer where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/compdata-0.9/src/Data/Comp/Term.hs
Applicative instance: 


instance Functor f => Applicative (Context f) where
    pure = Hole
    (<*>) = ap
Monad instance: 


instance (Functor f) => Monad (Context f) where
    return = Hole
    m >>= f = run m
        where run (Hole v) = f v
              run (Term t) = Term (fmap run t)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Tainted-0.1.0.2/src/Control/Monad/Trans/Tainted.hs
Applicative instance: 


instance (Monad m, Functor m) => Applicative (TaintedT m) where
    pure = return
    (<*>) = ap
Monad instance: 



instance Monad m => Monad (TaintedT m) where
    return = TaintedT . return . return
    TaintedT x >>= f = TaintedT $ do
        res <- x
        case res of
            Clean v -> runTainted $ f v
            Dirty t -> do
                    -- Ensure Dirty stays Dirty
                    res <- runTainted $ f t
                    return $ case res of
                        Clean u -> Dirty u
                        d       -> d
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Tainted-0.1.0.2/src/Data/Tainted.hs
Applicative instance: 



-- Proof of correctness comes from Monad correctness
instance Applicative Tainted where
    pure = return
    (<*>) = ap
Monad instance: 


-- Left Identity Law:
--
-- (return x) >>= f = Clean f x  ≡ f x
--
-- Right Identity Law:
--
-- m >>= return ≡ m 
--
-- proof is in definition of the Clean case below for (>>=)
--
-- Associativity Law:
--
-- Case of m being Clean :
-- 
-- LHS: (Clean a >>= f) >>= g = f a >>= g 
-- RHS: Clean a >>= (\x -> f x >>= g) =  f a >>= g
-- LHS = RHS
--
-- Case of m being Dirty:
--
-- LHS: (Dirty a >>= f) >>= g = 
--      g =<< case f a of 
--          (Clean y) -> Dirty y
--          y         -> y
--
-- RHS: Dirty a >>= (\x -> f x >>= g) = 
--      g =<< case f a of
--          (Clean y) -> Dirty y
--          y         -> y    
-- LHS = RHS
instance Monad Tainted where
    return = Clean
    Dirty x  >>= f = case f x of
                        (Clean y) -> Dirty y
                        y -> y
    Clean x  >>= f = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/franchise-0.0.6/Distribution/Franchise/ConfigureState.hs
Monad instance: 


instance Monad C where
    (C f) >>= g = C $ \cs ->
        do macs' <- f cs
           case macs' of
             Left e -> return (Left e)
             Right (a,cs') -> unC (g a) cs'
                              `catch` \err -> return (Left $ Err (show err) $ packageModuleMap cs')
    return x = C (\cs -> return $ Right (x, cs))
    fail e = do putV $ "failure: "++ e
                C (\ts -> return $ Left $ Err e (packageModuleMap ts))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/music-score-1.9.0/src/Data/PairMonad.hs
Monad instance: 


-- Equivalent to the Monad Writer instance.
instance Monoid o => Monad ((,) o) where
  return      = pure
  (o,a) >>= f = (o `mappend` o', a') where (o',a') = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/music-score-1.9.0/src/Data/Semigroup/Instances.hs
Applicative instance: 

instance Applicative Product where
  pure = Product
  Product f <*> Product x = Product (f x)
Applicative instance: 

instance Applicative Sum where
  pure = Sum
  Sum f <*> Sum x = Sum (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/music-score-1.9.0/src/Data/Functor/Context.hs
Applicative instance: 


instance Applicative Ctxt where
  pure x = Ctxt (Nothing, x, Nothing)
  Ctxt (b,x,a) <*> Ctxt (b',x',a') = Ctxt (b <*> b', x x', a <*> a')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/music-score-1.9.0/src/Music/Time/Voice.hs
Applicative instance: 


-- A voice is a list of events with explicit duration. Events can not overlap.
--
-- Voice is a 'Monoid' under sequential composition. 'mempty' is the empty part and 'mappend'
-- appends parts.

--
-- Voice is a 'Monad'. 'return' creates a part containing a single value of duration
-- one, and '>>=' transforms the values of a part, allowing the addition and
-- removal of values under relative duration. Perhaps more intuitively, 'join' scales
-- each inner part to the duration of the outer part, then removes the
-- intermediate structure.

instance Applicative Voice where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad Voice where
  return = view _Unwrapped . return . return
  xs >>= f = view _Unwrapped $ (view _Wrapped . f) `mbind` view _Wrapped xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/music-score-1.9.0/src/Music/Time/Event.hs
Monad instance: 

  -- TODO
instance (Functor f, Monad f, Monad g, Traversable g) => Monad (Compose f g) where
  return = Compose . return . return
  xs >>= f = Compose $ mbind (getCompose . f) (getCompose xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/music-score-1.9.0/src/Music/Time/Track.hs
Applicative instance: 


instance Applicative Track where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad Track where
  return = view _Unwrapped . return . return
  xs >>= f = view _Unwrapped $ (view _Wrapped . f) `mbind` view _Wrapped xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/music-score-1.9.0/src/Music/Time/Reactive.hs
Applicative instance: 

instance Applicative Reactive where
    pure  = pureDefault
      where
        pureDefault = view _Unwrapped . pure . pure

    (<*>) = apDefault
      where
        (view _Wrapped -> (tf, rf)) `apDefault` (view _Wrapped -> (tx, rx)) = view _Unwrapped (tf <> tx, rf <*> rx)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/music-score-1.9.0/src/Music/Time/Score.hs
Applicative instance: 


instance Applicative Score where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Score where
  return = (^. _Unwrapped') . return . return
  xs >>= f = (^. _Unwrapped') $ mbind ((^. _Wrapped') . f) ((^. _Wrapped') xs)
Applicative instance: 


instance Applicative Score' where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad Score' where
  return = (^. _Unwrapped) . pure . pure
  xs >>= f = (^. _Unwrapped) $ mbind ((^. _Wrapped') . f) ((^. _Wrapped') xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/copilot-core-2.2.0/src/Copilot/Core/Random/Gen.hs
Applicative instance: 


instance Applicative Gen where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Gen where
  return x = MkGen (\ _ _ _ -> x)
  MkGen m >>= k = MkGen $ \ d ws r ->
    let (r1, r2) = split r       in
    let MkGen m' = k (m d ws r1) in
    m' d ws r2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/polysoup-0.6.2/src/Text/XML/PolySoup/Parser.hs
Applicative instance: 


instance Applicative (P a) where
    pure x = P $ Just . (x,)
    P p <*> P q = P $ \t0 -> do
        (f, t1) <- p t0
        (x, t2) <- q t1
        return (f x, t2)
Monad instance: 


instance Monad (P a) where
    return = pure
    P p >>= f = P $ \t0 -> do
        (x, t1) <- p t0
        runP (f x) t1
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/polysoup-0.6.2/src/Text/XML/PolySoup/Predicate.hs
Applicative instance: 


instance Applicative (Q a) where
    pure = Q . const . Just
    Q f <*> Q p = Q $ \x -> f x <*> p x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rtorrent-rpc-0.2.2.0/Network/RTorrent/Action/Internals.hs
Applicative instance: 


instance Applicative (ActionB i) where
    pure a = ActionB $ Action [] (const (pure a))

    (ActionB a) <*> (ActionB b) = ActionB $ \tid -> let
        parse :: (Monad m, Applicative m) => (Value -> m (a -> b)) -> (Value -> m a) -> Value -> m b
        parse parseA parseB arr = do
            (valsA, valsB) <- splitAt len <$> getArray arr
            parseA (ValueArray valsA)
              <*> parseB (ValueArray valsB)
        len = length cmdsA
        Action cmdsA pA _ = a tid
        Action cmdsB pB _ = b tid
      in Action (cmdsA ++ cmdsB) (parse pA pB) tid
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fraxl-0.1.0.0/src/Control/Applicative/Fraxl/Free.hs
Applicative instance: 


instance Applicative (Ap f) where
  pure a = Ap (\k f -> k (`f` a))
  x <*> y = Ap (\k f -> unAp y (unAp x k) (\s a g -> f s (g a)))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fraxl-0.1.0.0/src/Control/Monad/Trans/Fraxl/Free.hs
Applicative instance: 


instance (Applicative f, Monad m) => Applicative (FreeT f m) where
  pure = freePure
  {-# INLINE pure #-}
  FreeT f <*> FreeT a = FreeT $ g <$> f <*> a where
    g :: FreeF f m (a -> b) -> FreeF f m a -> FreeF f m b
    g (Pure f') a' = fmap f' a'
    g (Free b kf) (Pure a') = Free b (fmap ($ a') >.< kf)
    g (Free b kf) (Free c ka) = Free (f' <$> b <*> c) (tsingleton (Kleisli id))
      where f' b' c' = runKleisli (qApp kf) b' <*> runKleisli (qApp ka) c'
  {-# INLINE (<*>) #-}
Monad instance: 


instance (Applicative f, Monad m) => Monad (FreeT f m) where
  FreeT ma >>= k = FreeT $ do
    freef <- ma
    case freef of
      Pure a -> runFreeT (k a)
      Free b k' -> return $ Free b (k' |> Kleisli k)
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rsagl-math-0.6.0.1/RSAGL/Math/Curve.hs
Applicative instance: 


instance Applicative Curve where
    pure a = Curve $ const a
    f <*> a = zipCurve ($) f a
Applicative instance: 


instance Applicative Surface where
    pure a = surface (const $ const a)
    f <*> a = zipSurface ($) f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/alpha-1.0.9/src/My/Control/Monad/RWTL.hs
Monad instance: 


instance Monoid w => Monad (RWTL r w p f) where
  tl >>= cc = RWTL tl'
    where tl' r p f = (p'',f'',b,w`mappend`w')
            where (p',f'',a,w) = runRWTL tl r p f'
                  (p'',f',b,w') = runRWTL (cc a) r p' f
  return a = RWTL (\r p f -> (p,f,a,mempty))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mage-1.1.0/src/RandT.hs
Monad instance: 


instance (Monad m) => Monad (RandT m) where
  return a = RandT $ return a
  (RandT m) >>= k = RandT $ m >>= (derand . k)
  fail str = RandT $ fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/foundation-0.0.1/Foundation/Internal/MonadTrans.hs
Applicative instance: 

instance Monad m => Applicative (State s m) where
    pure a = State $ \st -> return (a,st)
    fab <*> fa = State $ \s1 -> do
        (a,s2)  <- runState fa s1
        (ab,s3) <- runState fab s2
        return (ab a, s3)
Monad instance: 

instance Monad m => Monad (State r m) where
    return a = State $ \st -> return (a,st)
    ma >>= mb = State $ \s1 -> do
        (a,s2) <- runState ma s1
        runState (mb a) s2
Applicative instance: 

instance Monad m => Applicative (Reader r m) where
    pure a = Reader $ \_ -> return a
    fab <*> fa = Reader $ \r -> do
        a  <- runReader fa r
        ab <- runReader fab r
        return $ ab a
Monad instance: 

instance Monad m => Monad (Reader r m) where
    return a = Reader $ \_ -> return a
    ma >>= mb = Reader $ \r -> do
        a <- runReader ma r
        runReader (mb a) r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/flow2dot-0.9.0.3/Text/Dot.hs
Monad instance: 


instance Monad Dot where
  return a = Dot $ \ uq -> ([],uq,a)
  m >>= k  = Dot $ \ uq -> case unDot m uq of
                           (g1,uq',r) -> case unDot (k r) uq' of
                                           (g2,uq2,r2) -> (g1 ++ g2,uq2,r2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unique-logic-tf-0.4.1.2/src/UniqueLogic/ST/TF/System.hs
Applicative instance: 


instance Applicative (T w s) where
   pure = Cons . return
   (<*>) = ap
Monad instance: 


instance Monad (T w s) where
   return = Cons . return
   Cons x >>= k  = Cons $ run . k =<< x
Applicative instance: 


instance Applicative (Apply w s) where
   pure a = Apply $ pure a
   Apply f <*> Apply a = Apply $ f <*> a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unique-logic-tf-0.4.1.2/src/UniqueLogic/ST/TF/Expression.hs
Applicative instance: 


instance Applicative (Apply w s) where
   pure a = Apply $ return a
   Apply f <*> Apply a = Apply $ ap f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unique-logic-tf-0.4.1.2/src/UniqueLogic/ST/TF/Example/Verify.hs
Applicative instance: 


instance (Monad m) => Applicative (Track m) where
   pure = return
   (<*>) = ap
Monad instance: 


instance (Monad m) => Monad (Track m) where
   return = Track . UMT.point
   x >>= k  =  Track $ UMT.bind (runTrack x) (runTrack . k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unique-logic-tf-0.4.1.2/src/UniqueLogic/ST/TF/MonadTrans.hs
Applicative instance: 


instance (C t, Monad m) => Applicative (Wrap t m) where
   pure = return
   (<*>) = ap
Monad instance: 


instance (C t, Monad m) => Monad (Wrap t m) where
   return = wrap . point
   x >>= k  =  wrap $ bind (unwrap x) (unwrap . k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hobbits-1.2.3/Data/Binding/Hobbits/Mb.hs
Applicative instance: 


instance TypeCtx ctx => Applicative (Mb ctx) where
    pure x = nuMulti typeCtxProxies (const x)
    (<*>) = mbApply
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/deka-0.6.0.2/internal/Deka/Internal/Context.hs
Applicative instance: 


instance Applicative Ctx where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad Ctx where
  return a = Ctx $ \_ -> return a
  Ctx a >>= f = Ctx $ \p -> do
    r1 <- a p
    let b = unCtx $ f r1
    b p
  fail s = Ctx $ \_ -> fail s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/countable-1.0/src/Data/Expression.hs
Applicative instance: 


    instance (Applicative f, Functor g) => Applicative (Expression a g f) where
    {
        pure t = ClosedExpression (pure t);
        (ClosedExpression fpq) <*> ep = ffmap fpq ep;
        (OpenExpression a egpq) <*> ep = OpenExpression a ((\p -> fmap (\pq -> pq p)) <$> ep <*> egpq);
    };
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/thrist-0.3.0.2/Data/Thrist/List.hs
Applicative instance: 


instance Applicative List' where
  pure = return
  (<*>) = undefined
Monad instance: 
 -- TODO

instance Monad List' where
  return a = List' $ Cons (El a) Nil
  List' a >>= f = undefined
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ideas-1.5/src/Ideas/Encoding/Encoder.hs
Monad instance: 


instance Monad (Encoder a s) where
   return a = Enc $ \_ _ -> return a
   fail s   = Enc $ \_ _ -> fail s
   p >>= f  = Enc $ \xs s -> do
      a <- runEnc p xs s
      runEnc (f a) xs s
Applicative instance: 


instance Applicative (Encoder a s) where
   pure  = return
   (<*>) = liftM2 ($)
Monad instance: 


instance Monad (Decoder a s) where
   return a = Dec $ \_ s -> return (a, s)
   fail s   = Dec $ \_ _ -> fail s
   p >>= f  = Dec $ \xs s1 -> do
      (a, s2) <- runDec p xs s1
      runDec (f a) xs s2
Applicative instance: 


instance Applicative (Decoder a s) where
   pure  = return
   (<*>) = liftM2 ($)
Applicative instance: 


instance Applicative Error where
   pure  = return
   (<*>) = ap
Monad instance: 


instance Monad Error where
   fail    = Error . Left
   return  = Error . Right
   m >>= f = Error $ either Left (runError . f) (runError m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ideas-1.5/src/Ideas/Common/CyclicTree.hs
Applicative instance: 


instance Applicative (CyclicTree d) where
   pure    = leaf
   p <*> q = fold idAlg {fLeaf = (`fmap` q)} p
Monad instance: 


instance Monad (CyclicTree d) where
   return = leaf
   (>>=)  = flip replaceLeaf
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ideas-1.5/src/Ideas/Common/Algebra/Boolean.hs
Applicative instance: 


instance Applicative And where
   pure            = And
   And f <*> And a = And (f a)
Applicative instance: 


instance Applicative Or where
   pure          = Or
   Or f <*> Or a = Or (f a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ideas-1.5/src/Ideas/Common/Algebra/Field.hs
Applicative instance: 


instance A.Applicative Additive where
   pure = Additive
   Additive f <*> Additive a = Additive (f a)
Applicative instance: 


instance A.Applicative Multiplicative where
   pure = Multiplicative
   Multiplicative f <*> Multiplicative a = Multiplicative (f a)
Applicative instance: 


instance Applicative.Applicative SafeNum where
   pure  = return
   (<*>) = ap
Monad instance: 


instance Monad SafeNum where
   return  = Ok
   fail    = Exception
   m >>= f = either Exception f (safeNum m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ideas-1.5/src/Ideas/Common/Algebra/SmartGroup.hs
Applicative instance: 


instance Applicative Smart where
   pure = Smart
   Smart f <*> Smart a = Smart (f a)
Applicative instance: 


instance Applicative SmartZero where
   pure = SmartZero
   SmartZero f <*> SmartZero a = SmartZero (f a)
Applicative instance: 


instance Applicative SmartGroup where
   pure = SmartGroup
   SmartGroup f <*> SmartGroup a = SmartGroup (f a)
Applicative instance: 


instance Applicative SmartField where
   pure = SmartField
   SmartField f <*> SmartField a = SmartField (f a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ideas-1.5/src/Ideas/Common/Rule/EnvironmentMonad.hs
Applicative instance: 


instance Applicative EnvMonad where
   pure  = return
   (<*>) = ap
Monad instance: 


instance Monad EnvMonad where
   return = Return
   (>>=)  = Bind
   fail   = Fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wumpus-drawing-0.9.0/src/Wumpus/Drawing/Paths/PathBuilder.hs
Applicative instance: 



-- Applicative

instance Applicative (GenPathSpec st u) where
  pure a    = GenPathSpec $ \_   s -> (a, s, mempty)
  mf <*> ma = GenPathSpec $ \ctx s ->
                let (f,s1,w1) = getGenPathSpec mf ctx s
                    (a,s2,w2) = getGenPathSpec ma ctx s1
                in (f a, s2, w1 `mappend` w2)
Monad instance: 



-- Monad

instance Monad (GenPathSpec st u) where
  return a  = GenPathSpec $ \_   s -> (a, s, mempty)
  ma >>= k  = GenPathSpec $ \ctx s ->
                let (a,s1,w1) = getGenPathSpec ma ctx s
                    (b,s2,w2) = (getGenPathSpec . k) a ctx s1
                in (b, s2, w1 `mappend` w2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wumpus-drawing-0.9.0/src/Wumpus/Drawing/Text/Base/DocTextZero.hs
Applicative instance: 


instance Applicative (GenDoc st u) where
  pure a    = GenDoc $ \_   -> pure a
  mf <*> ma = GenDoc $ \env -> getGenDoc mf env <*> getGenDoc ma env
Monad instance: 



instance Monad (GenDoc st u) where
  return a  = GenDoc $ \_   -> return a
  ma >>= k  = GenDoc $ \env -> getGenDoc ma env >>= \a -> getGenDoc (k a) env
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lvish-1.1.4/Control/LVish/SchedIdempotent.hs
Monad instance: 


instance Monad Par where
  return a = Par $ \k -> k a
  m >>= c  = Par $ \k -> close m $ \a -> close (c a) k
Applicative instance: 


instance Applicative Par where
  (<*>) = ap
  pure  = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/game-probability-1.1/Numeric/Probability/Game/Event.hs
Applicative instance: 


instance Applicative EventM where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/network-api-support-0.2.2/src/Network/Api/Support/Response.hs
Applicative instance: 


instance Applicative JsonResult where
   pure = JsonSuccess

   (JsonSuccess f)   <*> m = fmap f m
   (ParseError err)  <*> _ = ParseError err
   (DecodeError err) <*> _ = DecodeError err
Monad instance: 


instance Monad JsonResult where
  return = JsonSuccess
  (ParseError t) >>= _ = ParseError t
  (DecodeError t) >>= _ = DecodeError t
  (JsonSuccess a) >>= f = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/one-liner-0.5.2/examples/realworld.hs
Applicative instance: 

instance MonadLogic m => Applicative (Fair m) where
  pure a = Fair $ pure a
  Fair fs <*> Fair as = Fair $ fs <~> as
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/omega-1.5.2/Parser.hs
Monad instance: 



-----------------------------------------------------------
-- Monad: return, sequence (>>=) and fail
-----------------------------------------------------------
instance Monad Parser where
  return x
    = Parser (\state -> Empty (Ok x state (unknownError state)))

  Parser p >>= f
    = Parser (\state ->
        case (p state) of
          Consumed reply1
            -> Consumed $
               case (reply1) of
                 Ok x state1 err1 -> case runP (f x) state1 of
                                       Empty reply2    -> mergeErrorReply err1 reply2
                                       Consumed reply2 -> reply2
                 Error err1       -> Error err1

          Empty reply1
            -> case (reply1) of
                 Ok x state1 err1 -> case runP (f x) state1 of
                                       Empty reply2 -> Empty (mergeErrorReply err1 reply2)
                                       other        -> other
                 Error err1       -> Empty (Error err1)
      )


  fail msg
    = Parser (\state ->
        Empty (Error (newErrorMessage (Message msg) (statePos state))))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/omega-1.5.2/Bind.hs
Monad instance: 


instance Monad M where
  return x = M (\ n -> (x,n))
  (>>=) (M h) g = M f
    where f n = let (a,n2) = h n
                    M k = g a
                in k n2
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/omega-1.5.2/Monads.hs
Monad instance: 


-------------------------------------------------------------

instance Monad (Either String) where
  return x = Right x
  (>>=) (Right x) f = f x
  fail s = Left s
Monad instance: 


instance Monad Id where
  return x = Id x
  (>>=) (Id x) f = f x
Monad instance: 
     -- message

instance Monad Exception where
  return x = Ok x
  (>>=) (Ok x) f = f x
  (>>=) (Fail loc n k s) f  = Fail loc n k s
  fail s = Fail Z 0 "" s
Monad instance: 


instance Monad (Env e) where
  return x = Env(\ e -> x)
  (>>=) (Env f) g = Env(\ e -> let Env h = g (f e)
                               in h e)
Monad instance: 


instance Monad (Store s) where
  return x = St(\ s -> (x,s))
  (>>=) (St f) g = St(\ s1 -> let (x,s2) = f s1
                                  St g' = g x
                              in g' s2)
Monad instance: 


instance Monad Mult where
  return x = Mult[x]
  (>>=) (Mult zs) f = Mult(flat(map f zs))
     where flat [] = []
           flat ((Mult xs):zs) = xs ++ (flat zs)
Monad instance: 


instance Monad Output where
  return x = OP(x,"")
  (>>=) (OP(x,s1)) f = let OP(y,s2) = f x in OP(y,s1 ++ s2)
Monad instance: 


instance Monad FIO where
  fail s = failFIO Z 0 s
  return x = FIO(return(Ok x))
  (>>=) (FIO a) g = FIO w
    where w = do { x <- a
                 ; case x of
                    Ok z -> unFIO(g z)
                    Fail loc n k s -> return(Fail loc n k s)}
Monad instance: 


instance Monad (StEnv s e) where
  return x = SE h
    where h s e = (x,s)
  (>>=) (SE f) g = SE(\ s1 e1 -> let (x,s2) = f s1 e1
                                     SE g' = g x
                                 in g' s2 e1)
Monad instance: 


instance Monad (Mtc e n) where
  return x = Tc f where f env = return(x,[])
  fail s = Tc f where f env = fail s
  (>>=) (Tc f) g = Tc h
     where h env = do { (a,ns1) <- f env
                      ; (b,ns2) <- unTc (g a) env
                      ; return(b,ns1++ns2)}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/stm-io-hooks-1.1.0/Control/Monad/AdvSTM/Def.hs
Applicative instance: 


instance Applicative AdvSTM where
    pure  = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/nested-sequence-0.2/src/Data/Nested/Seq/Ternary/Strict.hs
Monad instance: 


instance Monad (State s) where
  return x = State $ \s -> (s,x)
  a >>= u  = State $ \s -> case runState a s of (s',x) -> runState (u x) s'
Applicative instance: 


instance Applicative (State s) where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/nested-sequence-0.2/src/Data/Nested/Seq/Ternary/Lazy.hs
Monad instance: 


instance Monad (State s) where
  return x = State $ \s -> (s,x)
  a >>= u  = State $ \s -> case runState a s of (s',x) -> runState (u x) s'
Applicative instance: 


instance Applicative (State s) where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/nested-sequence-0.2/src/Data/Nested/Seq/Quaternary/Strict.hs
Monad instance: 


instance Monad (State s) where
  return x = State $ \s -> (s,x)
  a >>= u  = State $ \s -> case runState a s of (s',x) -> runState (u x) s'
Applicative instance: 


instance Applicative (State s) where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/nested-sequence-0.2/src/Data/Nested/Seq/Quaternary/Lazy.hs
Monad instance: 


instance Monad (State s) where
  return x = State $ \s -> (s,x)
  a >>= u  = State $ \s -> case runState a s of (s',x) -> runState (u x) s'
Applicative instance: 


instance Applicative (State s) where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/nested-sequence-0.2/src/Data/Nested/Seq/Binary/Strict.hs
Monad instance: 


instance Monad (State s) where
  return x = State $ \s -> (s,x)
  a >>= u  = State $ \s -> case runState a s of (s',x) -> runState (u x) s'
Applicative instance: 


instance Applicative (State s) where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/nested-sequence-0.2/src/Data/Nested/Seq/Binary/Lazy.hs
Monad instance: 


instance Monad (State s) where
  return x = State $ \s -> (s,x)
  a >>= u  = State $ \s -> case runState a s of (s',x) -> runState (u x) s'
Applicative instance: 


instance Applicative (State s) where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/labeled-graph-1.0.0.0/Data/LabeledGraph.hs
Monad instance: 


instance Monad (SetM s) where
    return x     = SetM $ const (return x)
    SetM v >>= f = SetM $ \ s -> do { x <- v s; runSetM (f x) s }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pinch-0.3.0.1/src/Pinch/Internal/Parser.hs
Applicative instance: 



instance Applicative Parser where
    {-# INLINE pure #-}
    pure a = Parser $ \b _ kSucc -> kSucc b a

    {-# INLINE (<*>) #-}
    Parser f' <*> Parser a' = Parser
        $ \b0 kFail kSucc -> f' b0 kFail
        $ \b1 f -> a' b1 kFail
        $ \b2 a -> kSucc b2 (f a)
Monad instance: 



instance Monad Parser where
    {-# INLINE return #-}
    return = pure

    {-# INLINE (>>) #-}
    (>>) = (*>)

    {-# INLINE fail #-}
    fail msg = Parser $ \_ kFail _ -> kFail msg

    {-# INLINE (>>=) #-}
    Parser m >>= k = Parser
        $ \b0 kFail kSucc -> m b0 kFail
        $ \b1 a -> unParser (k a) b1 kFail kSucc
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pinch-0.3.0.1/src/Pinch/Internal/Pinchable/Parser.hs
Applicative instance: 


instance Applicative Parser where
    {-# INLINE pure #-}
    pure a = Parser $ \_ kSucc -> kSucc a

    {-# INLINE (<*>) #-}
    Parser f' <*> Parser a' =
        Parser $ \kFail kSuccB ->
            f' kFail $ \f ->
            a' kFail $ \a ->
                kSuccB (f a)
Monad instance: 


instance Monad Parser where
    {-# INLINE fail #-}
    fail msg = Parser $ \kFail _ -> kFail msg

    {-# INLINE return #-}
    return = pure

    {-# INLINE (>>) #-}
    (>>) = (*>)

    {-# INLINE (>>=) #-}
    Parser a' >>= k =
        Parser $ \kFail kSuccB ->
            a' kFail $ \a ->
            unParser (k a) kFail kSuccB
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SciFlow-0.5.1/src/Scientific/Workflow/Builder.hs
Applicative instance: 


instance Applicative Parallel where
    pure = Parallel . pure
    Parallel fs <*> Parallel as = Parallel $
        (\(f, a) -> f a) <$> concurrently fs as
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sparser-0.6.1/src/Data/Sparser.hs
Monad instance: 


instance Monad ((?->) r) where
    return x = PartialP (\a -> Just (a, x))
    PartialP f >>= k = PartialP $ \r -> (f r >>= \(r1, x) -> getPartialP (k x) r1)
Applicative instance: 


instance Applicative ((?->) r) where
    pure  = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/streams-3.3/src/Data/Stream/Infinite/Skew.hs
Applicative instance: 


instance Applicative Stream where
  pure = repeat
  (<*>) = (<.>)
  (<* ) = (<. )
  ( *>) = ( .>)
Monad instance: 


instance Monad Stream where
  return = pure
  as >>= f = mapWithIndex (\i a -> f a !! i) as
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/streams-3.3/src/Data/Stream/Infinite/Functional/Zipper.hs
Applicative instance: 



instance Applicative Zipper where
  pure = repeat
  (<*>) = (<.>)
  as <* _ = as
  _ *> bs = bs
Monad instance: 


instance Monad Zipper where
  return = repeat
  (z :~ ma) >>= f = z :~ \ na -> case f (ma na) of
    nb :~ mb -> mb (nb + na - z)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monoid-absorbing-0.1.0.4/src/Data/List/Cut.hs
Monad instance: 


instance (Monad m) => Monad (CutListT m) where
  return a = CutListT $ return $ CCons a $ return CNil
  CutListT m >>= f = CutListT $ m >>= \x -> case x of
    CCons a m -> unCutListT $ f a +<>+ (CutListT m >>= f)
    CNil      -> return CNil
    CCut      -> return CCut
Applicative instance: 


instance (Functor m, Monad m) => Applicative (CutListT m) where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HARM-0.1.4/Arm/ParseLib.hs
Monad instance: 


instance Monad Parser where
   -- return      :: a -> Parser a
   return v        = P (\inp -> [(v,inp)])

   -- >>=         :: Parser a -> (a -> Parser b) -> Parser b
   (P p) >>= f     = P (\inp -> concat [papply (f v) out | (v,out) <- p inp])
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskgame-0.0.6/src/Graphics/UI/HaskGame/Vector2.hs
Applicative instance: 

instance Applicative Vector2 where
  pure x = Vector2 x x
  Vector2 f g <*> Vector2 x y = Vector2 (f x) (g y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtlx-0.1.6/examples/ListX.hs
Monad instance: 



instance (Index ix) => Monad (ListX ix) where
     return a = mkListX (getVal::ix) $ [a]
     v@((ListX {-(_::ix)-} _)::(ListX ix a)) >>= f = concatMapX f v
     fail _{-s-} = mkListX (getVal::ix) []
Monad instance: 


instance (Monad m, Index ix) => Monad (ListTX ix m) where
    return a = mkListTX (getVal::ix) $ return [a]
    m >>= k  = mkListTX (getVal::ix) $ do
        a <- runListTX' m
        b <- mapM (runListTX' . k) a
        return (concat b)
    fail _ = mkListTX (getVal::ix) $ return []
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtlx-0.1.6/Control/Monad/ReaderX.hs
Monad instance: 


instance (Index ix) => Monad (ReaderX ix r) where
    -- {-# INLINABLE return #-}
    -- {-# INLINABLE (>>=) #-}
    return a = mkReaderX (getVal::ix) $ \_ -> a
    m >>= k  = mkReaderX (getVal::ix) $ \r -> runReaderX (getVal::ix) (k (runReaderX (getVal::ix) m r)) r
Monad instance: 


instance (Monad m, Index ix) => Monad (ReaderTX ix r m) where
    -- {-# INLINABLE return #-}
    -- {-# INLINABLE (>>=) #-}
    return a = mkReaderTX (getVal::ix) $ \_ -> return a
    m >>= k  = mkReaderTX (getVal::ix) $ \r -> do
        a <- runReaderTX (getVal::ix) m r
        runReaderTX (getVal::ix) (k a) r
    fail msg = mkReaderTX (getVal::ix) $ \_ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtlx-0.1.6/Control/Monad/IdentityX.hs
Monad instance: 


instance (Index ix) => Monad (IdentityX ix) where
    return a = mkIdentityX (getVal::ix) a
    m >>= k  = k (runIdentityX' m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtlx-0.1.6/Control/Monad/WriterX/Strict.hs
Monad instance: 


instance (Monoid w, Index ix) => Monad (WriterX ix w) where
--    {-# INLINE return #-}
--    {-# INLINE (>>=) #-}
--    {-# INLINE (>>) #-}
    return a = mkWriterX (getVal::ix) (a, mempty)
    m >>= k  = mkWriterX (getVal::ix) $ case runWriterX' m of
                                          (a, w) -> case runWriterX' (k a) of
                                                      (b, w') -> (b, w `mappend` w')
    m >>  k  = mkWriterX (getVal::ix) $ case runWriterX' m of
                                          (_{-a-}, w) -> case runWriterX' (k {-a-}) of
                                                      (b, w') -> (b, w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m, Index ix) => Monad (WriterTX ix w m) where
--    {-# INLINE return #-}
--    {-# INLINE (>>=) #-}
--    {-# INLINE (>>) #-}
    return a = mkWriterTX (getVal::ix) $ return (a, mempty)
    m >>= k  = mkWriterTX (getVal::ix) $ do
        (a, w)  <- runWriterTX' m
        (b, w') <- runWriterTX' (k a)
        return (b, w `mappend` w')
    m >>  k  = mkWriterTX (getVal::ix) $ do
        (_{-a-}, w)  <- runWriterTX' m
        (b, w') <- runWriterTX' (k {-a-})
        return (b, w `mappend` w')
    fail msg = mkWriterTX (getVal::ix) $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtlx-0.1.6/Control/Monad/WriterX/Lazy.hs
Monad instance: 



instance (Monoid w, Index ix) => Monad (WriterX ix w) where
    -- {-# INLINABLE return #-}
    -- {-# INLINABLE (>>=) #-}
    return a = mkWriterX (getVal::ix) (a, mempty)
    m >>= k  = mkWriterX (getVal::ix) $ let
        (a, w)  = runWriterX' m
        (b, w') = runWriterX' (k a)
        in (b, w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m, Index ix) => Monad (WriterTX ix w m) where
    -- {-# INLINABLE return #-}
    -- {-# INLINABLE (>>=) #-}
    return a = mkWriterTX (getVal::ix) $ return (a, mempty)
    m >>= k  = mkWriterTX (getVal::ix) $ do
        ~(a, w)  <- runWriterTX' m
        ~(b, w') <- runWriterTX' (k a)
        return (b, w `mappend` w')
    fail msg = mkWriterTX (getVal::ix) $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtlx-0.1.6/Control/Monad/StateX/Strict.hs
Monad instance: 


instance (Index ix) => Monad (StateX ix s) where
    {-# INLINE return #-}
    {-# INLINE (>>=) #-}
    {-# INLINE (>>) #-}
    return a = mkStateX (getVal::ix) $ \s -> (a, s)
    ((StateX x)::(StateX ix s a)) >>= f  = mkStateX (getVal::ix) $ \s ->
        case (x s) of (v,s') -> runStateX' (f v) s'
    ((StateX x)::(StateX ix s a)) >> f  = mkStateX (getVal::ix) $ \s ->
        case (x s) of (_{-v-},s') -> runStateX' (f) s'
Monad instance: 


instance (Monad m, Index ix) => Monad (StateTX ix s m) where
    {-# INLINE return #-}
    {-# INLINE (>>=) #-}
    {-# INLINE (>>) #-}
    return a = mkStateTX (getVal::ix) $ \s -> return (a, s)
    ((StateTX x)::(StateTX ix s m a)) >>= f  = mkStateTX (getVal::ix) $ \s -> do
        (a, s') <- x s
        runStateTX' (f a) s'
    ((StateTX x)::(StateTX ix s m a)) >> f  = mkStateTX (getVal::ix) $ \s -> do
        (_{-a-}, s') <- x s
        runStateTX' (f) s'
    fail str = mkStateTX (getVal::ix) $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtlx-0.1.6/Control/Monad/StateX/Lazy.hs
Monad instance: 


instance (Index ix) => Monad (StateX ix s) where
    {-# INLINE return #-}
    {-# INLINE (>>=) #-}
    return a = mkStateX (getVal::ix) $ \s -> (a, s)
    ((StateX x)::(StateX ix s a)) >>= f  = mkStateX (getVal::ix) $ \s ->
        case (x s) of (v,s') -> runStateX' (f v) s'
Monad instance: 


instance (Monad m, Index ix) => Monad (StateTX ix s m) where
    {-# INLINE return #-}
    {-# INLINE (>>=) #-}
    return a = mkStateTX (getVal::ix) $ \s -> return (a, s)
    ((StateTX x)::(StateTX ix s m a)) >>= f  = mkStateTX (getVal::ix) $ \s -> do
        ~(a, s') <- x s
        runStateTX' (f a) s'
    fail str = mkStateTX (getVal::ix) $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtlx-0.1.6/Control/Monad/ErrorX.hs
Monad instance: 


instance (Monad m, ErrorX ix e, Index ix) => Monad (ErrorTX ix e m) where
    return a = mkErrorTX (getVal::ix) $ return (Right a)
    m >>= k  = mkErrorTX (getVal::ix) $ do
        a <- runErrorTX' m
        case a of
            Left  l -> return (Left l)
            Right r -> runErrorTX' (k r)
    fail msg = mkErrorTX (getVal::ix) $ return (Left (strMsgx (getVal::ix) msg))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtlx-0.1.6/Control/Monad/RWSX/Strict.hs
Monad instance: 



instance (Monoid w, Index ix) => Monad (RWSX ix r w s) where
    return a = mkRWSX (getVal::ix) $ \_ s -> (a, s, mempty)
    m >>= k  = mkRWSX (getVal::ix) $ \r s -> case runRWSX' m r s of
                                 (a, s',  w) ->
                                     case runRWSX' (k a) r s' of
                                         (b, s'', w') ->
                                             (b, s'', w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m, Index ix) => Monad (RWSTX ix r w s m) where
    return a = mkRWSTX (getVal::ix) $ \_ s -> return (a, s, mempty)
    m >>= k  = mkRWSTX (getVal::ix) $ \r s -> do
        (a, s', w)  <- runRWSTX' m r s
        (b, s'',w') <- runRWSTX' (k a) r s'
        return (b, s'', w `mappend` w')
    fail msg = mkRWSTX (getVal::ix) $ \_ _ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtlx-0.1.6/Control/Monad/RWSX/Lazy.hs
Monad instance: 


instance (Monoid w, Index ix) => Monad (RWSX ix r w s) where
    return a = mkRWSX (getVal::ix) $ \_ s -> (a, s, mempty)
    m >>= k  = mkRWSX (getVal::ix) $ \r s -> let
        (a, s',  w)  = runRWSX' m r s
        (b, s'', w') = runRWSX' (k a) r s'
        in (b, s'', w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m, Index ix) => Monad (RWSTX ix r w s m) where
    return a = mkRWSTX (getVal::ix) $ \_ s -> return (a, s, mempty)
    m >>= k  = mkRWSTX (getVal::ix) $ \r s -> do
        ~(a, s', w)  <- runRWSTX' m r s
        ~(b, s'',w') <- runRWSTX' (k a) r s'
        return (b, s'', w `mappend` w')
    fail msg = mkRWSTX (getVal::ix) $ \_ _ -> fail msg

Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/xml-extractors-0.4.0.2/src/Text/XML/Light/Extractors/Internal/Result.hs
Applicative instance: 



instance Applicative (Result e) where
  pure = Ok

  Ok f    <*> a = fmap f a
  Fatal e <*> _ = Fatal e
  Fail e  <*> _ = Fail e
Monad instance: 



instance Monad (Result e) where
  return = pure

  Fatal e >>= _ = Fatal e
  Fail e  >>= _ = Fail e
  Ok a    >>= k = k a
Applicative instance: 



instance (Functor m, Monad m) => Applicative (ResultT e m) where
  pure a = ResultT $ return (Ok a)

  f <*> v = ResultT $ do
              mf <- runResultT f
              case mf of
                Fatal e -> return (Fatal e)
                Fail  e -> return (Fail e)
                Ok   f' -> do
                   mv <- runResultT v
                   return (fmap f' mv)
Monad instance: 



instance (Monad m, Error e) => Monad (ResultT e m) where
  return = ResultT . return . Ok

  m >>= k = ResultT $ do
              r <- runResultT m
              case r of
                Fatal e -> return (Fatal e)
                Fail  e -> return (Fail e)
                Ok    a -> runResultT (k a)

  fail msg = ResultT $ return $ Fail (strMsg msg)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/foldl-1.2.1/src/Control/Foldl.hs
Applicative instance: 


instance Applicative (Fold a) where
    pure b    = Fold (\() _ -> ()) () (\() -> b)
    {-# INLINE pure #-}

    (Fold stepL beginL doneL) <*> (Fold stepR beginR doneR) =
        let step (Pair xL xR) a = Pair (stepL xL a) (stepR xR a)
            begin = Pair beginL beginR
            done (Pair xL xR) = doneL xL (doneR xR)
        in  Fold step begin done
    {-# INLINE (<*>) #-}
Applicative instance: 


instance Monad m => Applicative (FoldM m a) where
    pure b = FoldM (\() _ -> return ()) (return ()) (\() -> return b)
    {-# INLINABLE pure #-}

    (FoldM stepL beginL doneL) <*> (FoldM stepR beginR doneR) =
        let step (Pair xL xR) a = do
                xL' <- stepL xL a
                xR' <- stepR xR a
                return $! Pair xL' xR'
            begin = do
                xL <- beginL
                xR <- beginR
                return $! Pair xL xR
            done (Pair xL xR) = do
                f <- doneL xL
                x <- doneR xR
                return $! f x
        in  FoldM step begin done
    {-# INLINABLE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/transformers-0.5.2.0/legacy/pre711/Data/Functor/Compose.hs
Applicative instance: 


instance (Applicative f, Applicative g) => Applicative (Compose f g) where
    pure x = Compose (pure (pure x))
    Compose f <*> Compose x = Compose ((<*>) <$> f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/transformers-0.5.2.0/Control/Applicative/Backwards.hs
Applicative instance: 


-- | Apply @f@-actions in the reverse order.
instance (Applicative f) => Applicative (Backwards f) where
    pure a = Backwards (pure a)
    {-# INLINE pure #-}
    Backwards f <*> Backwards a = Backwards (a <**> f)
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/transformers-0.5.2.0/Control/Applicative/Lift.hs
Applicative instance: 


-- | A combination is 'Pure' only if both parts are.
instance (Applicative f) => Applicative (Lift f) where
    pure = Pure
    {-# INLINE pure #-}
    Pure f <*> Pure x = Pure (f x)
    Pure f <*> Other y = Other (f <$> y)
    Other f <*> Pure x = Other (($ x) <$> f)
    Other f <*> Other y = Other (f <*> y)
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/transformers-0.5.2.0/Data/Functor/Reverse.hs
Applicative instance: 


-- | Derived instance.
instance (Applicative f) => Applicative (Reverse f) where
    pure a = Reverse (pure a)
    {-# INLINE pure #-}
    Reverse f <*> Reverse a = Reverse (f <*> a)
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/happstack-facebook-0.9/Happstack/Facebook/FacebookT.hs
Applicative instance: 


instance (Monad m) => Applicative (FacebookT s m) where
    pure = FacebookT . return
    (FacebookT m) <*> (FacebookT n) = FacebookT (m `ap` n)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/iyql-0.0.7/src/main/haskell/Yql/Core/Backend.hs
Monad instance: 


instance Monad m => Monad (OutputT m) where
  fail = OutputT . return . Left

  return = OutputT . return . Right

  (OutputT mv) >>= f = OutputT $ do v <- mv
                                    case v
                                      of Left msg -> return (Left msg)
                                         Right v' -> unOutputT (f v')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-exception-0.1/src/Control/Monad/Trans/Exception.hs
Applicative instance: 



------------------------------------------------------------------------------
instance Monad m => Applicative (ExceptionT m) where
    pure = return
    (<*>) = ap
Monad instance: 



------------------------------------------------------------------------------
instance Monad m => Monad (ExceptionT m) where
    return = ExceptionT . return . Right'
    (ExceptionT m) >>= f = ExceptionT $ m >>= either' (return . Left') (\a ->
        let ExceptionT m' = f a in m')
    fail = ExceptionT . return . Left' . toException . PatternMatchFail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ffeed-0.3.2/FriendFeed/Types/Import.hs
Monad instance: 


instance Monad JM where
  return x = JM (\ _ _ -> return x)
  (JM a) >>= k = JM $ \ loc env -> do
     v <- a loc env
     case k v of
      (JM b) -> b loc env
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ffeed-0.3.2/FriendFeed/Monad.hs
Monad instance: 


instance Monad FFm where
  return x = FFm (\ _ -> return x)
  (FFm x) >>= k = FFm $ \ env -> do
      v <- x env
      case k v of
       FFm y -> y env
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HRay-1.2.3/HRayParser.hs
Monad instance: 


instance Monad HappyIdentity where
    return = HappyIdentity
    (HappyIdentity p) >>= q = q p
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/boombox-0.0/src/Data/Boombox/Player.hs
Applicative instance: 


instance Applicative (PlayerT w s m) where
  pure = return
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad (PlayerT w s m) where
  return a = PlayerT $ \cs -> cs a
  m >>= k = PlayerT $ \cs -> unPlayerT m $ \a -> unPlayerT (k a) cs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-4.5/Simulation/Aivika/Stream.hs
Applicative instance: 


instance Applicative Stream where

  pure a = let y = Cons (return (a, y)) in y

  (<*>) = apStream
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-4.5/Simulation/Aivika/Internal/Cont.hs
Monad instance: 


instance Monad Cont where
  return  = returnC
  m >>= k = bindC m k
Applicative instance: 


instance Applicative Cont where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-4.5/Simulation/Aivika/Internal/Event.hs
Monad instance: 


instance Monad Event where
  return  = returnE
  m >>= k = bindE m k
Applicative instance: 


instance Applicative Event where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-4.5/Simulation/Aivika/Internal/Parameter.hs
Monad instance: 


instance Monad Parameter where
  return  = returnP
  m >>= k = bindP m k
Applicative instance: 


instance Applicative Parameter where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-4.5/Simulation/Aivika/Internal/Process.hs
Monad instance: 
    -- for the references are unique

instance Monad Process where
  return  = returnP
  m >>= k = bindP m k
Applicative instance: 


instance Applicative Process where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-4.5/Simulation/Aivika/Internal/Dynamics.hs
Monad instance: 


instance Monad Dynamics where
  return  = returnD
  m >>= k = bindD m k
Applicative instance: 


instance Applicative Dynamics where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-4.5/Simulation/Aivika/Internal/Simulation.hs
Monad instance: 


instance Monad Simulation where
  return  = returnS
  m >>= k = bindS m k
Applicative instance: 


instance Applicative Simulation where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dbus-0.10.9.2/lib/DBus/Wire.hs
Applicative instance: 


instance Control.Applicative.Applicative (Wire s) where
        {-# INLINE pure #-}
        pure = return

        {-# INLINE (<*>) #-}
        (<*>) = ap
Monad instance: 


instance Monad (Wire s) where
        {-# INLINE return #-}
        return a = Wire (\_ s -> WireRR a s)

        {-# INLINE (>>=) #-}
        m >>= k = Wire $ \e s -> case unWire m e s of
                WireRL err -> WireRL err
                WireRR a s' -> unWire (k a) e s'

        {-# INLINE (>>) #-}
        m >> k = Wire $ \e s -> case unWire m e s of
                WireRL err -> WireRL err
                WireRR _ s' -> unWire k e s'
Applicative instance: 


instance Control.Applicative.Applicative (ErrorM e) where
        pure = return
        (<*>) = ap
Monad instance: 


instance Monad (ErrorM e) where
        return = ErrorM . Right
        (>>=) m k = case runErrorM m of
                Left err -> ErrorM (Left err)
                Right x -> k x
Applicative instance: 


instance Monad m => Control.Applicative.Applicative (ErrorT e m) where
        pure = return
        (<*>) = ap
Monad instance: 


instance Monad m => Monad (ErrorT e m) where
        return = ErrorT . return . Right
        (>>=) m k = ErrorT $ do
                x <- runErrorT m
                case x of
                        Left l -> return (Left l)
                        Right r -> runErrorT (k r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dbus-0.10.9.2/lib/DBus/Introspection.hs
Applicative instance: 


instance Control.Applicative.Applicative XmlWriter where
        pure = return
        (<*>) = ap
Monad instance: 


instance Monad XmlWriter where
        return a = XmlWriter $ Just (a, "")
        m >>= f = XmlWriter $ do
                (a, w) <- runXmlWriter m
                (b, w') <- runXmlWriter (f a)
                return (b, w ++ w')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/descriptive-0.9.4/src/Descriptive.hs
Applicative instance: 


instance Monad m => Applicative (Consumer s d m) where
  pure a =
    consumer (return mempty)
             (return (Succeeded a))
  Consumer d pf <*> Consumer d' p' =
    consumer (do e <- d
                 e' <- d'
                 return (e <> e'))
             (do mf <- pf
                 s <- get
                 ma <- p'
                 case mf of
                   Failed e ->
                     do put s
                        return (Failed e)
                   Continued e ->
                     case ma of
                       Failed e' ->
                         return (Failed e')
                       Continued e' ->
                         return (Continued (e <> e'))
                       Succeeded{} ->
                         return (Continued e)
                   Succeeded f ->
                     case ma of
                       Continued e ->
                         return (Continued e)
                       Failed e ->
                         return (Failed e)
                       Succeeded a ->
                         return (Succeeded (f a)))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/faceted-0.0.2.0/Data/Faceted/Internal.hs
Applicative instance: 


-- | Applicative: For when the function and argument both have facets.
instance Applicative Faceted where
  pure x  = Raw x
  (Raw f) <*> x  =  fmap f x
  (Faceted k priv pub) <*> x  =  Faceted k (priv <*> x) (pub <*> x)
Monad instance: 


-- | Monad: Like applicative, but even more powerful. 'Faceted' the free monad
-- over the function 'Facets a = F Label a a'. 
instance Monad Faceted where
  return x = Raw x
  (Raw x)              >>= f  = f x
  (Faceted k priv pub) >>= f  = Faceted k (priv >>= f) (pub >>= f)
Monad instance: 


-- | Monad is straightforward
instance Monad FIO where
  return x = FIO (\pc -> return x)
  x >>= f  = FIO (\pc -> do v <- runFIO x pc
                            runFIO (f v) pc)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/forml-0.2/src/hs/Forml/TypeCheck/Types.hs
Monad instance: 


instance Monad Z where
    return = Z
    (Z x) >>= f = f x
    (Error x) >>= _ = Error x
    fail = Error
Monad instance: 


instance Monad TI where
  fail x     = TI (\y -> error$ x ++ "\n" ++ msg y)
  return x   = TI (\y -> (y, x))
  TI f >>= g = TI (\x -> case f x of
                           (y, x') -> let TI gx = g x'
                                      in  gx y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/forml-0.2/src/hs/Forml/Optimize.hs
Monad instance: 


instance Monad Optimizer where

    fail   x = Optimizer (\y -> error x)
    return x = Optimizer (\y -> (y, x))

    Optimizer f >>= g =
        Optimizer (\x -> case f x of (y, x) -> let Optimizer gx = g x in gx y)
Applicative instance: 


instance Applicative Optimizer where

    pure = return
    x <*> y = do f <- x
                 f <$> y
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/forml-0.2/src/hs/Forml/Javascript/Backend.hs
Monad instance: 


        instance Monad JS where
          fail x     = JS (\_ -> error$ x)
          return x   = JS (\y -> (y, x))
          JS f >>= g = JS (\x -> case f x of
                                  (y, x') -> let JS gx = g x'
                                             in  gx y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/matrix-0.3.5.0/Data/Matrix.hs
Applicative instance: 



-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------

-------------------------------------------------------
-------------------------------------------------------
---- APPLICATIVE INSTANCE
---- Works like tensor product but applies a function 

instance Applicative Matrix where
  pure x = fromList 1 1 [x]
  m <*> m' = flatten $ ((\f -> f <$> m') <$> m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cpphs-1.9/Text/ParserCombinators/HuttonMeijer.hs
Monad instance: 


instance Monad Parser where
   -- return      :: a -> Parser a
   return v        = P (\inp -> [(v,inp)])

   -- >>=         :: Parser a -> (a -> Parser b) -> Parser b
   (P p) >>= f     = P (\inp -> concat [papply (f v) out | (v,out) <- p inp])

   -- fail        :: String -> Parser a
   fail _          = P (\_ -> [])
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/AbortT-transformers-1.0.1.2/Control/Monad/Trans/Abort.hs
Applicative instance: 


instance Applicative m => Applicative (AbortT r m) where
    pure = AbortT . fmap Right . pure
    (AbortT m) <*> (AbortT x) = AbortT ((fmap h m) <*> x)
      where
        h (Left g) = const (Left g)
        h (Right f) = either Left (Right . f)
Monad instance: 


instance Monad m => Monad (AbortT r m) where
    return = AbortT . return . Right
    (AbortT m) >>= f = AbortT $ m >>= either (return . Left) (unwrapAbortT . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/shelly-1.6.8/src/Shelly/Pipe.hs
Monad instance: 


instance Monad Sh where
    return  = Sh . return . return
    a >>= f = Sh $ fmap concat $ mapM (unSh . f) =<< unSh a
    a >> b  = Sh $ unSh a >> unSh b
Applicative instance: 


instance Applicative Sh where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/beautifHOL-0.11/ErrM.hs
Monad instance: 


instance Monad Err where
  return      = Ok
  fail        = Bad
  Ok a  >>= f = f a
  Bad s >>= f = Bad s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/karakuri-0.1.1/Data/Karakuri.hs
Applicative instance: 


instance Monad m => Applicative (Karakuri m) where
    pure a = Karakuri return (const a) ()
    {-# INLINE pure #-}
    Karakuri m f s <*> Karakuri n g t = Karakuri
        (\(a, b) -> m a >>= \r -> n b >>= \s -> return (r, s))
        (\(x, y) -> f x (g y))
        (s, t)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/data-inttrie-0.1.2/Data/IntTrie.hs
Applicative instance: 


instance Applicative BitTrie where
    pure x = fix (\g -> BitTrie x g g)
    ~(BitTrie f fl fr) <*> ~(BitTrie x xl xr) = BitTrie (f x) (fl <*> xl) (fr <*> xr)
Applicative instance: 


instance Applicative IntTrie where
    pure x = IntTrie (pure x) x (pure x)
    IntTrie fneg fz fpos <*> IntTrie xneg xz xpos =
        IntTrie (fneg <*> xneg) (fz xz) (fpos <*> xpos)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haddock-library-1.4.2/vendor/attoparsec-0.12.1.1/Data/Attoparsec/Internal/Types.hs
Monad instance: 


instance Monad (Parser i) where
    fail err = Parser $ \t pos more lose _succ -> lose t pos more [] msg
      where msg = "Failed reading: " ++ err
    {-# INLINE fail #-}

    return = pure
    {-# INLINE return #-}

    m >>= k = Parser $ \t !pos more lose succ ->
        let succ' t' !pos' more' a = runParser (k a) t' pos' more' lose succ
        in runParser m t pos more lose succ'
    {-# INLINE (>>=) #-}
Applicative instance: 


instance Applicative (Parser i) where
    pure v = Parser $ \t pos more _lose succ -> succ t pos more v
    {-# INLINE pure #-}
    (<*>)  = apP
    {-# INLINE (<*>) #-}

    -- These definitions are equal to the defaults, but this
    -- way the optimizer doesn't have to work so hard to figure
    -- that out.
    m *> k = m >>= \_ -> k
    {-# INLINE (*>) #-}
    x <* y = x >>= \a -> y >> return a
    {-# INLINE (<*) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bytestringparser-0.3/src/Data/ParserCombinators/Attoparsec/Internal.hs
Monad instance: 


instance Monad Parser where
    return a = Parser $ \s -> Right (a, s)
    m >>= f = Parser $ \s ->
              case unParser m s of
                Right (a, s') -> unParser (f a) s'
                Left (s', msgs) -> Left (s', msgs)
    fail err = Parser $ \(S sb lb _) -> Left (sb +: lb, [err])
Applicative instance: 


instance Applicative Parser where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dao-0.1.0.1/src/Dao/Parser.hs
Monad instance: 


instance Monad LexBuilderM where
  return = LexBuilderM . return
  (LexBuilderM a) >>= b = LexBuilderM (a >>= runLexBuilder . b)
Applicative instance: 

instance Applicative LexBuilderM where { pure = return; (<*>) = ap; }
Monad instance: 


instance TokenType tok =>
  Monad (Lexer tok) where
    (Lexer fn) >>= mfn = Lexer (fn >>= lexerToPredicateT . mfn)
    return             = Lexer . return
    fail msg           = do
      st <- get
      throwError $
        (parserErr (lexCurrentLocation st)){parseErrMsg = Just (ustr msg), parseStateAtErr=Just st}
Monad instance: 

instance TokenType tok =>
  Monad (TokStream st tok) where
    (TokStream ma) >>= mfa = TokStream (ma >>= parserToPredicateT . mfa)
    return a               = TokStream (return a)
    fail msg = do
      tok <- optional (nextToken False)
      st  <- get
      throwError $
        ParseError
        { parseErrLoc     = maybe LocationUnknown asLocation tok
        , parseErrMsg     = Just (ustr msg)
        , parseErrTok     = fmap getToken tok
        , parseStateAtErr = Just st
        }
Applicative instance: 

instance TokenType tok =>
  Applicative (TokStream st tok) where { pure = return ; (<*>) = ap; }
Monad instance: 

instance TokenType tok =>
  Monad (Parser st tok) where
    return = Parser . return
    parser >>= bind = case parser of
      ParserNull -> ParserNull
      Parser   p -> Parser $ p >>= \a -> case bind a of { ParserNull -> mzero; Parser p -> p; }
    --parserA >> parserB = case parserA of
    --  ParserNull     -> ParserNull
    --  Parser parserA -> case parserB of
    --    ParserNull     -> Parser (parserA >> mzero)
    --    Parser parserB -> Parser (parserA >> parserB)
    fail   = Parser . fail
Applicative instance: 

instance TokenType tok => Applicative (Parser st tok) where { pure = return; (<*>) = ap;    }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dao-0.1.0.1/src/Dao/Predicate.hs
Monad instance: 


instance Monad (Predicate err) where
  return = OK
  ma >>= mfn = case ma of
    OK     ok -> mfn    ok
    PFail err -> PFail err
    Backtrack -> Backtrack
Applicative instance: 


instance Applicative (Predicate err) where { pure  = return; (<*>) = ap;    }
Monad instance: 


instance Monad m => Monad (PredicateT err m) where
  return a = PredicateT (return (OK a))
  PredicateT ma >>= fma = PredicateT $ do
    a <- ma
    case a of
      Backtrack -> return Backtrack
      PFail   u -> return (PFail u)
      OK      o -> runPredicateT (fma o)
  PredicateT ma >> PredicateT mb = PredicateT $ do
    a <- ma
    case a of
      Backtrack -> return Backtrack
      PFail   u -> return (PFail u)
      OK      _ -> mb
  fail msg = PredicateT{ runPredicateT = return (PFail (error msg)) }
Applicative instance: 


instance (Functor m, Monad m) => Applicative (PredicateT err m) where { pure = return; (<*>) = ap; }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dao-0.1.0.1/src/Dao/Interval.hs
Monad instance: 

instance (Ord c, Enum c, InfBound c) =>
  Monad (SetM c) where
    return = InfiniteM . (:[])
    a >>= b = case a of
      EmptySetM   -> EmptySetM
      InfiniteM x -> msum (map b x)
      SetM    a x -> msum (map segs a ++ map deflts x) where
        segs (a, x) = msum (map (sieveM a . b) x)
        deflts x = case b x of
          EmptySetM   -> EmptySetM
          InfiniteM x -> InfiniteM x
          SetM    _ x -> InfiniteM x
Applicative instance: 

instance (Ord c, Enum c, InfBound c) =>
  Applicative (SetM c) where { pure = return; (<*>) = ap; }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dao-0.1.0.1/src/Dao/StepList.hs
Applicative instance: 

instance Applicative StepList where { pure  = return; (<*>) = ap;      }
Monad instance: 

instance Monad       StepList where
  -- | Return is defined by 'slSingletonL'. This is because when lists are used as a monad, the
  -- 'Control.Monad.return' operations that occur earlier in the computation place items in the list
  -- earlier than 'Control.Monad.return' operations that occur later in the computation. Therefore a
  -- monadic computation like @a >> b@ will have @a@ placed to the left of @b@.
  return = slSingletonL
  -- | Just like how the '(Prelude.>>=)' operator instantiated for Haskell lists is the
  -- 'Prelude.concatMap' function, the '(Prelude.>>=)' operator for 'StepList's is the 'slConcatMap'
  -- function.
  (>>=) = flip slConcatMap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dao-0.1.0.1/src/Dao/Binary.hs
Monad instance: 

instance Monad (GPutM mtab) where
  return = PutM . return
  (PutM a) >>= fn = PutM (a >>= encoderToStateT . fn)
  fail = PutM . fail
Applicative instance: 

instance Applicative (GPutM mtab) where { pure=return; (<*>)=ap; }
Monad instance: 

instance Monad (GGet mtab) where
  return = Get . return
  (Get a) >>= fn = Get (a >>= decoderToStateT . fn)
  Get a >> Get b = Get (a >> b)
  fail msg = bytesRead >>= \ofst -> Get (throwError (GetErr ofst (toUStr msg)))
Applicative instance: 

instance Applicative (GGet mtab) where { pure=return; (<*>)=ap;    }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dao-0.1.0.1/src/Dao/Tree.hs
Monad instance: 


instance Monad m =>
  Monad (UpdateTreeT p n m) where
    return = UpdateTreeT . return
    (UpdateTreeT a) >>= b = UpdateTreeT (a >>= getUpdateTreeStateT . b)
Applicative instance: 

instance (Monad m, Functor m) =>
  Applicative (UpdateTreeT p n m) where { pure = return; (<*>) = ap; }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-transformers-4.5/Simulation/Aivika/Trans/Stream.hs
Applicative instance: 


instance MonadDES m => Applicative (Stream m) where

  {-# INLINE pure #-}
  pure a = let y = Cons (return (a, y)) in y

  {-# INLINE (<*>) #-}
  (<*>) = apStream
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-transformers-4.5/Simulation/Aivika/Trans/Internal/Cont.hs
Monad instance: 


instance MonadDES m => Monad (Cont m) where

  {-# INLINE return #-}
  return a =
    Cont $ \c ->
    Event $ \p ->
    do z <- invokeEvent p $ contCanceled c
       if z
         then invokeEvent p $ cancelCont c
         else invokeEvent p $ contCont c a

  {-# INLINE (>>=) #-}
  (Cont m) >>= k =
    Cont $ \c ->
    Event $ \p ->
    do z <- invokeEvent p $ contCanceled c
       if z
         then invokeEvent p $ cancelCont c
         else invokeEvent p $ m $
              let cont a = invokeCont c (k a)
              in c { contCont = cont }
Applicative instance: 


instance MonadDES m => Applicative (Cont m) where

  {-# INLINE pure #-}
  pure = return

  {-# INLINE (<*>) #-}
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-transformers-4.5/Simulation/Aivika/Trans/Internal/Event.hs
Monad instance: 


instance Monad m => Monad (Event m) where

  {-# INLINE return #-}
  return a = Event $ \p -> return a

  {-# INLINE (>>=) #-}
  (Event m) >>= k =
    Event $ \p ->
    do a <- m p
       let Event m' = k a
       m' p
Applicative instance: 


instance Applicative m => Applicative (Event m) where

  {-# INLINE pure #-}
  pure = Event . const . pure

  {-# INLINE (<*>) #-}
  (Event x) <*> (Event y) = Event $ \p -> x p <*> y p
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-transformers-4.5/Simulation/Aivika/Trans/Internal/Parameter.hs
Monad instance: 


instance Monad m => Monad (Parameter m) where

  {-# INLINE return #-}
  return a = Parameter $ \r -> return a

  {-# INLINE (>>=) #-}
  (Parameter m) >>= k =
    Parameter $ \r ->
    do a <- m r
       let Parameter m' = k a
       m' r
Applicative instance: 


instance Applicative m => Applicative (Parameter m) where

  {-# INLINE pure #-}
  pure = Parameter . const . pure

  {-# INLINE (<*>) #-}
  (Parameter x) <*> (Parameter y) = Parameter $ \r -> x r <*> y r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-transformers-4.5/Simulation/Aivika/Trans/Internal/Process.hs
Monad instance: 


instance MonadDES m => Monad (Process m) where

  {-# INLINE return #-}
  return a = Process $ \pid -> return a

  {-# INLINE (>>=) #-}
  (Process m) >>= k =
    Process $ \pid ->
    do a <- m pid
       let Process m' = k a
       m' pid
Applicative instance: 


instance MonadDES m => Applicative (Process m) where

  {-# INLINE pure #-}
  pure = Process . const . pure

  {-# INLINE (<*>) #-}
  (Process x) <*> (Process y) = Process $ \pid -> x pid <*> y pid
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-transformers-4.5/Simulation/Aivika/Trans/Internal/Dynamics.hs
Monad instance: 


instance Monad m => Monad (Dynamics m) where

  {-# INLINE return #-}
  return a = Dynamics $ \p -> return a

  {-# INLINE (>>=) #-}
  (Dynamics m) >>= k =
    Dynamics $ \p ->
    do a <- m p
       let Dynamics m' = k a
       m' p
Applicative instance: 


instance Applicative m => Applicative (Dynamics m) where

  {-# INLINE pure #-}
  pure = Dynamics . const . pure

  {-# INLINE (<*>) #-}
  (Dynamics x) <*> (Dynamics y) = Dynamics $ \p -> x p <*> y p
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-transformers-4.5/Simulation/Aivika/Trans/Internal/Simulation.hs
Monad instance: 


instance Monad m => Monad (Simulation m) where

  {-# INLINE return #-}
  return a = Simulation $ \r -> return a

  {-# INLINE (>>=) #-}
  (Simulation m) >>= k =
    Simulation $ \r ->
    do a <- m r
       let Simulation m' = k a
       m' r
Applicative instance: 


instance Applicative m => Applicative (Simulation m) where

  {-# INLINE pure #-}
  pure = Simulation . const . pure

  {-# INLINE (<*>) #-}
  (Simulation x) <*> (Simulation y) = Simulation $ \r -> x r <*> y r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-lib-0.8.0.0/Penny/Lincoln/Serial.hs
Applicative instance: 


instance Applicative GenSerial where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad GenSerial where
  return a = GenSerial $ \s -> (a, s)
  (GenSerial k) >>= f = GenSerial $ \s ->
    let (a, s') = k s
        GenSerial g = f a
    in g s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-lib-0.8.0.0/Penny/Cabin/Posts/Allocated.hs
Applicative instance: 


instance Applicative Fields where
  pure a = Fields a a
  ff <*> fa = Fields {
    payee = payee ff (payee fa)
    , account = account ff (account fa) }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-lib-0.8.0.0/Penny/Cabin/Posts/Fields.hs
Applicative instance: 


instance Applicative Fields where
  pure a = Fields {
    globalTransaction = a
    , revGlobalTransaction = a
    , globalPosting = a
    , revGlobalPosting = a
    , fileTransaction = a
    , revFileTransaction = a
    , filePosting = a
    , revFilePosting = a
    , filtered = a
    , revFiltered = a
    , sorted = a
    , revSorted = a
    , visible = a
    , revVisible = a
    , lineNum = a
    , date = a
    , flag = a
    , number = a
    , payee = a
    , account = a
    , postingDrCr = a
    , postingCmdty = a
    , postingQty = a
    , totalDrCr = a
    , totalCmdty = a
    , totalQty = a
    , tags = a
    , memo = a
    , filename = a }

  ff <*> fa = Fields {
    globalTransaction = globalTransaction ff (globalTransaction fa)
    , revGlobalTransaction = revGlobalTransaction ff
                             (revGlobalTransaction fa)
    , globalPosting = globalPosting ff (globalPosting fa)
    , revGlobalPosting = revGlobalPosting ff (revGlobalPosting fa)
    , fileTransaction = fileTransaction ff (fileTransaction fa)
    , revFileTransaction = revFileTransaction ff (revFileTransaction fa)
    , filePosting = filePosting ff (filePosting fa)
    , revFilePosting = revFilePosting ff (revFilePosting fa)
    , filtered = filtered ff (filtered fa)
    , revFiltered = revFiltered ff (revFiltered fa)
    , sorted = sorted ff (sorted fa)
    , revSorted = revSorted ff (revSorted fa)
    , visible = visible ff (visible fa)
    , revVisible = revVisible ff (revVisible fa)
    , lineNum = lineNum ff (lineNum fa)
    , date = date ff (date fa)
    , flag = flag ff (flag fa)
    , number = number ff (number fa)
    , payee = payee ff (payee fa)
    , account = account ff (account fa)
    , postingDrCr = postingDrCr ff (postingDrCr fa)
    , postingCmdty = postingCmdty ff (postingCmdty fa)
    , postingQty = postingQty ff (postingQty fa)
    , totalDrCr = totalDrCr ff (totalDrCr fa)
    , totalCmdty = totalCmdty ff (totalCmdty fa)
    , totalQty = totalQty ff (totalQty fa)
    , tags = tags ff (tags fa)
    , memo = memo ff (memo fa)
    , filename = filename ff (filename fa) }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-lib-0.8.0.0/Penny/Cabin/Posts/BottomRows.hs
Applicative instance: 


instance Applicative Fields where
  pure a = Fields a a a
  ff <*> fa = Fields {
    tags = (tags ff) (tags fa)
    , memo = (memo ff) (memo fa)
    , filename = (filename ff) (filename fa)
    }
Applicative instance: 


instance Applicative TopRowCells where
  pure a = TopRowCells
    { globalTransaction    = a
    , revGlobalTransaction = a
    , globalPosting        = a
    , revGlobalPosting     = a
    , fileTransaction      = a
    , revFileTransaction   = a
    , filePosting          = a
    , revFilePosting       = a
    , filtered             = a
    , revFiltered          = a
    , sorted               = a
    , revSorted            = a
    , visible              = a
    , revVisible           = a
    , lineNum              = a
    , date                 = a
    , flag                 = a
    , number               = a
    , payee                = a
    , account              = a
    , postingDrCr          = a
    , postingCmdty         = a
    , postingQty           = a
    , totalDrCr            = a
    , totalCmdty           = a
    , totalQty             = a }

  ff <*> fa = TopRowCells
    { globalTransaction    = globalTransaction    ff (globalTransaction    fa)
    , revGlobalTransaction = revGlobalTransaction ff (revGlobalTransaction fa)
    , globalPosting        = globalPosting        ff (globalPosting        fa)
    , revGlobalPosting     = revGlobalPosting     ff (revGlobalPosting     fa)
    , fileTransaction      = fileTransaction      ff (fileTransaction      fa)
    , revFileTransaction   = revFileTransaction   ff (revFileTransaction   fa)
    , filePosting          = filePosting          ff (filePosting          fa)
    , revFilePosting       = revFilePosting       ff (revFilePosting       fa)
    , filtered             = filtered             ff (filtered             fa)
    , revFiltered          = revFiltered          ff (revFiltered          fa)
    , sorted               = sorted               ff (sorted               fa)
    , revSorted            = revSorted            ff (revSorted            fa)
    , visible              = visible              ff (visible              fa)
    , revVisible           = revVisible           ff (revVisible           fa)
    , lineNum              = lineNum              ff (lineNum              fa)
    , date                 = date                 ff (date                 fa)
    , flag                 = flag                 ff (flag                 fa)
    , number               = number               ff (number               fa)
    , payee                = payee                ff (payee                fa)
    , account              = account              ff (account              fa)
    , postingDrCr          = postingDrCr          ff (postingDrCr          fa)
    , postingCmdty         = postingCmdty         ff (postingCmdty         fa)
    , postingQty           = postingQty           ff (postingQty           fa)
    , totalDrCr            = totalDrCr            ff (totalDrCr            fa)
    , totalCmdty           = totalCmdty           ff (totalCmdty           fa)
    , totalQty             = totalQty             ff (totalQty             fa) }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-lib-0.8.0.0/Penny/Cabin/Posts/Growers.hs
Applicative instance: 


instance Applicative Fields where
  pure a = Fields
    { globalTransaction     = a
    , revGlobalTransaction = a
    , globalPosting        = a
    , revGlobalPosting     = a
    , fileTransaction      = a
    , revFileTransaction   = a
    , filePosting          = a
    , revFilePosting       = a
    , filtered             = a
    , revFiltered          = a
    , sorted               = a
    , revSorted            = a
    , visible              = a
    , revVisible           = a
    , lineNum              = a
    , date                 = a
    , flag                 = a
    , number               = a
    , postingDrCr          = a
    , postingCmdty         = a
    , postingQty           = a
    , totalDrCr            = a
    , totalCmdty           = a
    , totalQty             = a }

  fl <*> fa = Fields
    { globalTransaction    = globalTransaction    fl (globalTransaction    fa)
    , revGlobalTransaction = revGlobalTransaction fl (revGlobalTransaction fa)
    , globalPosting        = globalPosting        fl (globalPosting        fa)
    , revGlobalPosting     = revGlobalPosting     fl (revGlobalPosting     fa)
    , fileTransaction      = fileTransaction      fl (fileTransaction      fa)
    , revFileTransaction   = revFileTransaction   fl (revFileTransaction   fa)
    , filePosting          = filePosting          fl (filePosting          fa)
    , revFilePosting       = revFilePosting       fl (revFilePosting       fa)
    , filtered             = filtered             fl (filtered             fa)
    , revFiltered          = revFiltered          fl (revFiltered          fa)
    , sorted               = sorted               fl (sorted               fa)
    , revSorted            = revSorted            fl (revSorted            fa)
    , visible              = visible              fl (visible              fa)
    , revVisible           = revVisible           fl (revVisible           fa)
    , lineNum              = lineNum              fl (lineNum              fa)
    , date                 = date                 fl (date                 fa)
    , flag                 = flag                 fl (flag                 fa)
    , number               = number               fl (number               fa)
    , postingDrCr          = postingDrCr          fl (postingDrCr          fa)
    , postingCmdty         = postingCmdty         fl (postingCmdty         fa)
    , postingQty           = postingQty           fl (postingQty           fa)
    , totalDrCr            = totalDrCr            fl (totalDrCr            fa)
    , totalCmdty           = totalCmdty           fl (totalCmdty           fa)
    , totalQty             = totalQty             fl (totalQty             fa) }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-lib-0.8.0.0/Penny/Cabin/Balance/MultiCommodity/Chunker.hs
Applicative instance: 


instance Applicative Columns where
  pure a = Columns a a a a
  fn <*> fa = Columns {
    acct = (acct fn) (acct fa)
    , drCr = (drCr fn) (drCr fa)
    , commodity = (commodity fn) (commodity fa)
    , quantity = (quantity fn) (quantity fa)
     }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/penny-lib-0.8.0.0/Penny/Cabin/Balance/Convert/Chunker.hs
Applicative instance: 


instance Applicative Columns where
  pure a = Columns a a a
  fn <*> fa = Columns {
    acct = (acct fn) (acct fa)
    , drCr = (drCr fn) (drCr fa)
    , quantity = (quantity fn) (quantity fa)
     }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hedis-0.9.3/src/Database/Redis/Transactions.hs
Applicative instance: 


instance Applicative Queued where
    pure x                = Queued (const $ Right x)
    Queued f <*> Queued x = Queued $ \rs -> do
                                        f' <- f rs
                                        x' <- x rs
                                        return (f' x')
Monad instance: 


instance Monad Queued where
    return         = pure
    Queued x >>= f = Queued $ \rs -> do
                                x' <- x rs
                                let Queued f' = f x'
                                f' rs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/binary-search-1.0.0.3/Numeric/Search.hs
Applicative instance: 


instance Applicative (Evidence e) where
    pure                     = Evidence
    CounterEvidence  e <*> _ = CounterEvidence e
    Evidence f <*> r         = fmap f r
Monad instance: 


instance Monad (Evidence e) where
    return                   = Evidence
    CounterEvidence  l >>= _ = CounterEvidence l
    Evidence r >>= k         = k r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskore-vintage-0.3/src/Haskore/Monads.hs
Applicative instance: 


instance A.Applicative (SR s) where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad (SR s) where
  m >>= k  = SR (\s -> case (unSR m) s of a -> (unSR (k a)) s)
  m >>  k  = SR (\s -> case (unSR m) s of _ -> (unSR k) s)
  return a = SR (\s -> a)
Applicative instance: 


instance A.Applicative (State s) where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad (State s) where
  m >>= k  = S (\s -> case (unS m) s of (a,s') -> (unS (k a)) s')
  m >>  k  = S (\s -> case (unS m) s of (_,s') -> (unS k) s')
  return a = S (\s -> (a,s))
Applicative instance: 


instance A.Applicative (IOS s) where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad   (IOS s) where
 m >>= k  = IOS (\s -> unIOS m s >>= \(a,s') -> unIOS (k a) s')
 m >>  k  = IOS (\s -> unIOS m s >>= \(_,s') -> unIOS k s')
 return a = IOS (\s -> return (a,s))
Applicative instance: 


instance A.Applicative (Output s) where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad (Output s) where
  m >>= k  = O (let (a,r) = unO m; (b,s) = unO (k a) in (b, r . s))
  m >>  k  = O (let (a,r) = unO m; (b,s) = unO k     in (b, r . s))
  return a = O (a, \s -> s)
Applicative instance: 


instance A.Applicative (CPS s) where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad (CPS r) where
  m >>= k  = CPS (\c -> unCPS m (\a -> unCPS (k a) c))
  m >>  k  = CPS (\c -> unCPS m (\a -> unCPS k     c))
  return a = CPS (\c -> c a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/acme-inator-0.1.0.0/Acme/Inator.hs
Monad instance: 

instance Monad TriStateArea where
    return = TriStateArea . const . Just
    f >>= g = TriStateArea (\ta -> takeOver f ta >>= flip takeOver ta . g)
    fail _ = TriStateArea $ const Nothing
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/emgm-0.4/src/Generics/EMGM/Functions/UnzipWith.hs
Monad instance: 


instance Monad Id where
  return a = Id a
  m >>= k  = k (runId m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/frisby-0.2/Text/Parsers/Frisby.hs
Applicative instance: 


instance Applicative (PM s) where
  (<*>) = ap
  pure = return
Applicative instance: 


instance Applicative PE where
--should another constructor be added, rather?
--perhaps Then and ThenCat combined and parameterized by
--the function (++), (,) ... but, 'text', etc, does this too
    mf <*> ma = PMap (\(f,a) -> f a) (Then mf ma)
    pure = Unit
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ConstraintKinds-1.3.0/src/Control/ConstraintKinds/Applicative.hs
Applicative instance: 


-------------------------------------------------------------------------------
-- Instances

instance Applicative [] where
    (<*>) = M.ap
Applicative instance: 


instance Applicative V.Vector where
    {-# INLINE (<*>) #-}
    (<*>) = M.ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ConstraintKinds-1.3.0/src/Control/ConstraintKinds/Monad.hs
Monad instance: 


-------------------------------------------------------------------------------
-- instances

instance Control.ConstraintKinds.Monad.Monad [] where
    return = Monad.return
    (>>=)  = (Monad.>>=)
    (>>)   = (Monad.>>)
Monad instance: 


instance Monad ReadPrec where
    return = Monad.return
    (>>=)  = (Monad.>>=)
    (>>)   = (Monad.>>)
Monad instance: 


instance Monad V.Vector where
    return = Monad.return
    (>>=) = flip V.concatMap
Monad instance: 


instance Monad VU.Vector where
    return = VU.singleton
    (>>=) = flip VU.concatMap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unification-fd-0.9.0/src/Control/Unification/Ranked/IntVar.hs
Applicative instance: 


-- N.B., it's not possible to reduce the dependency to Applicative.
instance (Functor m, Monad m) => Applicative (IntRBindingT t m) where
    pure    = IRBT . pure
    x <*> y = IRBT (unIRBT x <*> unIRBT y)
    x  *> y = IRBT (unIRBT x  *> unIRBT y)
    x <*  y = IRBT (unIRBT x <*  unIRBT y)
Monad instance: 


instance (Monad m) => Monad (IntRBindingT t m) where
    return  = IRBT . return
    m >>= f = IRBT (unIRBT m >>= unIRBT . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unification-fd-0.9.0/src/Control/Unification/Ranked/STVar.hs
Applicative instance: 


instance Applicative (STRBinding s) where
    pure   = return
    (<*>)  = ap
    (*>)   = (>>)
    x <* y = x >>= \a -> y >> return a
Monad instance: 


instance Monad (STRBinding s) where
    return    = STRB . return
    stb >>= f = STRB (unSTRB stb >>= unSTRB . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unification-fd-0.9.0/src/Control/Unification/IntVar.hs
Applicative instance: 


-- BUG: can't reduce dependency to Applicative because of StateT's instance.
instance (Functor m, Monad m) => Applicative (IntBindingT t m) where
    pure    = IBT . pure
    x <*> y = IBT (unIBT x <*> unIBT y)
    x  *> y = IBT (unIBT x  *> unIBT y)
    x <*  y = IBT (unIBT x <*  unIBT y)
Monad instance: 


instance (Monad m) => Monad (IntBindingT t m) where
    return  = IBT . return
    m >>= f = IBT (unIBT m >>= unIBT . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unification-fd-0.9.0/src/Control/Unification/Types.hs
Applicative instance: 


-- Does this even make sense for UTerm? It'd mean (a->b) is a
-- variable type...
instance (Functor t) => Applicative (UTerm t) where
    pure                  = UVar
    UVar  a  <*> UVar  b  = UVar  (a b)
    UVar  a  <*> UTerm mb = UTerm (fmap a  <$> mb)
    UTerm ma <*> b        = UTerm ((<*> b) <$> ma)
Monad instance: 


-- Does this even make sense for UTerm? It may be helpful for
-- building terms at least; though bind is inefficient for that.
-- Should use the cheaper free...
instance (Functor t) => Monad (UTerm t) where
    return        = UVar
    UVar  v >>= f = f v
    UTerm t >>= f = UTerm ((>>= f) <$> t)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unification-fd-0.9.0/src/Control/Unification/STVar.hs
Applicative instance: 


instance Applicative (STBinding s) where
    pure   = return
    (<*>)  = ap
    (*>)   = (>>)
    x <* y = x >>= \a -> y >> return a
Monad instance: 


instance Monad (STBinding s) where
    return    = STB . return
    stb >>= f = STB (unSTB stb >>= unSTB . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unification-fd-0.9.0/src/Control/Monad/MaybeK.hs
Applicative instance: 


instance Applicative MaybeK where
    pure   = return
    (<*>)  = ap
    (*>)   = (>>)
    x <* y = x >>= \a -> y >> return a
Monad instance: 


instance Monad MaybeK where
    return a   = MK (\k -> k a)
    MK m >>= f = MK (\k -> m (\a -> case f a of MK n -> n k))
Applicative instance: 


instance Applicative (MaybeKT m) where
    pure   = return
    (<*>)  = ap
    (*>)   = (>>)
    x <* y = x >>= \a -> y >> return a
Monad instance: 


instance Monad (MaybeKT m) where
    return a    = MKT (\k -> k a)
    MKT m >>= f = MKT (\k -> m (\a -> case f a of MKT n -> n k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unification-fd-0.9.0/src/Control/Monad/EitherK.hs
Applicative instance: 


instance Applicative (EitherK e) where
    pure   = return
    (<*>)  = ap
    (*>)   = (>>)
    x <* y = x >>= \a -> y >> return a
Monad instance: 


instance Monad (EitherK e) where
    return a   = EK (\k -> k a)
    EK m >>= f = EK (\k -> m (\a -> case f a of EK n -> n k))
Applicative instance: 


instance Applicative (EitherKT e m) where
    pure   = return
    (<*>)  = ap
    (*>)   = (>>)
    x <* y = x >>= \a -> y >> return a
Monad instance: 


instance Monad (EitherKT e m) where
    return a    = EKT (\k -> k a)
    EKT m >>= f = EKT (\k -> m (\a -> case f a of EKT n -> n k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/comonad-5/src/Control/Comonad/Trans/Env.hs
Applicative instance: 


instance (Monoid e, Applicative m) => Applicative (EnvT e m) where
  pure = EnvT mempty . pure
  EnvT ef wf <*> EnvT ea wa = EnvT (ef `mappend` ea) (wf <*> wa)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/comonad-5/src/Control/Comonad/Trans/Store.hs
Applicative instance: 


instance (Applicative w, Monoid s) => Applicative (StoreT s w) where
  pure a = StoreT (pure (const a)) mempty
  StoreT ff m <*> StoreT fa n = StoreT ((<*>) <$> ff <*> fa) (mappend m n)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/comonad-5/src/Control/Comonad/Trans/Traced.hs
Applicative instance: 


instance Applicative w => Applicative (TracedT m w) where
  pure = TracedT . pure . const
  TracedT wf <*> TracedT wa = TracedT (ap <$> wf <*> wa)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/infix-0.1.1/Language/Haskell/Infix.hs
Monad instance: 


instance Monad Infix where
    return a
        = Infix (\state -> (a, state))
    Infix comp >>= fun
        = Infix (\state ->
                        let (result, newState) = comp state
                            Infix comp' = fun result
                        in comp' newState)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/text-postgresql-0.0.2.1/src/Control/Monad/Either/Plus.hs
Applicative instance: 


instance Applicative (EitherP e) where
  pure   =  EitherP . pure
  EitherP a <*> EitherP b  =  EitherP $ a <*> b
Monad instance: 


instance Monad (EitherP e) where
  (EitherP e) >>= f  =  EitherP (e >>= unEitherP . f)
  return             =  EitherP . return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mida-1.0.1/src/Mida/Language/Element.hs
Applicative instance: 


instance Applicative Element where
  pure           = Val
  (Val  f) <*> x = f <$> x
  (Sec  f) <*> x = Sec  $ (<*> x) <$> f
  (Mul  f) <*> x = Mul  $ (<*> x) <$> f
  (CMul f) <*> x = CMul $ (((<*> x) <$>) *** ((<*> x) <$>)) <$> f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tersmu-0.2.1/Pappy/Parse.hs
Monad instance: 
           -- unconditional error labeling

-- Standard monadic combinators
instance Derivs d => Monad (Parser d) where

        -- Sequencing combinator
        (Parser p1) >>= f = Parser parse

                where parse dvs = first (p1 dvs)

                      first (Parsed val rem err) =
                        let Parser p2 = f val
                        in second err (p2 rem)
                      first (NoParse err) = NoParse err

                      second err1 (Parsed val rem err) =
                        Parsed val rem (joinErrors err1 err)
                      second err1 (NoParse err) =
                        NoParse (joinErrors err1 err)

        -- Result-producing combinator
        return x = Parser (\dvs -> Parsed x dvs (nullError dvs))

        -- Failure combinator
        fail [] = Parser (\dvs -> NoParse (nullError dvs))
        fail msg = Parser (\dvs -> NoParse (msgError (dvPos dvs) msg))
Applicative instance: 


instance Derivs d => Applicative (Parser d) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/XMPP-0.1.2/Network/XMPP/XMPPMonad.hs
Monad instance: 


instance Monad XMPP where
    f >>= g = XMPP $
              \c state ->
                  do
                    (state', result) <- xmppFn f c state
                    case result of
                      XMPPJust a ->
                          xmppFn (g a) c state'
                      WaitingFor pred mangler keep ->
                          return $ (state',
                                    WaitingFor pred
                                    (\stanza -> (mangler stanza) >>= g) keep)
    return a = XMPP $ \_ state -> return (state, XMPPJust a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monte-carlo-0.6.1/lib/Control/Monad/MC/GSLBase.hs
Applicative instance: 


instance (Applicative m) => Applicative (MC m) where
    pure a = MC $ \_ -> pure a
    {-# INLINE pure #-}

    (MC gf) <*> (MC ga) = MC $ \r -> (gf r) <*> (ga r)
    {-# INLINE (<*>) #-}
Monad instance: 


instance (Monad m) => Monad (MC m) where
    return a = MC $ \_ -> return a
    {-# INLINE return #-}

    (MC m) >>= k =
        MC $ \r -> m r >>= \a ->
            let (MC m') = k a
            in m' r
    {-# INLINE (>>=) #-}

    fail msg = MC $ \_ -> fail msg
    {-# INLINE fail #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ConcurrentUtils-0.4.4.0/Control/CUtils/AList.hs
Monad instance: 


instance Monad AList where
        return x = List [x]
        Append ls ls2 >>= f = ((ls >>= f) `par` (ls2 >>= f)) `pseq` Append (ls >>= f) (ls2 >>= f)
        List ls >>= f = foldr mplus mzero (map f ls)
Applicative instance: 


instance Applicative AList where
        pure = return
        (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/parsek-1.0.1.3/Text/ParserCombinators/Parsek.hs
Monad instance: 


instance Monad (Parser s) where
  return a = Parser (\fut -> fut a)

  Parser f >>= k =
    Parser (\fut -> f (\a -> let Parser g = k a in g fut))

  fail s = Parser (\_fut exp -> Fail [(exp,s)])
Applicative instance: 


instance Applicative (Parser s) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/csp-1.3/src/Control/Monad/CSP.hs
Applicative instance: 


instance Applicative (CSP r) where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad (CSP r) where
    CSP x >>= y = CSP (\s -> x s >>= (\(CSP z) -> z s) . y)
    return a = CSP (\_ -> return a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/RxHaskell-0.2/Signal.hs
Monad instance: 


instance Scheduler s => Monad (Signal s) where
    return v =
        Signal $ \sub -> do
            send sub (NextEvent v)
            send sub CompletedEvent
            return EmptyDisposable

    s >>= f =
        Signal $ \sub -> do
            sc <- liftIO $ newIORef (1 :: Word32)
            ds <- liftIO newDisposableSet

            let decSubscribers = do
                    rem <- liftIO $ atomicModifyIORef sc $ \n ->
                        let n' = n - 1
                        in (n', n')

                    when (rem == 0) $ send sub CompletedEvent

                onInner CompletedEvent = decSubscribers
                onInner ev = send sub ev

                onOuter CompletedEvent = decSubscribers
                onOuter (ErrorEvent e) = send sub $ ErrorEvent e
                onOuter (NextEvent v) = do
                    liftIO $ atomicModifyIORef sc $ \n -> (n + 1, ())

                    d <- f v >>: onInner
                    liftIO $ ds `addDisposable` d

            d <- s >>: onOuter
            liftIO $ ds `addDisposable` d
            liftIO $ toDisposable ds
Applicative instance: 


instance Scheduler s => Applicative (Signal s) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/RxHaskell-0.2/Scheduler/Internal.hs
Monad instance: 


instance Scheduler s => Monad (SchedulerIO s) where
    return v = SchedulerIO $ \_ -> return v
    (SchedulerIO mf) >>= f =
        SchedulerIO $ \sch -> do
            v <- mf sch

            let unwrap sch (SchedulerIO mf') = mf' sch
            unwrap sch $ f v
Applicative instance: 


instance Scheduler s => Applicative (SchedulerIO s) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/first-and-last-0.1.0.1/src/Data/Monoid/Last.hs
Applicative instance: 


instance KnownNat n => Applicative (Last' n) where
  Last' l <*> Last' r = Last' $ l <*> r
  pure a = case natVal (Proxy :: Proxy n) of
    0 -> mempty
    _ -> Last' $ pure a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/first-and-last-0.1.0.1/src/Data/Monoid/First.hs
Applicative instance: 


instance KnownNat n => Applicative (First' n) where
  First' l <*> First' r = First' $ l <*> r
  pure a = case natVal (Proxy :: Proxy n) of
    0 -> mempty
    _ -> First' $ pure a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ms-0.2.1/src/Math/MetricSpace.hs
Applicative instance: 


instance Applicative (MetricSpace a) where
  pure = MetricSpace . const . const
  {-# INLINE pure #-}
  MetricSpace f <*> MetricSpace a = MetricSpace (\x y -> f x y (a x y))
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad (MetricSpace a) where
  return = pure
  {-# INLINE return #-}
  MetricSpace f >>= fn =
    MetricSpace (\x y -> let MetricSpace s =  fn (f x y) in s x y)
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/llvm-tf-3.1/src/LLVM/Core/Vector.hs
Applicative instance: 


instance (Dec.Positive n) => Applicative (Vector n) where
   pure = replicate
   f <*> a =
      withUnaryDecVector
         (unaryFromDecimalVector f <*> unaryFromDecimalVector a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/llvm-tf-3.1/src/LLVM/Util/Proxy.hs
Applicative instance: 


instance Applicative Proxy where
   pure _ = Proxy
   Proxy <*> Proxy = Proxy
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/free-theorems-seq-1.0/src/Language/Haskell/FreeTheorems/Variations/PolySeq/M.hs
Monad instance: 


instance Monad M where
    return a = M (\s -> [(a,s)])
    M m >>= k = M (\s -> concatMap (\(a,s') -> case k a of M l -> l s') (m s))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/DrIFT-2.4.2/src/ParseLib2.hs
Monad instance: 


instance Monad Parser where
   -- return      :: a -> Parser a
   return v        = P (\pos inp -> [(v,inp)])

   -- >>=         :: Parser a -> (a -> Parser b) -> Parser b
   (P p) >>= f     = P (\pos inp -> concat [papply (f v) pos out
                                                | (v,out) <- p pos inp])
   fail s          = P (\pos inp -> [])
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/safe-access-0.3.0.0/src/Control/SafeAccess.hs
Monad instance: 


instance Monad m => Monad (SafeAccessT d m) where
  return = SafeAccessT . const . return . Right
  ma >>= f = SafeAccessT $ \caps -> do
    ex <- runSafeAccessT ma caps
    case ex of
      Left d  -> return $ Left d
      Right x -> runSafeAccessT (f x) caps
Applicative instance: 


instance Applicative f => Applicative (SafeAccessT d f) where
  pure = SafeAccessT . const . pure . Right
  safef <*> safea = SafeAccessT $ \caps ->
    let fef = runSafeAccessT safef caps
        fea = runSafeAccessT safea caps
        ff  = flip fmap fef $ \ef -> case ef of
                Left d  -> const $ Left d
                Right f -> fmap f
    in ff <*> fea
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hexpat-iteratee-0.6/Text/XML/Expat/Chunked.hs
Monad instance: 


instance Monad m => Monad (XMLT s m) where
    return a = XMLT $ return $ Result a
    f >>= g = XMLT $ do
        res1 <- runXMLT f
        case res1 of
            Yield c        -> return $ Yield (c >>= g)
            Result a       -> runXMLT (g a)
            HandlerErr err -> return $ HandlerErr err
    fail err = XMLT $ return $ HandlerErr err
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/graph-rewriting-0.7.8/GraphRewriting/Pattern.hs
Monad instance: 


instance Monad m ⇒ Monad (PatternT n m) where
        return x = PatternT $ \h → return ([],x)
        p >>= f = PatternT $ \h → do
                (m1,x) ← patternT p h
                (m2,y) ← patternT (f x) (reverse m1 ⧺ h)
                return (m1 ⧺ m2, y)
        fail str = PatternT $ \h → lift (fail str)
Applicative instance: 


-- TODO: Change constraint from Monad m if possible
instance Monad m ⇒ Applicative (PatternT n m) where
        pure = return
        f <*> x = do
                f' ← f
                f' <$> x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/graph-rewriting-0.7.8/GraphRewriting/Rule.hs
Monad instance: 



instance Monad (Replace n) where
        return x = Replace $ return (x, [])
        Replace r1 >>= f = Replace $ do
                (x1, merges1) ← r1
                let Replace r2 = f x1
                (y, merges2) ← r2
                return (y, merges1 ⧺ merges2)
Applicative instance: 


instance Applicative (Replace n) where
        Replace rf <*> Replace rx = Replace $ do
                (f, merges1) ← rf
                (x, merges2) ← rx
                return (f x, merges1 ⧺ merges2)
        pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haddock-leksah-2.6.0/src/Haddock/Interface/Rn.hs
Monad instance: 

instance Monad Id where (Id v)>>=f = f v; return = Id
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/FailureT-15778.1/Control/Monad/Failure.hs
Applicative instance: 


instance Applicative m => Applicative (FailureT f m) where {
  pure = FailureT ∘ pure ∘ Right;
  FailureT f <*> FailureT x = let {
    go (Right φ) (Right χ) = Right (φ χ);
    go (Right _) (Left  e) = Left e;
    go (Left  e)  _        = Left e;
  } in FailureT (liftA2 go f x);
};
Monad instance: 


instance Monad m => Monad (FailureT f m) where {
  return = lift ∘ return;
  FailureT x >>= f = FailureT $ x >>= liftM join ∘ either (liftM Left ∘ return) (liftM Right ∘ runFailureT ∘ f);
};
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-timing-0.1.0.1/src/Control/Monad/Timing.hs
Applicative instance: 


instance Applicative m => Applicative (TimingT m) where
    pure x = TimingT (pure (x, []))
    TimingT f <*> TimingT a' = TimingT $
        liftA2 (\ (a,b) (c,d) -> (a c, b ++ d)) f a'
Monad instance: 


instance Monad m => Monad (TimingT m) where
    TimingT a >>= f = TimingT $ do
        (thing1, b) <- a
        (thing2, c) <- runTimingT $ f thing1
        return (thing2, condenseTree $ b ++ c)
        where
            condenseTree = map (foldl collapseNodes emptyNode)
                         . groupBy ((==) `on` (fst . rootLabel)) where
                collapseNodes (Node (_, x) sub) (Node (t, x1) sub2)
                    = Node (t, x + x1) (condenseTree $ sub ++ sub2)
                emptyNode = Node ("", 0) []
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/conduit-find-0.1.0.3/Data/Cond.hs
Applicative instance: 


instance Monad m => Applicative (CondT a m) where
    pure  = return
    {-# INLINE pure #-}
    (<*>) = ap
    {-# INLINE (<*>) #-}
Monad instance: 


instance Monad m => Monad (CondT a m) where
    return = CondT . return . accept'
    {-# INLINE return #-}
    fail _ = mzero
    {-# INLINE fail #-}
    CondT f >>= k = CondT $ do
        r <- f
        case r of
            Ignore -> return Ignore
            Keep b -> do
                n <- getCondT (k b)
                return $ case n of
                    RecurseOnly _      -> Ignore
                    KeepAndRecurse c _ -> Keep c
                    _                  -> n
            RecurseOnly l -> return $ RecurseOnly (fmap (>>= k) l)
            KeepAndRecurse b _ -> getCondT (k b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/commodities-0.2.0/Ledger/Balance.hs
Applicative instance: 


instance Applicative Balance where
    pure = Plain

    Zero <*> _ = Zero
    _ <*> Zero = Zero

    Plain f <*> Plain qy     = Plain (f qy)
    Plain f <*> Amount cy qy = Amount cy (f qy)
    Amount cx f <*> Plain qy = Amount cx (f qy)
    Plain f <*> Balance xs   = Balance $ fmap f xs
    Balance fs <*> Plain qy  = Balance $ fmap ($ qy) fs

    Amount cx f <*> Amount cy qy
        | cx == cy = Amount cy (f qy)
        | otherwise = Zero

    Amount cx f <*> Balance xs =
        maybe Zero (Amount cx . f) $ IntMap.lookup cx xs
    Balance fs <*> Amount cy qy =
        maybe Zero (\f -> Amount cy (f qy)) $ IntMap.lookup cy fs

    Balance fs <*> Balance ys =
        Balance $ IntMap.intersectionWith ($) fs ys
Monad instance: 


instance Monad Balance where
    return = Plain
    (>>=)  = (>>-)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ordrea-0.3.0.0/FRP/Ordrea/Base.hs
Applicative instance: 


instance Applicative Discrete where
  pure = pureDiscrete
  (<*>) = apDiscrete
Applicative instance: 


instance Applicative Behavior where
  pure x = Beh (bottomPrio bottomLocation) (return $ pure x)
  Beh f_prio f_init <*> Beh a_prio a_init =
      Beh (max f_prio a_prio) $ transparentMemoS $ do
    f_pull <- f_init
    a_pull <- a_init
    return $ f_pull <*> a_pull
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-tx-0.0.1/Control/Monad/Tx.hs
Monad instance: 

instance Monad (TxM o s) where
  return a = TxM (\s k -> k s a)
  TxM g >>= f = TxM (\s k -> g s (\s a -> unTxM (f a) s k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/attoparsec-text-0.8.5.3/tests/QCSupport.hs
Applicative instance: 


instance Applicative NonEmpty where
    NonEmpty f <*> NonEmpty a = NonEmpty (f a)
    pure a                    = NonEmpty a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/math-functions-0.2.0.1/Numeric/Series.hs
Applicative instance: 


instance Applicative Sequence where
  pure a = Sequence () (\() -> (a,()))
  Sequence sA fA <*> Sequence sB fB = Sequence (sA,sB) $ \(!sa,!sb) ->
    let (a,sa') = fA sa
        (b,sb') = fB sb
    in (a b, (sa',sb'))
  {-# INLINE pure  #-}
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/math-functions-0.2.0.1/Numeric/RootFinding.hs
Monad instance: 


instance Monad Root where
    NotBracketed >>= _ = NotBracketed
    SearchFailed >>= _ = SearchFailed
    Root a       >>= m = m a

    return = Root
Applicative instance: 


instance Applicative Root where
    pure  = Root
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hws-1.1.0.1/src/Parser.hs
Monad instance: 



-----------------------------------------------------------
-- Monad: return, sequence (>>=) and fail
-----------------------------------------------------------    
instance Monad Parser where
  return x
    = Parser (\state -> Empty (Ok x state (unknownError state)))

  (Parser p) >>= f
    = Parser (\state ->
        case (p state) of
          Consumed reply1
            -> Consumed $
               case (reply1) of
                 Ok x state1 err1 -> case runP (f x) state1 of
                                       Empty reply2    -> mergeErrorReply err1 reply2
                                       Consumed reply2 -> reply2
                 Error err1       -> Error err1

          Empty reply1
            -> case (reply1) of
                 Ok x state1 err1 -> case runP (f x) state1 of
                                       Empty reply2 -> Empty (mergeErrorReply err1 reply2)
                                       other        -> other
                 Error err1       -> Empty (Error err1)
      )


  fail msg
    = Parser (\state ->
        Empty (Error (newErrorMessage (Message msg) (statePos state))))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wai-predicates-0.9.0/src/Data/Predicate/Result.hs
Applicative instance: 


instance Applicative (Result f) where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad (Result f) where
    return           = Okay 0
    (Okay _ x) >>= k = k x
    (Fail   x) >>= _ = Fail x
Applicative instance: 


instance Monad m => Applicative (ResultT f m) where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad m => Monad (ResultT f m) where
    return  = ResultT . return . return
    m >>= k = ResultT $ runResultT m >>= \a -> case a of
        Okay _ x -> runResultT (k x)
        Fail   x -> return (Fail x)
    fail = ResultT . fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/flexiwrap-0.1.0/Data/Wrap.hs
Applicative instance: 


instance Wrapper f => Applicative (Wrap f) where
    pure = wrap
    (<*>) = inWrapper . unwrap
Monad instance: 


instance Wrapper f => Monad (Wrap f) where
    return = wrap
    (>>=) = flip (. unwrap)
Applicative instance: 


-- cofmapFC = inO.fmap.cofmap

instance (Wrapper f, Applicative g) => Applicative (InnerWrapT f g) where
    pure = InnerWrapT . pure . wrap
    (<*>) = inInnerWrapT2 $ (<*>) . fmap (<*>)
Applicative instance: 

    -- (<*>) = inInnerWrapT2 $ inCompose2 (fmap unwrap) (fmap wrap) (<*>)
    {-
    (<*>) :: Wrap f (a -> b) -> Wrap f a -> Wrap f b
    fmap (<*>) :: g (Wrap f (a -> b)) -> g (Wrap f a -> Wrap f b)
    (<*>) . fmap (<*>) :: g (Wrap f (a -> b)) -> g (Wrap f a) -> g (Wrap f b)
    -}

instance (Wrapper f, Applicative g) => Applicative (OuterWrapT f g) where
    pure = OuterWrapT . wrap . pure
    (<*>) = inOuterWrapT2 $ (<*>) . fmap (<*>)
Monad instance: 

    {-
    sequenceA = fmap OuterWrapT . T.sequenceA .
        fmap T.sequenceA . runOuterWrapT
    -}
    {-
    OuterWrapT f g (h a)
    -> runOuterWrapT ->
    Wrap f (g (h a))
    -> fmap sequenceA ->
    Wrap f (h (g a))
    -> sequenceA ->
    h (Wrap f (g a))
    -> fmap OuterWrapT ->
    h (OuterWrapT f g a)
    -}

instance (Wrapper f, Monad g) => Monad (InnerWrapT f g) where
    return = InnerWrapT . return . wrap
    a >>= f = InnerWrapT $ runInnerWrapT a >>= runInnerWrapT . f . unwrap
Monad instance: 


instance (Wrapper f, Monad g) => Monad (OuterWrapT f g) where
    return = OuterWrapT . wrap . return
    a >>= f = OuterWrapT . wrap $
        unwrap (runOuterWrapT a) >>= unwrap . runOuterWrapT . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/flexiwrap-0.1.0/Data/Flex/WrapT.hs
Applicative instance: 


instance forall t f r. (Apply (FWPure t f) r (WrapPure (FWT t f)),
            Apply (FWCombine t f) r (WrapCombine (FWT t f)),
            FWApplicative (FWT t f) r,
            Functor (FWT t f)
        ) =>
        Applicative (FWT t f) where
    pure = unwrapPure $ apply (undefined :: FWPure t f) (undefined :: r)
    (<*>) = unwrapCombine $ apply (undefined :: FWCombine t f) (undefined :: r)
Monad instance: 


instance forall t m r. (Apply (FWReturn t m) r (WrapReturn (FWT t m)),
            Apply (FWBind t m) r (WrapBind (FWT t m)),
            FWMonad (FWT t m) r
        ) =>
        Monad (FWT t m) where
    return = unwrapReturn $
        apply (undefined :: FWReturn t m) (undefined :: r)
    (>>=) = unwrapBind $ apply (undefined :: FWBind t m) (undefined :: r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/flexiwrap-0.1.0/Data/Flex/Wrap.hs
Applicative instance: 


instance Applicative (FW t) where
    pure = FlexiWrap
    (<*>) = inFlexiWrap . unFlexiWrap
Monad instance: 


instance Monad (FW t) where
    return = FlexiWrap
    (>>=) = flip (. unFlexiWrap)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/flexiwrap-0.1.0/Data/Flex/WrapCTC.hs
Monad instance: 


instance forall t o m n r. (
            Apply (FWReturn t (o m n)) r (WrapReturn (FWCTC t o m n)),
            Apply (FWBind t (o m n)) r (WrapBind (FWCTC t o m n)),
            FWMonad (FWCTC t o m n) r
        ) =>
        Monad (FWCTC t o m n) where
    return = unwrapReturn $
        apply (undefined :: FWReturn t (o m n)) (undefined :: r)
    (>>=) = unwrapBind $ apply (undefined :: FWBind t (o m n)) (undefined :: r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/flexiwrap-0.1.0/Data/Flex/Test/WrappedMonad.hs
Monad instance: 


instance Monad m => Monad (TestMonad m) where
    return = TM . return
    (>>=) = bindWrapper unTM TM (>>=)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactive-0.9.9/src/FRP/Reactive/Fun.hs
Applicative instance: 


instance Applicative (Fun t) where
  pure        = K
  K f <*> K x = K   (f x)
  cf  <*> cx  = Fun (apply cf <*> apply cx)
Monad instance: 


instance Monad (Fun t) where
  return = pure
  K   a >>= h = h a
  Fun f >>= h = Fun (f >>= apply . h)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactive-0.9.9/src/FRP/Reactive/PrimReactive.hs
Applicative instance: 


-- standard instance
instance Ord t => Applicative (EventG t) where
  pure = return
  _ <*> (Event (Future (Max MaxBound,_))) = mempty
  x <*> y = x `ap` y
Applicative instance: 


instance Ord t => Applicative (ReactiveG t) where
  pure a = a `stepper` mempty
  -- Standard definition.  See 'Zip'.
  rf <*> rx = zipWith ($) rf rx
Monad instance: 


-- A wonderful thing about the <*> definition for ReactiveG is that it
-- automatically caches the previous value of the function or argument
-- when the argument or function changes.


instance Ord t => Monad (EventG t) where
  return a = Event (pure (pure a))
  e >>= f  = joinE (fmap f e)
Monad instance: 


-- Standard instance for Applicative w/ join
instance Ord t => Monad (ReactiveG t) where
  return  = pure
  r >>= f = joinR (f <$> r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactive-0.9.9/src/Data/PairMonad.hs
Monad instance: 



-- Orphan instance:

-- Equivalent to the Monad Writer instance.
instance Monoid o => Monad ((,) o) where
  return      = pure
  (o,a) >>= f = (o `mappend` o', a') where (o',a') = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/clean-unions-0.1.1/src/Data/OpenUnion1/Clean.hs
Applicative instance: 


instance Applicative Id where
  pure = Id
  Id f <*> Id a = Id (f a)
Applicative instance: 


instance Applicative (C a) where
  pure _ = C Nothing
  C (Just a) <*> C _ = C (Just a)
  C _ <*> C b = C b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/strict-data-0.1.1.0/src/Data/Option.hs
Applicative instance: 


instance Applicative Option where
    pure = Some
    {-# INLINE pure #-}

    f <*> x =
        case f of
          Some g -> fmap g x
          None -> None
    {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Option where
    (Some x) >>= k = k x
    None  >>= _ = None
    (>>) = (*>)
    fail _ = None
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/generator-0.5.5/src/Control/Monad/Generator.hs
Monad instance: 


instance Monad m => Monad (GeneratorT v m) where
    return = GeneratorT . return
    GeneratorT a >>= f = GeneratorT $ a >>= runGeneratorT . f
    fail = lift . fail
Applicative instance: 


instance Monad m => Applicative (GeneratorT v m) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ldap-client-0.1.0/src/Ldap/Asn1/FromAsn1.hs
Applicative instance: 


instance Applicative (Parser s) where
  pure x = Parser (\s -> pure (s, x))
  Parser mf <*> Parser mx = Parser $ \s -> do
    (s', f)  <- mf s
    (s'', x) <- mx s'
    pure (s'', f x)
Monad instance: 


instance Monad (Parser s) where
  return x = Parser (\s -> return (s, x))
  Parser mx >>= k =
    Parser (mx >=> \(s', x) -> unParser (k x) s')
  fail _ = empty
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/MonadCompose-0.8.4.2/Control/Monad/PlusMonad.hs
Monad instance: 


instance (Dist m, Dist n, Monad m, Monad n) => Monad (Composition m n) where
        return = Rtn
        Composition m >>= f = Composition ((fmap (fmap Composition)
                . distributive
                . fmap distributive
                . fmap (fmap (bringDown . (>>= f))))
                m)
        Rtn x >>= f = f x
        fail = Composition . fail
Applicative instance: 


instance (Dist m, Dist n, Monad m, Monad n) => Applicative (Composition m n) where
        pure = return
        (<*>) = ap
Monad instance: 


instance Monad File where
        return = File . return
        File m >>= f = File (m >>= \x -> case f x of File m -> m)
        fail = File . fail
Applicative instance: 


instance Applicative File where
        pure = return
        (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/MonadCompose-0.8.4.2/Control/Monad/IOT.hs
Monad instance: 


instance (Monad m) => Monad (IOT m) where
        {-# INLINE return #-}
        return x = IOT $ \s -> return (s, x)
        {-# INLINE (>>=) #-}
        IOT f >>= g = IOT $ \s -> f s >>= \(s, x) -> let IOT h = g x in h s
Applicative instance: 


instance (Monad m) => Applicative (IOT m) where
        {-# INLINE pure #-}
        pure = return
        {-# INLINE (<*>) #-}
        (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/backward-state-0.1.0.2/src/Control/Monad/Trans/BackwardState.hs
Applicative instance: 


instance (Functor m, MonadFix m) => Applicative (BackwardStateT s m) where
    pure = return
    (<*>) = ap
Monad instance: 



instance (MonadFix m) => Monad (BackwardStateT s m) where
    return x = BackwardStateT $ \s -> return (x, s)
    m >>= f = BackwardStateT $ \s'' -> do
        rec (x, s) <- runBackwardStateT m s'
            (y, s') <- runBackwardStateT (f x) s''
        return (y, s)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/MonadRandomLazy-0.1.1.1/Control/Monad/LazyRandom.hs
Applicative instance: 


instance RandomGen g => Applicative (Rand g) where
  pure  = return
  (<*>) = ap
Monad instance: 


instance RandomGen g => Monad (Rand g) where
  return x = MkRand (const x)

  MkRand m >>= k =
    MkRand (\r ->
      let (r1,r2)  = split r
          MkRand m' = k (m r1)
       in m' r2
    )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/boundingboxes-0.2.3/Data/BoundingBox.hs
Applicative instance: 


instance Applicative f => Applicative (Box f) where
    pure a = Box (pure a) (pure a)
    {-# INLINE pure #-}
    Box f g <*> Box a b = Box (f <*> a) (g <*> b)
    {-# INLINE (<*>) #-}
Monad instance: 


instance Monad f => Monad (Box f) where
    return a = Box (return a) (return a)
    {-# INLINE return #-}
    Box f g >>= k = Box (f >>= \x -> let Box p _ = k x in p) (g >>= \x -> let Box _ q = k x in q)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hyena-0.1.0.1/Hyena/Parser.hs
Applicative instance: 


instance Applicative Parser where
    pure a = Parser $ \s succ -> succ a s
    {-# INLINE pure #-}

    p <*> p' = Parser $ \s succ ->
               let succ' f s' = unParser p' s' (succ . f)
               in unParser p s succ'
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/trivia-0.0/Control/Monad/One.hs
Monad instance: 


instance Monad One where
    return _ = One
    {-# INLINE return #-}
    _ >>= _ = One
    {-# INLINE (>>=) #-}
Applicative instance: 


instance Applicative One where
    pure _ = One
    {-# INLINE pure #-}
    _ <*> _ = One
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/h-booru-0.3.0.0/src/HBooru/Types.hs
Applicative instance: 


instance Applicative (LA XmlTree) where
  pure x = LA . const $ return x
  (<*>) = ap
Monad instance: 


instance Monad (LA XmlTree) where
  return = pure
  (>>=) = bA
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/text-1.2.2.1/Data/Text/Internal/Read.hs
Applicative instance: 


instance Applicative (IParser t) where
    pure a = P $ \t -> Right (a,t)
    {-# INLINE pure #-}
    (<*>) = ap
Monad instance: 


instance Monad (IParser t) where
    return = App.pure
    m >>= k  = P $ \t -> case runP m t of
                           Left err     -> Left err
                           Right (a,t') -> runP (k a) t'
    {-# INLINE (>>=) #-}
    fail msg = P $ \_ -> Left msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/text-xml-generic-0.1.1/src/Text/XML/Generic.hs
Monad instance: 





instance Monad (Either String) where
  return v = Right v
  fail s = Left s
  (Left s) >>= _ = Left s
  (Right v) >>= f = f v
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tokenize-0.3.0/src/NLP/Tokenize/Text.hs
Monad instance: 


instance Monad (EitherList a) where
    return x = E [Right x]
    E xs >>= f = E $ concatMap (either (return . Left) (unE . f)) xs
Applicative instance: 


instance Applicative (EitherList a) where
    pure x = return x
    f <*> x = f `ap` x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tokenize-0.3.0/src/NLP/Tokenize/String.hs
Monad instance: 


instance Monad (EitherList a) where
    return x = E [Right x]
    E xs >>= f = E $ concatMap (either (return . Left) (unE . f)) xs
Applicative instance: 


instance Applicative (EitherList a) where
    pure x = return x
    f <*> x = f `ap` x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/nonfree-0.1.0.1/Data/Monoid/Nonfree.hs
Applicative instance: 


instance Applicative (FromN e) where
  pure x = FromN $ \r -> case r of
    NEmpty -> x
    _ -> error "FromN pure: invalid structure (expected NEmpty)"
  FromN mf <*> FromN mx = FromN $ \r ->
    case r of
      NAppend a b -> mf a (mx b)
      _ -> error "FromN (<*>): invalid structure (expected NAppend)"
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/state-plus-0.1.2/Control/Monad/Trans/State/Plus.hs
Monad instance: 


instance Monad m => Monad (StatePlusT s m) where
    return = lift . return
    x >>= f = (MkSPT . StateT) go
        where go s = do
                    (a, s') <- runStateT (unSPT x) s
                    if fst s'
                            then runStateT (unSPT $ f a) s'
                            else return $ (mzeroError, s')
Applicative instance: 


instance (Monad m, Functor m) => Applicative (StatePlusT s m) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/atomo-0.4.0.2/src/Atomo/Kernel/Regexp.hs
Monad instance: 


instance Monad MkRegex where
    return = RegexOK
    fail = Failed

    Failed x >>= _ = Failed x
    RegexOK a >>= f = f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lp-diagrams-2.0.0/Graphics/Diagrams/Types.hs
Applicative instance: 


instance Applicative Point' where
  pure x = Point x x
  Point f g <*> Point x y = Point (f x) (g y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lp-diagrams-2.0.0/Graphics/Diagrams/Core.hs
Applicative instance: 

instance Applicative (R env) where
  pure x = R (\_ -> x)
  R f <*> R x = R (\rho -> (f rho) (x rho))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Adaptive-Blaisorblade-0.23/Control/Monad/Adaptive/OrderedList.hs
Monad instance: 


instance Ref m r => Monad (OrderedList m r a) where
  return a = inM (return a)
  (OL m) >>= f = OL $ \e -> m e >>= \a -> deOL (f a) e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Adaptive-Blaisorblade-0.23/Control/Monad/Adaptive.hs
Monad instance: 


instance Ref m r => Monad (Changeable m r) where
  return a   = Ch $ \k -> k a
  Ch m >>= f = Ch $ \k -> m $ \a -> deCh (f a) k
Monad instance: 


instance Ref m r => Monad (Adaptive m r) where
  return a   = Ad $ \e -> return a
  Ad m >>= f = Ad $ \e -> m e >>= \a -> deAd (f a) e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/effects-0.2.2/src/Control/Effects.hs
Applicative instance: 


instance Applicative (Layer e m) where
  pure a   = Layer $ \k -> k a
  m <*> v  = Layer $ \k -> runLayer m (\f -> runLayer v (k . f))
Monad instance: 


instance Monad (Layer e m) where
  return a = Layer $ \k -> k a
  m >>= f  = Layer $ \k -> runLayer m (\a -> runLayer (f a) k)
Applicative instance: 


instance Applicative Pure where
  pure = Pure
  Pure f <*> Pure a = Pure (f a)
Monad instance: 


instance Monad Pure where
  return = Pure
  Pure a >>= f = f a
Applicative instance: 


instance Applicative m => Applicative (Base m) where
  pure = Base . pure
  Base m <*> Base v = Base (m <*> v)
Monad instance: 


instance Monad m => Monad (Base m) where
  return = Base . return
  Base m >>= f = Base $ m >>= runBase . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/xhtml-combinators-0.3/src/Text/XHtmlCombinators/Internal.hs
Applicative instance: 


instance (Functor t, Monad t) => Applicative (XHtmlMT x t) where
    -- Could define better instance that would
    -- just require Applicative t =>
    pure = return

    (<*>) = ap
Monad instance: 


instance Monad t => Monad (XHtmlMT x t) where
    return = XHtmlMT . return

    (XHtmlMT w) >>= f = XHtmlMT $ w >>= unXHtmlMT . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/roshask-0.2.1/src/Ros/Topic.hs
Applicative instance: 


instance Applicative m => Applicative (Topic m) where
  pure x = let t = Topic $ pure (x, t) in t
  Topic ma <*> Topic mb = Topic $ uncurry (***) . (($) *** (<*>)) <$> ma <*> mb
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hburg-1.1.2/hburg/hburg-tmp/Parser/Lexer.hs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kure-2.8.0/examples/Lam/Monad.hs
Monad instance: 


instance Monad LamM where
  return a = LamM (\n -> (n,Right a))
  (LamM f) >>= gg = LamM $ \ n -> case f n of
                                    (n', Left msg) -> (n', Left msg)
                                    (n', Right a)  -> lamM (gg a) n'
  fail msg = LamM (\ n -> (n, Left msg))
Applicative instance: 


instance Applicative LamM where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kure-2.8.0/Language/KURE/Translate.hs
Applicative instance: 


-- | Lifting through a Reader transformer, where (c,a) is the read-only environment.
instance Applicative m => Applicative (Translate c m a) where

-- pure :: b -> Translate c m a b
   pure = constT . pure
   {-# INLINE pure #-}

-- (<*>) :: Translate c m a (b -> d) -> Translate c m a b -> Translate c m a d
   tf <*> tb = translate (\ c a -> apply tf c a <*> apply tb c a)
   {-# INLINE (<*>) #-}
Monad instance: 


-- | Lifting through a Reader transformer, where (c,a) is the read-only environment.
instance Monad m => Monad (Translate c m a) where

-- return :: b -> Translate c m a b
   return = constT . return
   {-# INLINE return #-}

-- (>>=) :: Translate c m a b -> (b -> Translate c m a d) -> Translate c m a d
   t >>= f = translate $ \ c a -> do b <- apply t c a
                                     apply (f b) c a
   {-# INLINE (>>=) #-}

-- fail :: String -> Translate c m a b
   fail = constT . fail
   {-# INLINE fail #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kure-2.8.0/Language/KURE/Walker.hs
Monad instance: 


instance (Monoid w, Monad m) => Monad (AllT w m) where
-- return :: a -> AllT w m a
   return a = AllT $ return (P a mempty)
   {-# INLINE return #-}

-- fail :: String -> AllT w m a
   fail = AllT . fail
   {-# INLINE fail #-}

-- (>>=) :: AllT w m a -> (a -> AllT w m d) -> AllT w m d
   ma >>= f = AllT $ do P a w1 <- unAllT ma
                        P d w2 <- unAllT (f a)
                        return (P d (w1 <> w2))
   {-# INLINE (>>=) #-}
Monad instance: 


instance Monad m => Monad (OneT w m) where
-- return :: a -> OneT w m a
   return a = OneT $ \ mw -> return (P a mw)
   {-# INLINE return #-}

-- fail :: String -> OneT w m a
   fail msg = OneT (\ _ -> fail msg)
   {-# INLINE fail #-}

-- (>>=) :: OneT w m a -> (a -> OneT w m d) -> OneT w m d
   ma >>= f = OneT $ do \ mw1 -> do P a mw2 <- unOneT ma mw1
                                    unOneT (f a) mw2
   {-# INLINE (>>=) #-}
Monad instance: 


instance Monad (GetChild c g) where
-- return :: a -> GetChild c g a
   return a = GetChild (return a) Nothing
   {-# INLINE return #-}

-- fail :: String -> GetChild c g a
   fail msg = GetChild (fail msg) Nothing
   {-# INLINE fail #-}

-- (>>=) :: GetChild c g a -> (a -> GetChild c g b) -> GetChild c g b
   (GetChild kma mcg) >>= k = runKureM (\ a   -> getChildSecond (mplus mcg) (k a))
                                       (\ msg -> GetChild (fail msg) mcg)
                                       kma
   {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kure-2.8.0/Language/KURE/Combinators/Translate.hs
Monad instance: 


instance Monad m => Monad (AnyR m) where
-- return :: a -> AnyR m a
   return = AnyR . return . PBool False
   {-# INLINE return #-}

-- fail :: String -> AnyR m a
   fail = AnyR . fail
   {-# INLINE fail #-}

-- (>>=) :: AnyR m a -> (a -> AnyR m d) -> AnyR m d
   ma >>= f = AnyR $ do PBool b1 a <- unAnyR ma
                        PBool b2 d <- unAnyR (f a)
                        return (PBool (b1 || b2) d)
   {-# INLINE (>>=) #-}
Monad instance: 


instance Monad m => Monad (OneR m) where
-- return :: a -> OneR m a
   return a = OneR (\ b -> return (PBool b a))
   {-# INLINE return #-}

-- fail :: String -> OneR m a
   fail msg = OneR (\ _ -> fail msg)
   {-# INLINE fail #-}

-- (>>=) :: OneR m a -> (a -> OneR m d) -> OneR m d
   ma >>= f = OneR $ \ b1 -> do PBool b2 a <- unOneR ma b1
                                unOneR (f a) b2
   {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kure-2.8.0/Language/KURE/MonadCatch.hs
Monad instance: 


instance Monad KureM where
-- return :: a -> KureM a
   return = Success
   {-# INLINE return #-}

-- (>>=) :: KureM a -> (a -> KureM b) -> KureM b
   (Success a)   >>= f = f a
   (Failure msg) >>= _ = Failure msg
   {-# INLINE (>>=) #-}

-- fail :: String -> KureM a
   fail = Failure
   {-# INLINE fail #-}
Applicative instance: 


instance Applicative KureM where
-- pure :: a -> KureM a
   pure = return
   {-# INLINE pure #-}

-- (<*>) :: KureM (a -> b) -> KureM a -> KureM b
   (<*>) = ap
   {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Dao-0.1.0.2/src/Dao/Parser.hs
Monad instance: 


instance Monad LexBuilderM where
  return = LexBuilderM . return
  (LexBuilderM a) >>= b = LexBuilderM (a >>= runLexBuilder . b)
Applicative instance: 

instance Applicative LexBuilderM where { pure = return; (<*>) = ap; }
Monad instance: 


instance TokenType tok =>
  Monad (Lexer tok) where
    (Lexer fn) >>= mfn = Lexer (fn >>= lexerToPredicateT . mfn)
    return             = Lexer . return
    fail msg           = do
      st <- get
      throwError $
        (parserErr (lexCurrentLocation st)){parseErrMsg = Just (ustr msg), parseStateAtErr=Just st}
Monad instance: 

instance TokenType tok =>
  Monad (TokStream st tok) where
    (TokStream ma) >>= mfa = TokStream (ma >>= parserToPredicateT . mfa)
    return a               = TokStream (return a)
    fail msg = do
      tok <- optional (nextToken False)
      st  <- get
      throwError $
        ParseError
        { parseErrLoc     = maybe LocationUnknown asLocation tok
        , parseErrMsg     = Just (ustr msg)
        , parseErrTok     = fmap getToken tok
        , parseStateAtErr = Just st
        }
Applicative instance: 

instance TokenType tok =>
  Applicative (TokStream st tok) where { pure = return ; (<*>) = ap; }
Monad instance: 

instance TokenType tok =>
  Monad (Parser st tok) where
    return = Parser . return
    parser >>= bind = case parser of
      ParserNull -> ParserNull
      Parser   p -> Parser $ p >>= \a -> case bind a of { ParserNull -> mzero; Parser p -> p; }
    --parserA >> parserB = case parserA of
    --  ParserNull     -> ParserNull
    --  Parser parserA -> case parserB of
    --    ParserNull     -> Parser (parserA >> mzero)
    --    Parser parserB -> Parser (parserA >> parserB)
    fail   = Parser . fail
Applicative instance: 

instance TokenType tok => Applicative (Parser st tok) where { pure = return; (<*>) = ap;    }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Dao-0.1.0.2/src/Dao/Predicate.hs
Monad instance: 


instance Monad (Predicate err) where
  return = OK
  ma >>= mfn = case ma of
    OK     ok -> mfn    ok
    PFail err -> PFail err
    Backtrack -> Backtrack
Applicative instance: 


instance Applicative (Predicate err) where { pure  = return; (<*>) = ap;    }
Monad instance: 


instance Monad m => Monad (PredicateT err m) where
  return a = PredicateT (return (OK a))
  PredicateT ma >>= fma = PredicateT $ do
    a <- ma
    case a of
      Backtrack -> return Backtrack
      PFail   u -> return (PFail u)
      OK      o -> runPredicateT (fma o)
  PredicateT ma >> PredicateT mb = PredicateT $ do
    a <- ma
    case a of
      Backtrack -> return Backtrack
      PFail   u -> return (PFail u)
      OK      _ -> mb
  fail msg = PredicateT{ runPredicateT = return (PFail (error msg)) }
Applicative instance: 


instance (Functor m, Monad m) => Applicative (PredicateT err m) where { pure = return; (<*>) = ap; }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Dao-0.1.0.2/src/Dao/Interval.hs
Monad instance: 

instance (Ord c, Enum c, InfBound c) =>
  Monad (SetM c) where
    return = InfiniteM . (:[])
    a >>= b = case a of
      EmptySetM   -> EmptySetM
      InfiniteM x -> msum (map b x)
      SetM    a x -> msum (map segs a ++ map deflts x) where
        segs (a, x) = msum (map (sieveM a . b) x)
        deflts x = case b x of
          EmptySetM   -> EmptySetM
          InfiniteM x -> InfiniteM x
          SetM    _ x -> InfiniteM x
Applicative instance: 

instance (Ord c, Enum c, InfBound c) =>
  Applicative (SetM c) where { pure = return; (<*>) = ap; }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Dao-0.1.0.2/src/Dao/StepList.hs
Applicative instance: 

instance Applicative StepList where { pure  = return; (<*>) = ap;      }
Monad instance: 

instance Monad       StepList where
  -- | Return is defined by 'slSingletonL'. This is because when lists are used as a monad, the
  -- 'Control.Monad.return' operations that occur earlier in the computation place items in the list
  -- earlier than 'Control.Monad.return' operations that occur later in the computation. Therefore a
  -- monadic computation like @a >> b@ will have @a@ placed to the left of @b@.
  return = slSingletonL
  -- | Just like how the '(Prelude.>>=)' operator instantiated for Haskell lists is the
  -- 'Prelude.concatMap' function, the '(Prelude.>>=)' operator for 'StepList's is the 'slConcatMap'
  -- function.
  (>>=) = flip slConcatMap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Dao-0.1.0.2/src/Dao/Binary.hs
Monad instance: 

instance Monad (GPutM mtab) where
  return = PutM . return
  (PutM a) >>= fn = PutM (a >>= encoderToStateT . fn)
  fail = PutM . fail
Applicative instance: 

instance Applicative (GPutM mtab) where { pure=return; (<*>)=ap; }
Monad instance: 

instance Monad (GGet mtab) where
  return = Get . return
  (Get a) >>= fn = Get (a >>= decoderToStateT . fn)
  Get a >> Get b = Get (a >> b)
  fail msg = bytesRead >>= \ofst -> Get (throwError (GetErr ofst (toUStr msg)))
Applicative instance: 

instance Applicative (GGet mtab) where { pure=return; (<*>)=ap;    }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Dao-0.1.0.2/src/Dao/Tree.hs
Monad instance: 


instance Monad m =>
  Monad (UpdateTreeT p n m) where
    return = UpdateTreeT . return
    (UpdateTreeT a) >>= b = UpdateTreeT (a >>= getUpdateTreeStateT . b)
Applicative instance: 

instance (Monad m, Functor m) =>
  Applicative (UpdateTreeT p n m) where { pure = return; (<*>) = ap; }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/possible-0.1.0.5/Data/Possible.hs
Applicative instance: 


instance Applicative Possible  where
    pure = HaveData
    (HaveData f) <*> (HaveData x) = HaveData (f x)
    MissingData  <*> MissingData  = MissingData
    (HaveData _) <*> MissingData  = MissingData
    MissingData  <*> (HaveData _) = MissingData
    _            <*> _            = HaveNull
Monad instance: 


instance  Monad Possible where
    HaveNull     >>= _  = HaveNull
    MissingData  >>= _  = MissingData
    (HaveData x) >>= k  = k x

    HaveNull     >>  _  = HaveNull
    MissingData  >>  _  = MissingData
    (HaveData _) >>  k  = k

    return              = HaveData
    fail _              = HaveNull
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/MemoTrie-0.6.4/src/Data/MemoTrie.hs
Applicative instance: 


instance HasTrie a => Applicative ((:->:) a) where
  pure b = trie (pure b)
  (<*>)  = inTrie2 (<*>)
Monad instance: 


instance HasTrie a => Monad ((:->:) a) where
  return a = trie (return a)
  u >>= k  = trie (untrie u >>= untrie . k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-0.2.0.1/src-4/Synthesizer/Inference/DesignStudy/Applicative.hs
Applicative instance: 


instance Applicative Processor where
   pure x = P Any (const x)
   (P r0 f0) <*> (P r1 f1)  =
      P (intersectRates r0 r1) (\r -> f0 r (f1 r))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-0.2.0.1/src-4/Synthesizer/Inference/DesignStudy/Monad.hs
Monad instance: 


instance Monad Processor where
   return x = P Any (\_ -> return x)
   -- maybe we should turn this into an Applicative instance
   (P r0 f0) >> (P r1 f1)  =
       P (intersectRates r0 r1) (\r -> f0 r >> f1 r)
   (P _ _) >>= _ = error "Is it possible to implement that?"
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-0.2.0.1/src/Synthesizer/Interpolation/Class.hs
Applicative instance: 


instance Applicative (MAC a v) where
   {-# INLINE pure #-}
   {-# INLINE (<*>) #-}
   pure x = MAC $ const (x, const x)
   MAC f <*> MAC x =
      MAC $ \av ->
         let (xav,add) = x av
             (g,fadd)  = f av
         in  (g xav, \y -> fadd y (add y))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-0.2.0.1/src/Synthesizer/Interpolation.hs
Applicative instance: 


instance Applicative (PrefixReader y) where
   {-# INLINE pure #-}
   {-# INLINE (<*>) #-}
   pure = PrefixReader . pure . pure
   (PrefixReader f) <*> (PrefixReader x) =
       PrefixReader (liftA2 (<*>) f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-0.2.0.1/src/Synthesizer/Dimensional/Process.hs
Applicative instance: 


instance Applicative (T s u t) where
   pure  = pure
   (<*>) = apply
Monad instance: 


instance Monad (T s u t) where
   return = pure
   (>>=)  = bind
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ivory-0.1.0.3/src/Ivory/Language/MemArea.hs
Applicative instance: 


instance Applicative AreaInitM where
  pure  = M.derive_pure areaInit_iso
  (<*>) = M.derive_apply areaInit_iso
  {-# INLINE pure #-}
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad AreaInitM where
  return  = pure
  (>>=)   = M.derive_bind   areaInit_iso
  {-# INLINE return #-}
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/json-0.9.1/Text/JSON/String.hs
Applicative instance: 

instance A.Applicative GetJSON where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad GetJSON where
  return x        = GetJSON (\s -> Right (x,s))
  fail x          = GetJSON (\_ -> Left x)
  GetJSON m >>= f = GetJSON (\s -> case m s of
                                     Left err -> Left err
                                     Right (a,s1) -> un (f a) s1)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/json-0.9.1/Text/JSON.hs
Applicative instance: 


instance Applicative Result where
  (<*>) = ap
  pure  = return
Monad instance: 


instance Monad Result where
  return x      = Ok x
  fail x        = Error x
  Ok a >>= f    = f a
  Error x >>= _ = Error x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Grempa-0.2.2/Data/Parser/Grempa/Grammar/Levels.hs
Monad instance: 


instance MonadFix m => Monad (ReverseT m) where
    return            = ReverseT . return
    ReverseT m >>= f  =
         ReverseT $ do
           rec
             b <- runReverseT (f a)
             a <- m
           return b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/taglib-api-0.1.1.3/src/Audio/TagLib/Internal.hs
Monad instance: 


instance Monad TagLib where
  return           = TagLib . return
  (TagLib m) >>= f = TagLib $ m >>= unTagLib . f
Applicative instance: 


instance Applicative TagLib where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/timberc-1.0.3/src/ParseMonad.hs
Monad instance: 


instance Monad PM where
    (>>=)       = thenPM
    return      = returnPM
    fail        = failPM
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/timberc-1.0.3/src/Common.hs
Monad instance: 


instance Monad (M s) where
    M m >>= f                   = M $ \k ->
                                    case m k of
                                        Right (k',a) -> m' k' where M m' = f a
                                        Left s -> Left s
    return a                    = M $ \k -> Right (k,a)
    fail s                      = M $ \k -> Left s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hat-2.9.0.0/libraries/PreludeBasic.hs
Monad instance: 



instance  Monad Maybe  where
    (Just x) >>= k   =  k x
    Nothing  >>= k   =  Nothing
    return           =  Just
    fail s           =  Nothing
Monad instance: 



instance Monad IO where
   (>>=)  = primIOBind
   return = primIOReturn
   fail s = ioError (userError s)
Monad instance: 



instance  Monad []  where
    m >>= k          = concat (map k m)
    return x         = [x]
    fail s           = []
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hat-2.9.0.0/Hat/PreludeBasic.hs
Monad instance: 


instance Monad Maybe where
        (%>>=) !>>= p
          = T.ufun2 (+*$!=*=*$#=%#>>=) (%>>=) p (*>>=)
          where ((T.R (Just fx) _) *>>= fk) p
                  = T.uap1 T.mkNoSrcPos p
                      (T.projection T.mkNoSrcPos p fk)
                      fx
                (T.R Nothing _ *>>= fk) p
                  = T.con0 T.mkNoSrcPos p Nothing aNothing
                (_ *>>= _) p = T.fatal p
        greturn preturn p = T.uconstUse preturn p sreturn
        sreturn
          = T.uconstDef p c522v5v522v28return
              (\ p -> T.pa0 Just T.cn1 T.mkNoSrcPos p aJust)
        gfail pfail p
          = T.ufun1 c523v5v523v31fail pfail p hfail
          where hfail fs p
                  = T.con0 T.mkNoSrcPos p Nothing aNothing
Monad instance: 


instance Monad IO where
        (%>>=) !>>= p = T.uconstUse (%>>=) p (|>>=)
        (|>>=)
          = T.uconstDef p (+*&+=&=*&+=$$>>=)
              (\ p -> gprimIOBind T.mkNoSrcPos p)
        greturn preturn p = T.uconstUse preturn p sreturn
        sreturn
          = T.uconstDef p c547v4v547v24return
              (\ p -> gprimIOReturn T.mkNoSrcPos p)
        gfail pfail p
          = T.ufun1 c548v4v548v33fail pfail p hfail
          where hfail fs p
                  = T.uwrapForward p
                      (hioError (T.uwrapForward p (huserError fs p)) p)
Monad instance: 


instance Monad T.List where
        (%>>=) !>>= p
          = T.ufun2 (+>!%=*=>!%=%>>>=) (%>>=) p (*>>=)
          where (fm *>>= fk) p
                  = T.uwrapForward p
                      (hconcat (T.uwrapForward p (hmap fk fm p)) p)
        greturn preturn p
          = T.ufun1 c904v5v904v26return preturn p hreturn
          where hreturn fx p
                  = T.fromExpList T.mkNoSrcPos p [fx]
        gfail pfail p
          = T.ufun1 c905v5v905v25fail pfail p hfail
          where hfail fs p = T.con0 T.mkNoSrcPos p T.Nil T.aNil
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/blank-canvas-0.6/Graphics/Blank/Canvas.hs
Monad instance: 


instance Monad Canvas where
        return = Return
        (>>=) = Bind
Applicative instance: 


instance Applicative Canvas where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/xmonad-contrib-0.9.2/XMonad/Actions/GridSelect.hs
Applicative instance: 


instance Applicative (TwoD a) where
    (<*>) = ap
    pure = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Plot-ho-matic-0.9.0.9/src/PlotHo/Plotter.hs
Applicative instance: 


instance Applicative Plotter where
  pure x = Plotter $ pure (x, [])
  f <*> v = Plotter $ liftA2 k (unPlotter f) (unPlotter v)
    where k ~(a, w) ~(b, w') = (a b, w `mappend` w')
Monad instance: 


instance Monad Plotter where
    return a = Plotter $ return (a, [])
    m >>= k  = Plotter $ do
        ~(a, w)  <- unPlotter m
        ~(b, w') <- unPlotter (k a)
        return (b, w `mappend` w')
    fail msg = Plotter $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/algebraic-0.1.0.2/src/Math/Coordinate/LogPolar.hs
Applicative instance: 


instance Applicative Point2 where
    pure a = Point2 a a
    {-# INLINE pure #-}
    Point2 a b <*> Point2 d e = Point2 (a d) (b e)
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/algebraic-0.1.0.2/src/Math/Coordinate/BiPolar.hs
Applicative instance: 


instance Applicative Point where
    pure a = Point a a a
    {-# INLINE pure #-}
    Point a b c <*> Point d e f = Point (a d) (b e) (c f)
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/algebraic-0.1.0.2/src/Math/Coordinate/Cartesian.hs
Applicative instance: 


instance Applicative Point1 where
    pure a = Point1 a
    {-# INLINE pure #-}
    Point1 a <*> Point1 d = Point1 (a d)
    {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative Point2 where
    pure a = Point2 a a
    {-# INLINE pure #-}
    Point2 a b <*> Point2 d e = Point2 (a d) (b e)
    {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative Point3 where
    pure a = Point3 a a a
    {-# INLINE pure #-}
    Point3 a b c <*> Point3 d e f = Point3 (a d) (b e) (c f)
    {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative Point4 where
    pure a = Point4 a a a a
    {-# INLINE pure #-}
    Point4 a b c d <*> Point4 e f g h = Point4 (a e) (b f) (c g) (d h)
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/algebraic-0.1.0.2/src/Math/Coordinate/UV.hs
Applicative instance: 


instance Applicative Point1 where
    pure a = Point1 a
    {-# INLINE pure #-}
    Point1 a <*> Point1 d = Point1 (a d)
    {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative Point2 where
    pure a = Point2 a a
    {-# INLINE pure #-}
    Point2 a b <*> Point2 d e = Point2 (a d) (b e)
    {-# INLINE (<*>) #-}
Applicative instance: 


instance Applicative Point3 where
    pure a = Point3 a a a
    {-# INLINE pure #-}
    Point3 a b c <*> Point3 d e f = Point3 (a d) (b e) (c f)
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/algebraic-0.1.0.2/src/Math/Coordinate/Elliptic.hs
Applicative instance: 


instance Applicative Point where
    pure a = Point a a a
    {-# INLINE pure #-}
    Point a b c <*> Point d e f = Point (a d) (b e) (c f)
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/algebraic-0.1.0.2/src/Math/Coordinate/Polar.hs
Applicative instance: 


instance Applicative Point2 where
    pure a = Point2 a a
    {-# INLINE pure #-}
    Point2 a b <*> Point2 d e = Point2 (a d) (b e)
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/algebraic-0.1.0.2/src/Math/Coordinate/Parabolic.hs
Applicative instance: 


instance Applicative Point where
    pure a = Point a a
    {-# INLINE pure #-}
    Point a b <*> Point d e = Point (a d) (b e)
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/algebraic-0.1.0.2/src/Math/Coordinate/BiPolar2Center.hs
Applicative instance: 


instance Applicative Point where
    pure a = Point a a a
    {-# INLINE pure #-}
    Point a b c <*> Point d e f = Point (a d) (b e) (c f)
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/delicious-0.3.4/Network/Delicious/Types.hs
Monad instance: 


instance Monad DM where
  return x = DM $ \ _   -> return x
  m >>= k  = DM $ \ env -> do
     v <- unDM m env
     unDM (k v)  env
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/libmpd-0.9.0.6/src/Network/MPD/Applicative/Internal.hs
Monad instance: 


instance Monad Parser where
    fail      = Parser . const . Left
    return a  = Parser $ \input -> Right (a, input)
    p1 >>= p2 = Parser $ \input -> runParser p1 input >>= uncurry (runParser . p2)
Applicative instance: 


instance Applicative Parser where
    pure  = return
    (<*>) = ap
Applicative instance: 


instance Applicative Command where
    pure a = Command (pure a) []
    (Command p1 c1) <*> (Command p2 c2) = Command (p1 <*> p2) (c1 ++ c2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/libmpd-0.9.0.6/src/Network/MPD/Core.hs
Applicative instance: 


instance Applicative MPD where
    (<*>) = ap
    pure  = return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tpar-0.1.0.0/TPar/ProcessPipe.hs
Applicative instance: 

instance Applicative OutputStreams where
    pure x = OutputStreams x x
    OutputStreams f g <*> OutputStreams x y = OutputStreams (f x) (g y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dynobud-1.9.1.0/src/Dyno/NlpUtils.hs
Applicative instance: 

instance Monad m => A.Applicative (StateL m s) where
    pure x = StateL (\s -> return (s, x))
    StateL kf <*> StateL kv = StateL $ \ s -> do
      (s', f)  <- kf s
      (s'', v) <- kv s'
      return (s'', f v)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dynobud-1.9.1.0/src/Dyno/Vectorize.hs
Applicative instance: 

instance Applicative None where
  pure = const None
  (<*>) = const (const None)
Applicative instance: 

instance Applicative Id where
  pure = Id
  Id fx <*> Id x = Id (fx x)
Applicative instance: 

instance (Applicative f, Applicative g) => Applicative (Tuple f g) where
  pure x = Tuple (pure x) (pure x)
  Tuple fx fy <*> Tuple x y = Tuple (fx <*> x) (fy <*> y)
Applicative instance: 

instance (Applicative f, Applicative g, Applicative h) => Applicative (Triple f g h) where
  pure x = Triple (pure x) (pure x) (pure x)
  Triple fx fy fz <*> Triple x y z = Triple (fx <*> x) (fy <*> y) (fz <*> z)
Applicative instance: 

instance (Applicative f, Applicative g, Applicative h, Applicative i) => Applicative (Quad f g h i) where
  pure x = Quad (pure x) (pure x) (pure x) (pure x)
  Quad fx fy fz fw <*> Quad x y z w = Quad (fx <*> x) (fy <*> y) (fz <*> z) (fw <*> w)
Applicative instance: 


-- undecidable, overlapping, orphan instances to get rid of boilerplate

#if defined(__GLASGOW_HASKELL__) && __GLASGOW_HASKELL__ <= 708
instance Vectorize f => Applicative f where
#else
instance {-# OVERLAPPABLE #-} Vectorize f => Applicative f where
#endif
  pure = fill
  x0 <*> x1 = devectorize (V.zipWith id (vectorize x0) (vectorize x1))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/dynobud-1.9.1.0/src/Dyno/TypeVecs.hs
Applicative instance: 


instance Dim n => Applicative (Vec n) where
  pure x = ret
    where
      ret = MkVec $ V.replicate (tvlength ret) x
  MkVec xs <*> MkVec ys = MkVec $ V.zipWith id xs ys
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hs-twitter-0.2.8/Web/Twitter/Types/Import.hs
Monad instance: 


instance Monad JM where
  return x = JM (\ _ _ -> return x)
  (JM a) >>= k = JM $ \ loc env -> do
     v <- a loc env
     case k v of
      (JM b) -> b loc env
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hs-twitter-0.2.8/Web/Twitter/Monad.hs
Monad instance: 


instance Monad TM where
  return x = TM $ \ _   -> return x
  m >>= k  = TM $ \ env -> do
     v <- unTM m env
     unTM (k v)  env
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/yesod-bootstrap-0.3/src/Yesod/Form/Generic.hs
Applicative instance: 


instance (Monad m, Monoid w) => Applicative (GForm w m) where
  pure x = GForm $ const $ const $ \ints -> return (FormSuccess x, mempty, ints, mempty)
  (GForm f) <*> (GForm g) = GForm $ \mr env ints -> do
    (a, b, ints', c) <- f mr env ints
    (x, y, ints'', z) <- g mr env ints'
    return (a <*> x, b <> y, ints'', c <> z)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reactive-bacon-0.4.1/src/Reactive/Bacon/Property.hs
Applicative instance: 


instance Applicative Property where
  (<*>) = applyP
  pure  = constantP
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tagsoup-ht-0.3/src/Text/HTML/TagSoup/HT/Parser/Custom.hs
Monad instance: 


instance Monad Identity where
   return = Identity
   m >>= k = k $ runIdentity m
Monad instance: 



instance (Monoid output, Monad fail) => Monad (T input output fail) where
   return a = Cons $ \s -> return (a, s, mempty)
   m >>= k  = Cons $ \s -> do
           ~(a, s', w)  <- run m s
           ~(b, s'',w') <- run (k a) s'
           return (b, s'', mappend w w')
   fail msg = Cons $ \_ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/total-maps-1.0.0.3/src/Data/Total/Map/Subset.hs
Applicative instance: 


-- | Zippy applicative. Complexity: 'pure' O(n), '<*>' O(n).
instance (Ord k, Subset s k) => Applicative (TotalSubsetMap s k) where
    pure x = TotalSubsetMap $ Map.fromSet (const x) (reflect (Proxy :: Proxy s))
    (<*>)  = zap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/total-maps-1.0.0.3/src/Data/Total/Map/Sparse.hs
Applicative instance: 


-- | Zippy applicative. Complexity: 'pure' O(1), '<*>' O(k1 + k2)
instance Ord k => Applicative (TotalSparseMap k) where
    pure x = TotalSparseMap Map.empty x
    (<*>)  = zap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/total-maps-1.0.0.3/src/Data/Total/Map.hs
Applicative instance: 


-- | Zippy applicative. Complexity: 'pure' O(n * log n), '<*>' O(n).
instance (Ord k, Enum k, Bounded k) => Applicative (TotalMap k) where
    pure x = TotalMap $ Map.fromList [(k, x) | k <- [minBound .. maxBound]]
    (<*>)  = zap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bag-0.1/Data/Bag.hs
Monad instance: 


instance Monad BagTree where
    return = Leaf
    m >>= f = btconcat $ fmap f m
Monad instance: 


instance Monad Bag where
    return = Bag . Leaf
    m >>= f = bconcat $ fmap f m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rad-0.1.6.3/Numeric/RAD.hs
Monad instance: 


instance Monad S where
    return a = S (\s -> (a,s))
    S g >>= f = S (\s -> let (a,s') = g s in runS (f a) s')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/supervisor-0.1.1.0/Control/Monad/Supervisor.hs
Monad instance: 


--instance MonadState () IO where
--  get= return()
--  put= const $ return ()

--instance MonadState s m => Supervise s m



-- | The Supervisor Monad is in essence an Identity monad transformer when executing Forward.
instance  Supervise s m => Monad (Sup s m) where
    fail   _ = Sup . return $ Backward
    return x = Sup . return $ Forward x
    x >>= f    = Sup $ loop
     where
     loop = do
        s <- get
        -- execution as usual if supervise== id
        v <-  supervise s $ runSup x
        case v of
            --  a normal execution if supervise== id
            Forward y  -> supervise s $ runSup (f y)

            --   Backward was returned, stop the branch of execution and propagate it back
            Backward  ->  return  Backward

            -- the computaton x was a control point. if the branch of execution goes Backward
            -- then x will be reexecuted. supBack will control the state backtracking, how much of
            -- the current state we want to keep and how much we want to backtrack  
            Control y  -> do
                 z <- supervise s $ runSup (f y)
                 case z of
                  Backward  -> supBack s >> loop           -- re-execute x   
                  other   -> return other
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/opensoundcontrol-ht-0.3/src/Sound/OSC/Transport/Monad/ByteString.hs
Applicative instance: 


instance Applicative T where
   pure = return
   (<*>) = ap
Monad instance: 


instance Monad T where
   return = Cons . return
   Cons x >>= k  =
      Cons  $  decons . k =<< x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/txt-sushi-0.6.0/Database/TxtSushi/SQLExecution.hs
Applicative instance: 


instance Applicative NestedDataGroups where
    pure = SingleElement

    (SingleElement f)  <*> (SingleElement x)  = SingleElement (f x)
    (SingleElement f)  <*> gd@(GroupedData _) = fmap f gd
    gd@(GroupedData _) <*> (SingleElement x)  = fmap ($ x) gd
    (GroupedData fs)   <*> (GroupedData xs)   = GroupedData $ zipWith (<*>) fs xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/processing-1.2.0.2/Graphics/Web/Processing/Mid.hs
Applicative instance: 


instance Applicative (EventM c) where
 pure x = EventM $ pure x
 ef <*> e = EventM $ unEventM ef <*> unEventM e
Monad instance: 


instance Monad (EventM c) where
 return = pure
 (EventM s) >>= f = EventM $ s >>= unEventM . f
Applicative instance: 


instance Applicative (ScriptM c) where
 pure x = ScriptM $ pure x
 ef <*> e = ScriptM $ unScriptM ef <*> unScriptM e
Monad instance: 


instance Monad (ScriptM c) where
 return = pure
 (ScriptM s) >>= f = ScriptM $ s >>= unScriptM . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/processing-1.2.0.2/Graphics/Web/Processing/Core/Monad.hs
Applicative instance: 


instance Applicative (ProcM c) where
 pure x = ProcM $ pure x
 pf <*> p = ProcM $ unProcM pf <*> unProcM p
Monad instance: 


instance Monad (ProcM c) where
 return = pure
 (ProcM w) >>= f = ProcM $ w >>= unProcM . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/traverse-with-class-0.2.0.4/Data/Generics/Traversable/Zipper.hs
Applicative instance: 


instance Applicative (Left c) where
  pure = LeftUnit
  tx <*> LeftUnit e = fmap ($ e) tx
  tx <*> LeftCons ty az = LeftCons ((.) <$> tx <*> ty) az
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/app-lens-0.1.0.1/Control/LensFunction/Core.hs
Monad instance: 


instance Monad (R s) where
  return x = R $ const (x, const True)
  R m >>= f = R $ \s -> let (x,c1) = m s
                            (y,c2) = let R k = f x in k s
                        in (y, \t -> c1 t && c2 t)
Applicative instance: 


instance Applicative (R s) where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/statethread-0.1.1/src/Control/Monad/ST/Strict.hs
Applicative instance: 


instance Applicative (ST s) where
   pure f = ST (pure f)
   ST f <*> ST x = ST (f <*> x)
Monad instance: 


instance Monad (ST s) where
   return f = ST (return f)
   fail str = ST (fail str)
   ST x >> ST y = ST (x >> y)
   ST x >>= k = ST (unST . k =<< x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/statethread-0.1.1/src/Control/Monad/ST/Lazy.hs
Applicative instance: 


instance Applicative (ST s) where
   pure f = ST (pure f)
   ST f <*> ST x = ST $
      mapStateT unsafeInterleaveIO f <*>
      mapStateT unsafeInterleaveIO x
Monad instance: 


instance Monad (ST s) where
   return f = ST (return f)
   fail str = ST (fail str)
   ST x >> ST y = ST $
      mapStateT unsafeInterleaveIO x >>
      mapStateT unsafeInterleaveIO y
   ST x >>= k = ST $
      mapStateT unsafeInterleaveIO . unST . k =<<
      mapStateT unsafeInterleaveIO x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hLLVM-0.5.0.1/src/Llvm/Data/Conversion/LabelMapM.hs
Applicative instance: 


instance (Functor m, Applicative m, Monad m, H.UniqueMonad m) => Applicative (LabelMapM m) where
  pure = return
  (<*>) = ap
Monad instance: 


-- | we need to get a fresh Hoopl label for each LLVM label, so we use Hoopl Unique Monad
instance (Applicative m, H.UniqueMonad m) => Monad (LabelMapM m) where
  return x = LabelMapM $ \iLm -> return (iLm, x)
  iLmM >>= k = LabelMapM $ \iLm -> unIlM iLmM iLm >>= \(iLm1, x) -> unIlM (k x) iLm1
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hasim-0.1.2/src/Control/Hasim/Process.hs
Monad instance: 


-- The Monad instance for the @Action@ GADT.
instance Monad (Action pkt st) where
    return = Prim . Ret
    (>>=) = (:>>=)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/machines-0.6.1/src/Data/Machine/Plan.hs
Applicative instance: 


instance Applicative (PlanT k o m) where
  pure a = PlanT (\kp _ _ _ -> kp a)
  {-# INLINE pure #-}
  m <*> n = PlanT $ \kp ke kr kf -> runPlanT m (\f -> runPlanT n (\a -> kp (f a)) ke kr kf) ke kr kf
  {-# INLINE (<*>) #-}
  m *> n = PlanT $ \kp ke kr kf -> runPlanT m (\_ -> runPlanT n kp ke kr kf) ke kr kf
  {-# INLINE (*>) #-}
  m <* n = PlanT $ \kp ke kr kf -> runPlanT m (\a -> runPlanT n (\_ -> kp a) ke kr kf) ke kr kf
  {-# INLINE (<*) #-}
Monad instance: 


instance Monad (PlanT k o m) where
  return = pure
  {-# INLINE return #-}
  PlanT m >>= f = PlanT (\kp ke kr kf -> m (\a -> runPlanT (f a) kp ke kr kf) ke kr kf)
  (>>) = (*>)
  {-# INLINE (>>) #-}
  fail _ = PlanT (\_ _ _ kf -> kf)
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/machines-0.6.1/src/Data/Machine/Moore.hs
Applicative instance: 

#if MIN_VERSION_profunctors(3,1,1)
  dimap f g = go where
    go (Moore b h) = Moore (g b) (go . h . f)
  {-# INLINE dimap #-}
#endif

instance Applicative (Moore a) where
  pure a = r where r = Moore a (const r)
  {-# INLINE pure #-}
  Moore f ff <*> Moore a fa  = Moore (f a) (\i -> ff i <*> fa i)
  m <* _ = m
  {-# INLINE (<*) #-}
  _ *> n = n
  {-# INLINE (*>) #-}
Monad instance: 


-- | slow diagonalization
instance Monad (Moore a) where
  return a = r where r = Moore a (const r)
  {-# INLINE return #-}
  k >>= f = j (fmap f k) where
    j (Moore a g) = Moore (extract a) (\x -> j $ fmap (\(Moore _ h) -> h x) (g x))
  _ >> m = m
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/machines-0.6.1/src/Data/Machine/Type.hs
Applicative instance: 


instance (Monad m, Appliance k) => Applicative (MachineT m k) where
  pure = point
  (<*>) = applied
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/machines-0.6.1/src/Data/Machine/Mealy.hs
Applicative instance: 


instance Applicative (Mealy a) where
  pure b = r where r = Mealy (const (b, r))
  {-# INLINE pure #-}
  Mealy m <*> Mealy n = Mealy $ \a -> case m a of
    (f, m') -> case n a of
       (b, n') -> (f b, m' <*> n')
  m <* _ = m
  {-# INLINE (<*) #-}
  _ *> n = n
  {-# INLINE (*>) #-}
Monad instance: 


-- | slow diagonalization
instance Monad (Mealy a) where
  return b = r where r = Mealy (const (b, r))
  {-# INLINE return #-}
  m >>= f = Mealy $ \a -> case runMealy m a of
    (b, m') -> (fst (runMealy (f b) a), m' >>= f)
  {-# INLINE (>>=) #-}
  _ >> n = n
  {-# INLINE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/drifter-0.2.2/src/Drifter/Graph.hs
Applicative instance: 


instance Monad m => A.Applicative (EitherT e m) where
  pure a  = EitherT $ return (Right a)
  {-# INLINE pure #-}
  EitherT f <*> EitherT v = EitherT $ f >>= \mf -> case mf of
    Left  e -> return (Left e)
    Right k -> v >>= \mv -> case mv of
      Left  e -> return (Left e)
      Right x -> return (Right (k x))
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad m => Monad (EitherT e m) where
  return a = EitherT $ return (Right a)
  {-# INLINE return #-}
  m >>= k  = EitherT $ do
    a <- runEitherT m
    case a of
      Left  l -> return (Left l)
      Right r -> runEitherT (k r)
  {-# INLINE (>>=) #-}
  fail = EitherT . fail
  {-# INLINE fail #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/asil-1.2/src/Instr.hs
Monad instance: 


-- | Monad instance provides meta-programming via sequences.
instance Monad Instr where
  return x = Instr $ \n k -> k n x L.Instr_Nop
  (Instr m1) >>= f = Instr $ \n1 k ->
    m1 n1 $ \n2 v1 i1 ->
      let (Instr m2) = f v1
      in m2 n2 $ \n3 v2 i2 -> k n3 v2 (optSeq i1 i2)
  fail s = Instr $ \n k -> k n (error s) (L.Instr_Fail (Just s))
Applicative instance: 


-- | Applicative instance provides sequencing.
--   Can be defined in terms of the monad; the current implementation has slightly less
--   Haskell overhead.
instance Applicative Instr where
  pure x = return x
  (Instr m1) <*> (Instr m2) = Instr $ \n1 k ->
    m1 n1 $ \n2 f i1 ->
      m2 n2 $ \n3 v i2 ->
        k n3 (f v) (L.Instr_Seq i1 i2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/equivalence-0.3.1/src/Data/Equivalence/Monad.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (EquivT s c v m) where
  pure = EquivT . pure
  (EquivT f) <*> (EquivT a) = EquivT (f <*> a)
Monad instance: 


instance (Monad m) => Monad (EquivT s c v m) where
    EquivT m >>= f = EquivT (m >>= (unEquivT . f))
    return = EquivT . return
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/HMap-1.2.7/Data/HKeyPrivate.hs
Monad instance: 


instance Monad (TermM f) where
  return = Return
  (>>=)  = Bind
Applicative instance: 


instance Applicative (TermM f) where
  pure = return
  (<*>) = ap
Applicative instance: 


instance Monad m => Applicative (KeyT s m) where
  pure = return
  f <*> x = do fv <- keyTSplit f; xv <- keyTSplit x; lift (ap fv xv)
Monad instance: 


instance Monad m =>Monad (KeyT s m) where
  return   = KeyT . Return
  c >>= f  = KeyT $ getKT c >>= getKT . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rivet-migration-0.1.0.1/src/Rivet/Migration.hs
Applicative instance: 


instance Applicative Migration where
  pure v = Migration v []
  (<*>) (Migration f ss) (Migration v ss') = Migration (f v) (ss ++ ss')
Monad instance: 


instance Monad Migration where
  (>>=) (Migration v ss) f = let (Migration v' ss') = f v in Migration v' (ss ++ ss')
  return v = Migration v []
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pipes-concurrency-2.0.6/src/Pipes/Concurrent.hs
Applicative instance: 


instance Applicative Input where
    pure r    = Input (pure (pure r))
    mf <*> mx = Input ((<*>) <$> recv mf <*> recv mx)
Monad instance: 


instance Monad Input where
    return r = Input (return (return r))
    m >>= f  = Input $ do
        ma <- recv m
        case ma of
            Nothing -> return Nothing
            Just a  -> recv (f a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bifunctors-5.4.1/src/Data/Bifunctor/Join.hs
Applicative instance: 


instance Biapplicative p => Applicative (Join p) where
  pure a = Join (bipure a a)
  {-# INLINE pure #-}
  Join f <*> Join a = Join (f <<*>> a)
  {-# INLINE (<*>) #-}
  Join a *> Join b = Join (a *>> b)
  {-# INLINE (*>) #-}
  Join a <* Join b = Join (a <<* b)
  {-# INLINE (<*) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bifunctors-5.4.1/src/Data/Bifunctor/Fix.hs
Applicative instance: 


instance Biapplicative p => Applicative (Fix p) where
  pure a = In (bipure (pure a) a)
  {-# INLINE pure #-}
  In p <*> In q = In (biliftA2 (<*>) ($) p q)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/happstack-server-7.4.6.2/src/Happstack/Server/RqData.hs
Applicative instance: 


instance (Monoid e, Error e) => Applicative (ReaderError r e) where
    pure = return
    (ReaderError (ReaderT f)) <*> (ReaderError (ReaderT a))
        = ReaderError $ ReaderT $ \env -> (f env) `apEither` (a env)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/scalpel-0.3.1/src/Text/HTML/Scalpel/Internal/Scrape.hs
Applicative instance: 


instance Applicative (Scraper str) where
    pure = MkScraper . const . Just
    (MkScraper f) <*> (MkScraper a) = MkScraper applied
        where applied tags | (Just aVal) <- a tags = ($ aVal) <$> f tags
                           | otherwise             = Nothing
Monad instance: 


instance Monad (Scraper str) where
    return = pure
    (MkScraper a) >>= f = MkScraper combined
        where combined tags | (Just aVal) <- a tags = let (MkScraper b) = f aVal
                                                      in  b tags
                            | otherwise             = Nothing
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sessions-2008.7.18/Control/Concurrent/Session/Base/SMonad.hs
Monad instance: 


instance (Monad m) => Monad (SChain m x x) where
    m >> n   = SChain $ \x -> do { ~(_, y) <- runSChain m x
                                 ; runSChain n y
                                 }
    m >>= k  = SChain $ \x -> do { ~(a, y) <- runSChain m x
                                 ; runSChain (k a) y
                                 }
    return a = SChain $ \x -> return (a, x)
    fail str = SChain $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/knead-0.2/src/Data/Array/Knead/Parameter.hs
Applicative instance: 


{- |
Useful for combining @T p a@ and @T p b@ to @T p (a,b)@
using @liftA2 (,)@.
However, we do not recommend to do so
because the result parameter can only be constant
if both operands are constant.
-}
instance App.Applicative (T p) where
   pure a = Constant a
   Constant f <*> Constant a = Constant (f a)
   f <*> a = Variable (\p -> get f p (get a p))
Monad instance: 


instance Monad (T p) where
   return = pure
   Constant x >>= f = f x
   Variable x >>= f =
      Variable (\p -> get (f (x p)) p)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/shakespeare-2.0.9/Text/Hamlet/Parse.hs
Monad instance: 

instance Monad Result where
    return = Ok
    Error s >>= _ = Error s
    Ok v >>= f = f v
    fail = Error
Applicative instance: 

instance Applicative Result where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtl-tf-0.1/Control/Monad/Cont.hs
Monad instance: 


instance Monad (Cont r) where
    return a = Cont ($ a)
    m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
Monad instance: 


instance (Monad m) => Monad (ContT r m) where
    return a = ContT ($ a)
    m >>= k  = ContT $ \c -> runContT m (\a -> runContT (k a) c)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtl-tf-0.1/Control/Monad/Error.hs
Monad instance: 


-- ---------------------------------------------------------------------------
-- Our parameterizable error monad

instance (Error e) => Monad (Either e) where
    return        = Right
    Left  l >>= _ = Left l
    Right r >>= k = k r
    fail msg      = Left (strMsg msg)
Monad instance: 


instance (Monad m, Error e) => Monad (ErrorT e m) where
    return a = ErrorT $ return (Right a)
    m >>= k  = ErrorT $ do
        a <- runErrorT m
        case a of
            Left  l -> return (Left l)
            Right r -> runErrorT (k r)
    fail msg = ErrorT $ return (Left (strMsg msg))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtl-tf-0.1/Control/Monad/Identity.hs
Monad instance: 


instance Monad Identity where
    return a = Identity a
    m >>= k  = k (runIdentity m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtl-tf-0.1/Control/Monad/State/Strict.hs
Monad instance: 


instance Monad (State s) where
    return a = State $ \s -> (a, s)
    m >>= k  = State $ \s -> case runState m s of
                                 (a, s') -> runState (k a) s'
Monad instance: 


instance (Monad m) => Monad (StateT s m) where
    return a = StateT $ \s -> return (a, s)
    m >>= k  = StateT $ \s -> do
        (a, s') <- runStateT m s
        runStateT (k a) s'
    fail str = StateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtl-tf-0.1/Control/Monad/State/Lazy.hs
Monad instance: 


instance Monad (State s) where
    return a = State $ \s -> (a, s)
    m >>= k  = State $ \s -> let
        (a, s') = runState m s
        in runState (k a) s'
Monad instance: 


instance (Monad m) => Monad (StateT s m) where
    return a = StateT $ \s -> return (a, s)
    m >>= k  = StateT $ \s -> do
        ~(a, s') <- runStateT m s
        runStateT (k a) s'
    fail str = StateT $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtl-tf-0.1/Control/Monad/RWS/Strict.hs
Monad instance: 


instance (Monoid w) => Monad (RWS r w s) where
    return a = RWS $ \_ s -> (a, s, mempty)
    m >>= k  = RWS $ \r s -> case runRWS m r s of
                                 (a, s',  w) ->
                                     case runRWS (k a) r s' of
                                         (b, s'', w') ->
                                             (b, s'', w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (RWST r w s m) where
    return a = RWST $ \_ s -> return (a, s, mempty)
    m >>= k  = RWST $ \r s -> do
        (a, s', w)  <- runRWST m r s
        (b, s'',w') <- runRWST (k a) r s'
        return (b, s'', w `mappend` w')
    fail msg = RWST $ \_ _ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtl-tf-0.1/Control/Monad/RWS/Lazy.hs
Monad instance: 


instance (Monoid w) => Monad (RWS r w s) where
    return a = RWS $ \_ s -> (a, s, mempty)
    m >>= k  = RWS $ \r s -> let
        (a, s',  w)  = runRWS m r s
        (b, s'', w') = runRWS (k a) r s'
        in (b, s'', w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (RWST r w s m) where
    return a = RWST $ \_ s -> return (a, s, mempty)
    m >>= k  = RWST $ \r s -> do
        ~(a, s', w)  <- runRWST m r s
        ~(b, s'',w') <- runRWST (k a) r s'
        return (b, s'', w `mappend` w')
    fail msg = RWST $ \_ _ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtl-tf-0.1/Control/Monad/Reader.hs
Monad instance: 


instance Monad (Reader r) where
    return a = Reader $ \_ -> a
    m >>= k  = Reader $ \r -> runReader (k (runReader m r)) r
Monad instance: 


instance (Monad m) => Monad (ReaderT r m) where
    return a = ReaderT $ \_ -> return a
    m >>= k  = ReaderT $ \r -> do
        a <- runReaderT m r
        runReaderT (k a) r
    fail msg = ReaderT $ \_ -> fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtl-tf-0.1/Control/Monad/List.hs
Monad instance: 


instance (Monad m) => Monad (ListT m) where
    return a = ListT $ return [a]
    m >>= k  = ListT $ do
        a <- runListT m
        b <- mapM (runListT . k) a
        return (concat b)
    fail _ = ListT $ return []
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtl-tf-0.1/Control/Monad/Writer/Strict.hs
Monad instance: 


instance (Monoid w) => Monad (Writer w) where
    return a = Writer (a, mempty)
    m >>= k  = Writer $ case runWriter m of
                            (a, w) -> case runWriter (k a) of
                                (b, w') -> (b, w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (WriterT w m) where
    return a = WriterT $ return (a, mempty)
    m >>= k  = WriterT $ do
        (a, w)  <- runWriterT m
        (b, w') <- runWriterT (k a)
        return (b, w `mappend` w')
    fail msg = WriterT $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/mtl-tf-0.1/Control/Monad/Writer/Lazy.hs
Monad instance: 


instance (Monoid w) => Monad (Writer w) where
    return a = Writer (a, mempty)
    m >>= k  = Writer $ let
        (a, w)  = runWriter m
        (b, w') = runWriter (k a)
        in (b, w `mappend` w')
Monad instance: 


instance (Monoid w, Monad m) => Monad (WriterT w m) where
    return a = WriterT $ return (a, mempty)
    m >>= k  = WriterT $ do
        ~(a, w)  <- runWriterT m
        ~(b, w') <- runWriterT (k a)
        return (b, w `mappend` w')
    fail msg = WriterT $ fail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/FM-SBLEX-3.0.1/src/lib/Dict/ErrM.hs
Monad instance: 


instance Monad Err where
  return      = Ok
  fail        = Bad
  Ok a  >>= f = f a
  Bad s >>= f = Bad s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/esqueleto-2.4.3/src/Database/Esqueleto/Internal/Sql.hs
Monad instance: 


instance Monad SqlQuery where
  return  = Q . return
  m >>= f = Q (unQ m >>= unQ . f)
Applicative instance: 


instance Applicative SqlQuery where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bff-0.3.1.2/Data/Zippable/Definition.hs
Monad instance: 


instance Monad CError where
        return a = CError (\h -> h a)
        (CError p) >>= k = CError (\h -> p (\a -> case k a of CError q -> q h))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/AutoForms-0.4.2/src/Control/Monad/RecursiveObserver.hs
Monad instance: 


-- Common monad instances

instance (Monad m) => Monad (ListenerT eid m) where
    return x = ListenerT $ return x
    m >>= k  = ListenerT (listenerT' m >>= listenerT' . k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-inference-0.2/src/Synthesizer/Inference/Reader/Process.hs
Applicative instance: 


instance Applicative (T t t') where
   pure  = pure
   (<*>) = apply
Monad instance: 


instance Monad (T t t') where
   return = pure
   (>>=)  = share
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/vector-sized-0.3.3.0/src/Data/Vector/Generic/Sized.hs
Applicative instance: 


-- | The 'Applicative' instance for sized vectors does not have the same
-- behaviour as the 'Applicative' instance for the unsized vectors found in the
-- 'vectors' package. The instance defined here has the same behaviour as the
-- 'Control.Applicative.ZipList' instance.
instance KnownNat n => Applicative (Vector Boxed.Vector n) where
  pure = replicate
  (<*>) = zipWith ($)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/presburger-1.3.1/src/Data/Integer/SAT.hs
Monad instance: 



instance Monad Answer where
  return a           = One a
  fail _             = None
  None >>= _         = None
  One a >>= k        = k a
  Choice m1 m2 >>= k = mplus (m1 >>= k) (m2 >>= k)
Applicative instance: 


instance Applicative Answer where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad S where
  return a      = S $ \s -> return (a,s)
  S m >>= k     = S $ \s -> do (a,s1) <- m s
                               let S m1 = k a
                               m1 s1
Applicative instance: 


instance Applicative S where
  pure  = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/conduit-1.2.7/Data/Conduit/Internal/Pipe.hs
Applicative instance: 


instance Monad m => Applicative (Pipe l i o u m) where
    pure = Done
    {-# INLINE pure #-}
    (<*>) = ap
    {-# INLINE (<*>) #-}
Monad instance: 


instance Monad m => Monad (Pipe l i o u m) where
    return = pure
    {-# INLINE return #-}

    HaveOutput p c o >>= fp = HaveOutput (p >>= fp)            c          o
    NeedInput p c    >>= fp = NeedInput  (p >=> fp)            (c >=> fp)
    Done x           >>= fp = fp x
    PipeM mp         >>= fp = PipeM      ((>>= fp) `liftM` mp)
    Leftover p i     >>= fp = Leftover   (p >>= fp)            i
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/conduit-1.2.7/Data/Conduit/Internal/Conduit.hs
Applicative instance: 


instance Applicative (ConduitM i o m) where
    pure x = ConduitM ($ x)
    {-# INLINE pure #-}
    (<*>) = ap
    {-# INLINE (<*>) #-}
Monad instance: 


instance Monad (ConduitM i o m) where
    return = pure
    ConduitM f >>= g = ConduitM $ \h -> f $ \a -> unConduitM (g a) h
Applicative instance: 

instance Monad m => Applicative (ZipSource m) where
    pure  = ZipSource . forever . yield
    (ZipSource f) <*> (ZipSource x) = ZipSource $ zipSourcesApp f x
Applicative instance: 

instance Monad m => Applicative (ZipSink i m) where
    pure  = ZipSink . return
    (ZipSink f) <*> (ZipSink x) =
         ZipSink $ liftM (uncurry ($)) $ zipSinks f x
Applicative instance: 

instance Monad m => Applicative (ZipConduit i o m) where
    pure = ZipConduit . pure
    ZipConduit left <*> ZipConduit right = ZipConduit (zipConduitApp left right)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/halfs-2.0/Halfs/Classes.hs
Monad instance: 


instance Monad m => Monad (TimedT m) where
  return a = TimedT $ \ _ -> return a
  m >>= k  = TimedT $ \ t -> do
               a <- runTimerT m t
               runTimerT (k a) (t + 1)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/halfs-2.0/Halfs/Monad.hs
Monad instance: 


--------------------------------------------------------------------------------
-- Instances

instance (Monad m) => Monad (HalfsT err env m) where
  m >>= k = HalfsT $ runHalfsT m >>= either (return . Left) (runHalfsT . k)
  return  = HalfsT . return . Right
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Clean-0.6/src/Clean/Applicative.hs
Applicative instance: 


instance Applicative (Either a)
Monad instance: 

instance Monad (Either a) where join (Right a) = a
                                join (Left a) = Left a
Applicative instance: 

instance Applicative ((->) a)
Monad instance: 

instance Monad ((->) a) where join f x = f x x
Applicative instance: 

instance Monoid w => Applicative ((,) w)
Monad instance: 

instance Monoid w => Monad ((,) w) where
  join ~(w,~(w',a)) = (w+w',a)
Applicative instance: 

instance Applicative []
Monad instance: 

instance Monad [] where join = fold
Applicative instance: 

instance Applicative Tree
Monad instance: 

instance Monad Tree where
  join (Node (Node a subs) subs') = Node a (subs + map join subs')
Applicative instance: 

instance (Applicative f,Applicative g) => Applicative (Compose f g) where
  Compose fs <*> Compose xs = Compose ((<*>)<$>fs<*>xs)
Applicative instance: 

instance Applicative Interleave
Monad instance: 

instance Monad Interleave where join = fold
Applicative instance: 

instance Applicative ZipList where
  ZipList fs <*> ZipList xs = ZipList (zip fs xs)
    where zip (f:fs) (x:xs) = f x:zip fs xs
          zip _ _ = []
Applicative instance: 

instance Applicative ZipTree where
  ZipTree (Node f fs) <*> ZipTree (Node x xs) =
    ZipTree (Node (f x) (getZipList ((<*>)<$>ZipList fs<*>ZipList xs)))
Applicative instance: 

instance Applicative f => Applicative (Backwards f) where
  Backwards fs <*> Backwards xs = Backwards (liftA2 (&) xs fs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Clean-0.6/src/Clean/Arrow.hs
Monad instance: 


instance (Monad f,Contravariant f,Monad g) => Monad (Compose f g) where
  join = map getCompose >>> getCompose >>> map collect
         >>> join >>> map join >>> Compose
Applicative instance: 

instance Monad m => Applicative (Kleisli m a)
Monad instance: 

instance Monad m => Monad (Kleisli m a) where join m = m ^. kc.lam (join . map (^.kc)).kc'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Clean-0.6/src/Clean/Functor.hs
Applicative instance: 

instance Applicative Id
Monad instance: 

instance Monad Id where Id a >>= k = k a
Applicative instance: 

instance Applicative (Const a)
Monad instance: 

instance Monad (Const a) where Const a >>= _ = Const a
Applicative instance: 

instance Applicative IO
Monad instance: 

instance Monad IO where (>>=) = (P.>>=)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Clean-0.6/src/Clean/Monad.hs
Applicative instance: 

instance Monad m => Applicative (StateT s m)
Monad instance: 

instance Monad m => Monad (StateT s m) where
  StateT st >>= k = StateT (\s -> st s >>= \ ~(s',a) -> runStateT (k a) s')
Applicative instance: 

instance Monad m => Applicative (ReaderT r m)
Monad instance: 

instance Monad m => Monad (ReaderT r m) where
  ReaderT rd >>= k = ReaderT (\r -> rd r >>= \a -> runReaderT (k a) r)
Applicative instance: 

instance (Monoid w,Monad m) => Applicative (WriterT w m)
Monad instance: 

instance (Monoid w,Monad m) => Monad (WriterT w m) where
  wr >>= k = WriterT $ do
    (w,a) <- runWriterT wr
    map (first (w+)) (runWriterT (k a))
Applicative instance: 

instance Monad m => Applicative (ContT r m)
Monad instance: 

instance Monad m => Monad (ContT r m) where
  ContT k >>= f = ContT (\cc -> k (\a -> runContT (f a) cc))
Monad instance: 

instance MonadFix m => Monad (Backwards m) where
  Backwards ma >>= k = Backwards$fst<$>mfix (\r -> liftA2 (,) (forwards (k (snd r))) ma)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cereal-plus-0.4.2/library/CerealPlus/Deserialize.hs
Monad instance: 


instance (Monad m) => Monad (Deserialize m) where
  Deserialize runA >>= aToDeserializeTB = Deserialize $ \bs -> runA bs >>= aToMB where
    aToMB a = case a of
      Fail msg bs -> return $ Fail msg bs
      Partial cont -> return $ Partial $ \bs -> cont bs >>= aToMB
      Done a bs -> case aToDeserializeTB a of Deserialize runB -> runB bs
  return a = Deserialize $ \bs -> return $ Done a bs
Applicative instance: 


instance (Monad m) => Applicative (Deserialize m) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bamse-0.9.5/Bamse/IMonad.hs
Monad instance: 


instance Monad IM where
  (>>=)  = bindIM
  return = returnIM
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pagination-0.1.0/Data/Pagination.hs
Applicative instance: 


instance Applicative Paginated where
  pure x  = Paginated [x] (Pagination 1 1) 1 1
  f <*> p = p { pgItems = pgItems f <*> pgItems p }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/compilation-0.0.0.3/Control/Compilation.hs
Monad instance: 


-- | Standard state monad definition.
instance StateExtension a => Monad (Compilation a) where
  return x = Compilation (\s -> (s, x))
  (>>=) fc1 fc2 =
    case fc1 of
      Compilation c1 ->
        Compilation $
          (\state ->
            let (state', r) = c1 state
                Compilation c2 = fc2 r
            in c2 state'
          )
      Error err -> Error err
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/reenact-0.9/src/Control/Reactive.hs
Applicative instance: 


-- |
-- Reactive is an applicative functor: 'pure' is a constant value and @fr \<*> xr@ applies the
-- function @fr t@ to the value @xr t@.
--
instance Applicative Reactive where
    pure = RConst
    -- pure x = x `stepper` never 
    (<*>) = RApply
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/vector-static-0.3.0.1/Data/Vector/Static.hs
Applicative instance: 


-- The Applicative and Monad instances are slow (return and pure) because of witnessNat! avoid them!
-- Except they might not be so expensive. When 'n' is known witnessNat gets reduced to a constant at compile time.
instance Reify n => Applicative (Vec n) where
  {-# INLINE pure #-}
  pure = replicate
  {-# INLINE (<*>) #-}
  (<*>) = zipWith id
Monad instance: 


instance Reify n => Monad (Vec n) where
  {-# INLINE return #-}
  return  = replicate
  {-# INLINE (>>=) #-}
  x >>= f = diagonal (fmap f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sparsecheck-0.1.0.3/SparseCheck.hs
Monad instance: 


instance Monad LP where
  return a = LP (\s k -> k s a)
  m >>= f = LP (\s k -> unLP m s (\s a -> unLP (f a) s k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/vcache-trie-0.2.4/hsrc_lib/Strict.hs
Applicative instance: 

instance Applicative Strict where
    pure = Strict
    (<*>) (Strict f) (Strict a) = Strict (f a)
Monad instance: 

instance Monad Strict where
    return = Strict
    (>>=) (Strict a) fn = fn a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/vcache-trie-0.2.4/hsrc_lib/Ident.hs
Applicative instance: 

instance Applicative Ident where
    pure = return
    (<*>) = ap
Monad instance: 

instance Monad Ident where
    return = Ident
    (>>=) m fn = fn (runIdent m)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/EdisonCore-1.3.1.1/src/Data/Edison/Seq/RandList.hs
Applicative instance: 


instance App.Applicative Seq where
  pure = return
  x <*> y = do
     x' <- x
     y' <- y
     return (x' y')
Monad instance: 


instance Monad Seq where
  return = singleton
  xs >>= k = concatMap k xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/EdisonCore-1.3.1.1/src/Data/Edison/Seq/BankersQueue.hs
Applicative instance: 


instance App.Applicative Seq where
  pure = return
  x <*> y = do
     x' <- x
     y' <- y
     return (x' y')
Monad instance: 


instance Monad Seq where
  return = singleton
  xs >>= k = concatMap k xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/EdisonCore-1.3.1.1/src/Data/Edison/Seq/SizedSeq.hs
Applicative instance: 


instance S.Sequence s => App.Applicative (Sized s) where
  pure = return
  x <*> y = do
     x' <- x
     y' <- y
     return (x' y')
Monad instance: 


instance S.Sequence s => Monad (Sized s) where
  return = singleton
  xs >>= k = concatMap k xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/EdisonCore-1.3.1.1/src/Data/Edison/Seq/MyersStack.hs
Applicative instance: 


instance App.Applicative Seq where
  pure = return
  x <*> y = do
     x' <- x
     y' <- y
     return (x' y')
Monad instance: 


instance Monad Seq where
  return = singleton
  xs >>= k = concatMap k xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/EdisonCore-1.3.1.1/src/Data/Edison/Seq/BraunSeq.hs
Applicative instance: 


instance App.Applicative Seq where
  pure = return
  x <*> y = do
     x' <- x
     y' <- y
     return (x' y')
Monad instance: 


instance Monad Seq where
  return = singleton
  xs >>= k = concatMap k xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/EdisonCore-1.3.1.1/src/Data/Edison/Seq/SimpleQueue.hs
Applicative instance: 


instance App.Applicative Seq where
  pure = return
  x <*> y = do
     x' <- x
     y' <- y
     return (x' y')
Monad instance: 


instance Monad Seq where
  return = singleton
  xs >>= k = concatMap k xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/EdisonCore-1.3.1.1/src/Data/Edison/Seq/BinaryRandList.hs
Applicative instance: 


instance App.Applicative Seq where
  pure = return
  x <*> y = do
     x' <- x
     y' <- y
     return (x' y')
Monad instance: 


instance Monad Seq where
  return = singleton
  xs >>= k = concatMap k xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/EdisonCore-1.3.1.1/src/Data/Edison/Seq/JoinList.hs
Applicative instance: 


instance App.Applicative Seq where
  pure = return
  x <*> y = do
     x' <- x
     y' <- y
     return (x' y')
Monad instance: 


instance Monad Seq where
  return = singleton
  xs >>= k = concatMap k xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/EdisonCore-1.3.1.1/src/Data/Edison/Seq/RevSeq.hs
Applicative instance: 


instance S.Sequence s => App.Applicative (Rev s) where
  pure = return
  x <*> y = do
     x' <- x
     y' <- y
     return (x' y')
Monad instance: 


instance S.Sequence s => Monad (Rev s) where
  return = singleton
  xs >>= k = concatMap k xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/cheapskate-0.1.0.5/Cheapskate/ParserCombinators.hs
Applicative instance: 


instance Applicative Parser where
  pure x = Parser $ \st -> Right (st, x)
  (Parser f) <*> (Parser g) = Parser $ \st ->
    case f st of
         Left e         -> Left e
         Right (st', h) -> case g st' of
                                Right (st'', x) -> Right (st'', h x)
                                Left e          -> Left e
  {-# INLINE pure #-}
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Parser where
  return x = Parser $ \st -> Right (st, x)
  fail e = Parser $ \st -> Left $ ParseError (position st) e
  p >>= g = Parser $ \st ->
    case evalParser p st of
         Left e        -> Left e
         Right (st',x) -> evalParser (g x) st'
  {-# INLINE return #-}
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/units-2.4/Data/Metrology/Unsafe.hs
Applicative instance: 


instance Applicative (UnsafeQu d l) where
  pure x = UnsafeQu (Qu x)
  UnsafeQu (Qu f) <*> UnsafeQu (Qu x) = UnsafeQu (Qu (f x))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/source-code-server-2010.9.1/src/Rika/Data/Record/Label.hs
Applicative instance: 


instance Applicative (Point f i) where
  pure a = Point (const a) (const id)
  a <*> b = Point (_get a <*> _get b) (\r -> _set b r . _set a r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/TypeIlluminator-0.0/TypeIlluminator.hs
Monad instance: 


instance Monad Error where
  return = Correct
  (Correct a) >>= f = f a
  (Wrong s) >>= _ = Wrong s
  fail = Wrong
Monad instance: 


instance Monad (TI a) where
  return x   = TI (\_ n -> Right (n,x))
  TI c >>= f = TI (\ce n ->
                   case c ce n of
                     Right (m,x) -> let TI fx = f x in fx ce m
                     Left x      -> Left x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskeline-0.7.2.3/System/Console/Haskeline/Command.hs
Applicative instance: 


instance Monad m => Applicative (CmdM m) where
    pure  = Result
    (<*>) = ap
Monad instance: 


instance Monad m => Monad (CmdM m) where
    return = pure

    GetKey km >>= g = GetKey $ fmap (>>= g) km
    DoEffect e f >>= g = DoEffect e (f >>= g)
    CmdM f >>= g = CmdM $ liftM (>>= g) f
    Result x >>= g = g x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/darcs-cabalized-2.0.2.2/src/Darcs/Patch/ReadMonads.hs
Monad instance: 

instance Monad SM where
    SM m >>= k = SM $ \s -> case m s of
                                Nothing -> Nothing
                                Just (x, s') ->
                                    case k x of
                                        SM y -> y s'
    return x         = SM (\s -> Just (x,s))
    fail _           = SM (\_ -> Nothing)
Monad instance: 

instance Monad LM where
    LM m >>= k = LM $ \s -> let (x, s') = m s
                                LM y = k x
                            in y s'
    return x = LM (\s -> (x,s))
    fail s = error s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/error-continuations-0.1.0.0/src/Control/Monad/Trans/EitherCont.hs
Applicative instance: 


-- |The 'Applicative' instance encodes applicativity of 'EitherContT' 'a' 'l'
-- 'm' 'r' in 'r'.
instance Applicative (EitherContT a l m) where
    pure r = EitherContT $ \_ kr -> kr r
    ecf <*> ec = EitherContT $ \kl kr ->
        runEitherContT ecf kl (\f -> runEitherContT ec kl (kr . f))
Monad instance: 


-- |The 'Monad' instance encodes monadicity of 'EitherContT' 'a' 'l' 'm' 'r' in
-- 'r'.
instance Monad (EitherContT a l m) where
    return = pure
    ec >>= ecf = EitherContT $ \kl kr ->
        runEitherContT ec kl (\r -> runEitherContT (ecf r) kl kr)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/error-continuations-0.1.0.0/src/Control/Monad/Trans/MaybeCont.hs
Applicative instance: 


-- |The 'Applicative' instance encodes applicativity of 'MaybeContT' 'a' 'm'.
instance Applicative (MaybeContT a m) where
    pure r = MaybeContT $ \_ k -> k r
    mcf <*> mc = MaybeContT $ \ma k ->
        runMaybeContT mcf ma (\f -> runMaybeContT mc ma (k . f))
Monad instance: 


-- |The 'Monad' instance encodes monadicity of 'MaybeContT' 'a' 'm'.
instance Monad (MaybeContT a m) where
    return = pure
    mc >>= mcf = MaybeContT $ \ma k ->
        runMaybeContT mc ma (\r -> runMaybeContT (mcf r) ma k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hofix-mtl-1.0/Control/Monad/StarToStar/Fix.hs
Monad instance: 




instance (Iso (Fix ff), Monad (Other (Fix ff))) => Monad (Fix ff) where
  return = to . return
  m >>= k = to (from m >>= from . k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/parsec1-1.0.0.6/Text/ParserCombinators/Parsec/Prim.hs
Monad instance: 



-----------------------------------------------------------
-- Monad: return, sequence (>>=) and fail
-----------------------------------------------------------
instance Monad (GenParser tok st) where
  return x   = parsecReturn x
  p >>= f    = parsecBind p f
  fail msg   = parsecFail msg
Applicative instance: 


instance Applicative (GenParser tok st) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-experiment-4.0.3/Simulation/Aivika/Experiment/HtmlWriter.hs
Monad instance: 


instance Monad HtmlWriter where

  return a = HtmlWriter $ \f -> return (a, f)

  (HtmlWriter m) >>= k = HtmlWriter $ \f ->
    do (a, f') <- m f
       let HtmlWriter m' = k a
       m' f'
Applicative instance: 


instance Applicative HtmlWriter where

  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-experiment-4.0.3/Simulation/Aivika/Experiment/ExperimentWriter.hs
Applicative instance: 


instance Applicative ExperimentWriter where

  {-# INLINE pure #-}
  pure a =
    ExperimentWriter $ \r -> return a

  {-# INLINE (<*>) #-}
  (ExperimentWriter f) <*> (ExperimentWriter m) =
    ExperimentWriter $ \r -> f r <*> m r
Monad instance: 


instance Monad ExperimentWriter where

  {-# INLINE return #-}
  return a =
    ExperimentWriter $ \r -> return a

  {-# INLINE (>>=) #-}
  (ExperimentWriter m) >>= k =
    ExperimentWriter $ \r ->
    do a <- m r
       let ExperimentWriter b = k a
       b r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/non-empty-sequence-0.2.0.2/lib/Data/Sequence/NonEmpty.hs
Monad instance: 


instance Monad NonEmptySeq where
  return a = NonEmptySeq a Seq.empty
  NonEmptySeq a as >>= f = NonEmptySeq (_fore r1) rs
    where
      r1 = f a
      rs = _aft r1 `mappend` rss
      rss = join . fmap nonEmptySeqToSeq . fmap f $ as
Applicative instance: 


instance Applicative NonEmptySeq where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/network-protocol-xmpp-0.4.8/lib/Network/Protocol/XMPP/ErrorT.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (ErrorT e m) where
        pure a  = ErrorT $ return (Right a)
        f <*> v = ErrorT $ do
                mf <- runErrorT f
                case mf of
                        Left  e -> return (Left e)
                        Right k -> do
                                mv <- runErrorT v
                                case mv of
                                        Left  e -> return (Left e)
                                        Right x -> return (Right (k x))
Monad instance: 


instance Monad m => Monad (ErrorT e m) where
        return = ErrorT . return . Right
        (>>=) m k = ErrorT $ do
                x <- runErrorT m
                case x of
                        Left l -> return (Left l)
                        Right r -> runErrorT (k r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/network-protocol-xmpp-0.4.8/lib/Network/Protocol/XMPP/Monad.hs
Monad instance: 


instance Monad XMPP where
        return = XMPP . return
        m >>= f = XMPP (unXMPP m >>= unXMPP . f)
Applicative instance: 


instance A.Applicative XMPP where
        pure = return
        (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CV-0.3.7/Utils/Stream.hs
Applicative instance: 


instance (Monad m) => Applicative (Stream m) where
    pure f  = repeatS f
    Terminated <*> _ = Terminated
    _ <*> Terminated = Terminated
    (Value a) <*> (Value b) = Value renext
      where
      renext = do
        (fun,anext) <- a
        (br,bnext)  <- b
        return (fun br,anext<*>bnext)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/CV-0.3.7/CV/Pixelwise.hs
Applicative instance: 


instance Applicative Pixelwise where
  pure x               = MkP maxBound  (pure x)
  MkP i f <*> MkP j g  = MkP (min i j) (f <*> g)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Concurrential-0.5.0.1/Control/Concurrent/Concurrential.hs
Applicative instance: 


instance Applicative Identity where
  pure = Identity
  f <*> x = Identity $ (runIdentity f) (runIdentity x)
Monad instance: 


instance Monad Identity where
  return = Identity
  x >>= k = Identity $ (runIdentity . k) (runIdentity x)
Applicative instance: 


instance Applicative Concurrential where
  pure = SCAtom . Sequential . pure
  cf <*> cx = SCBind cf (\f -> SCBind cx (\x -> pure (f x)))
Monad instance: 


instance Monad Concurrential where
  return = pure
  (>>=) = SCBind
Applicative instance: 


instance Applicative ConcurrentialAp where
  pure = ConcurrentialAp . pure
  cf <*> cx = ConcurrentialAp $ SCAp (unConcurrentialAp cf) (unConcurrentialAp cx)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/promise-0.1.0.0/src/Control/Concurrent/Promise.hs
Applicative instance: 


instance Applicative Promise where
  pure = Promise . async . return
  Promise mf <*> Promise mx = Promise $ do
      f <- mf
      x <- mx
      (f', x') <- waitBoth f x
      async $ return $ f' x'
Monad instance: 


instance Monad Promise where
   return = liftIO . return
   Promise m >>= f = Promise $ m >>= wait >>= unPromise . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/template-haskell-2.9.0.0/Language/Haskell/TH/Syntax.hs
Monad instance: 


instance Monad Q where
  return x   = Q (return x)
  Q m >>= k  = Q (m >>= \x -> unQ (k x))
  Q m >> Q n = Q (m >> n)
  fail s     = report True s >> Q (fail "Q monad failure")
Applicative instance: 


instance Applicative Q where
  pure x = Q (pure x)
  Q f <*> Q x = Q (f <*> x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/template-haskell-2.9.0.0/Language/Haskell/TH/PprLib.hs
Applicative instance: 


instance Applicative PprM where
      pure = return
      (<*>) = ap
Monad instance: 


instance Monad PprM where
    return x = PprM $ \s -> (x, s)
    m >>= k  = PprM $ \s -> let (x, s') = runPprM m s
                            in runPprM (k x) s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/scyther-proof-0.8.0.0/src/Scyther/Theory/Lexer.hs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/scyther-proof-0.8.0.0/src/Text/Dot.hs
Monad instance: 


instance Monad Dot where
  return a = Dot $ \ uq -> ([],uq,a)
  m >>= k  = Dot $ \ uq -> case unDot m uq of
                           (g1,uq',r) -> case unDot (k r) uq' of
                                           (g2,uq2,r2) -> (g1 ++ g2,uq2,r2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Dangerous-0.3.2/src/Control/Dangerous.hs
Applicative instance: 


instance Applicative Dangerous where
    pure x = Dangerous (Right x, [])
    (Dangerous (Left e, ws)) <*> _ = Dangerous (Left e, ws)
    (Dangerous (Right _, ws)) <*> (Dangerous (Left e, ws')) =
        Dangerous (Left e, ws ++ ws')
    (Dangerous (Right f, ws)) <*> (Dangerous (Right x, ws')) =
        Dangerous (Right $ f x, ws ++ ws')
Monad instance: 


instance Monad Dangerous where
    fail s = Dangerous (Left $ Failure s, [])
    return x = Dangerous (Right x, [])
    (Dangerous (Left e, ws)) >>= _ = Dangerous (Left e, ws)
    (Dangerous (Right v, ws)) >>= f = Dangerous $
        second (ws ++) $ runDangerous $ f v
Applicative instance: 


instance (Applicative f, Monad f) => Applicative (DangerousT f) where
    pure f = DangerousT $ pure (Right f, [])
    (DangerousT ff) <*> (DangerousT fa) = DangerousT $ thread <$> ff <*> fa where
        thread (Left e, ws) _ = (Left e, ws)
        thread (Right _, ws) (Left e, ws') = (Left e, ws ++ ws')
        thread (Right f, ws) (Right x, ws') = (Right $ f x, ws ++ ws')
Monad instance: 


instance (Monad m) => Monad (DangerousT m) where
    fail s = DangerousT (return (Left $ Failure s, []))
    return = lift . return
    (DangerousT m) >>= f = DangerousT $ m >>= \(r, ws) -> case r of
        Right x -> runDangerousT (f x) >>= return . second (ws ++)
        Left e -> return (Left e, ws)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/docker-0.3.0.0/src/Docker/Client/Http.hs
Applicative instance: 
 -- Applicative, Monad, MonadReader, MonadError, MonadTrans

instance Applicative m => Applicative (DockerT m) where
    pure a = DockerT $ pure a
    (<*>) (DockerT f) (DockerT v) =  DockerT $ f <*> v
Monad instance: 


instance Monad m => Monad (DockerT m) where
    (DockerT m) >>= f = DockerT $ m >>= unDockerT . f
    return = pure
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/boomerang-1.4.5.2/Text/Boomerang/Prim.hs
Applicative instance: 


instance Applicative (Parser e tok) where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad (Parser e tok) where
    return a =
        Parser $ \tok pos ->
            [Right ((a, tok), pos)]
    (Parser p) >>= f =
        Parser $ \tok pos ->
            case partitionEithers (p tok pos) of
              ([], []) -> []
              (errs,[]) -> map Left errs
              (_,as) -> concat [ runParser (f a) tok' pos' | ((a, tok'), pos') <- as ]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/storable-record-0.0.3.1/src/Foreign/Storable/RecordMinimalSize.hs
Applicative instance: 


instance Applicative (Access r) where
   {-# INLINE pure #-}
   {-# INLINE (<*>) #-}
   pure a = Access (pure a)
   Access f <*> Access x = Access (f <*> x)
Applicative instance: 


instance Applicative (Box r) where
   {-# INLINE pure #-}
   {-# INLINE (<*>) #-}
   pure a = Box (pure a) (pure ())
   f <*> x = Box (peek_ f <*> peek_ x) (poke_ f >> poke_ x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/storable-record-0.0.3.1/src/Foreign/Storable/RecordReaderPtr.hs
Applicative instance: 


instance Applicative (Access r) where
   {-# INLINE pure #-}
   {-# INLINE (<*>) #-}
   pure a = Access (pure a)
   Access f <*> Access x = Access (f <*> x)
Applicative instance: 


instance Applicative (Box r) where
   {-# INLINE pure #-}
   {-# INLINE (<*>) #-}
   pure a = Box (pure a) (pure ())
   f <*> x = Box (peek_ f <*> peek_ x) (poke_ f >> poke_ x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/storable-record-0.0.3.1/src/Foreign/Storable/Record.hs
Applicative instance: 


instance Applicative (Access r) where
   {-# INLINE pure #-}
   {-# INLINE (<*>) #-}
   pure a = Access (pure a)
   Access f <*> Access x = Access (f <*> x)
Applicative instance: 


instance Applicative (Box r) where
   {-# INLINE pure #-}
   {-# INLINE (<*>) #-}
   pure a = Box (const $ pure a) (const $ const $ pure ())
   f <*> x =
      Box
         (\ptr -> peek_ f ptr <*> peek_ x ptr)
         (\ptr r -> poke_ f ptr r >> poke_ x ptr r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/indexed-free-0.3.1/Control/MonadPlus/Indexed/Free.hs
Applicative instance: 


instance IxFunctor f => Applicative (IxFree f i i) where
    pure = ireturn
    (<*>) = iap
Monad instance: 


instance IxFunctor f => Monad (IxFree f i i) where
    return = ireturn
    (>>=) = (>>>=)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/indexed-free-0.3.1/Control/Monad/Indexed/Trans/Free.hs
Applicative instance: 


instance (Monad m, IxFunctor f) => Applicative (IxFreeT f m i i) where
    pure = ireturn
    (<*>) = iap
Monad instance: 


instance (Monad m, IxFunctor f) => Monad (IxFreeT f m i i) where
    return = ireturn
    (>>=) = (>>>=)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/indexed-free-0.3.1/Control/Monad/Indexed/Free.hs
Applicative instance: 


instance IxFunctor f => Applicative (IxFree f i i) where
    pure = ireturn
    (<*>) = iap
Monad instance: 


instance IxFunctor f => Monad (IxFree f i i) where
    return = ireturn
    (>>=) = (>>>=)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/neet-0.4.0.1/src/Neet/Training.hs
Applicative instance: 



instance Applicative (Training candidate score) where
  pure = DoneTraining
  (<*>) = apTraining
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/zippers-0.2.2/src/Control/Zipper/Internal.hs
Applicative instance: 

  {- INLINE (<.>) #-}

-- | This is an illegal 'Applicative'.
instance Applicative (Flow i b) where
  pure a = Flow (const a)
  {-# INLINE pure #-}
  Flow mf <*> Flow ma = Flow $ \ s -> case s of
    Ap _ _ _ _ l r -> mf l (ma r)
    _              -> mf s (ma s)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tickle-0.0.6/src/Data/Tickle/Get.hs
Applicative instance: 


-- | Apply a function on the @Get@ decoder result.
--
-- >>> runGet (fmap (+) word8 <*> word8) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (fmap (+) word8 <*> word8) (BLC.pack "a")
-- RunGetFail 1 ()
--
-- >>> runGet (fmap (+) word8 <*> word8) (BLC.pack "ab")
-- RunGet 195
--
-- >>> runGet (fmap (+) word8 <*> word8) (BLC.pack "abc")
-- RunGet 195
--
-- >>> runGet (pure 7 :: Get () Int) (BLC.pack "abc")
-- RunGet 7
--
-- prop> runGet (pure x :: Get () Int) (BLC.pack "abc") == _RunGet # x
instance Applicative (Get e) where
  pure =
    return
  {-# INLINE pure #-}
  (<*>) =
    apG
  {-# INLINE (<*>) #-}
Monad instance: 


-- | Sequence an action through the @Get@ decoder.
--
-- >>> runGet (return 7 :: Get () Int) (BLC.pack "abc")
-- RunGet 7
--
-- prop> runGet (return x :: Get () Int) (BLC.pack "abc") == _RunGet # x
--
-- >>> runGet (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2)) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2)) (BLC.pack "a")
-- RunGetFail 1 ()
--
-- >>> runGet (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2)) (BLC.pack "ab")
-- RunGet 195
--
-- >>> runGet (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2)) (BLC.pack "abc")
-- RunGet 195
instance Monad (Get e) where
  return =
    returnG
  (>>=) =
    bindG
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tickle-0.0.6/src/Data/Tickle/RunGetResult.hs
Applicative instance: 


-- |
--
-- >>> pure 7 :: RunGetResult () Int
-- RunGet 7
--
-- >>> _RunGet # (*2) <*> _RunGet # 9
-- RunGet 18
--
-- >>> _RunGetFail # (10, 2) <*> _RunGet # 9
-- RunGetFail 10 2
--
-- >>> _RunGet # (*2) <*> _RunGetFail # (11, 3)
-- RunGetFail 11 3
--
-- >>> _RunGetFail # (10, 2) <*> _RunGetFail # (11, 3)
-- RunGetFail 10 2
instance Applicative (RunGetResult e) where
  RunGet f <*> RunGet a =
    RunGet (f a)
  RunGet _ <*> RunGetFail i e =
    RunGetFail i e
  RunGetFail i e <*> _ =
    RunGetFail i e
  pure =
    RunGet
Monad instance: 


-- |
--
-- >>> _RunGet # 8 >>= \g -> if even g then _RunGet # (g * 2) else _RunGetFail # (13, g * 14)
-- RunGet 16
--
-- >>> _RunGet # 9 >>= \g -> if even g then _RunGet # (g * 2) else _RunGetFail # (13, g * 14)
-- RunGetFail 13 126
--
-- >>> _RunGetFail # (10, 8) >>= \g -> if even g then _RunGet # (g * 2) else _RunGetFail # (13, g * 14)
-- RunGetFail 10 8
instance Monad (RunGetResult e) where
  RunGet a >>= f =
    f a
  RunGetFail i e >>= _ =
    RunGetFail i e
  return =
    RunGet
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fusion-0.2.0/Fusion.hs
Applicative instance: 


instance (Monad m, Applicative m) => Applicative (Stream a m) where
    {-# SPECIALIZE instance Applicative (Stream a IO) #-}
    pure = Stream (pure . Done)
    {-# INLINE{-# INLINE_FUSED pure #-}[1] pure #-}
    sf <*> sx = Stream (\() -> Done <$> (runStream sf <*> runStream sx)) ()
    {-# INLINE{-# INLINE_FUSED (<*>) #-}[1] (<*>) #-}
Applicative instance: 


instance (Monad m, Applicative m) => Applicative (ListT m) where
    {-# SPECIALIZE instance Applicative (ListT IO) #-}
    pure = return
    {-# INLINE pure #-}
    (<*>) = ap
    {-# INLINE (<*>) #-}
Monad instance: 


instance (Monad m, Applicative m) => Monad (ListT m) where
    {-# SPECIALIZE instance Monad (ListT IO) #-}
    return = ListT . fromList . (:[])
    {-# INLINE return #-}
    (>>=) = (concatL .) . flip fmap
    {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sphero-0.1.0.0/Network/Protocol/Orbotix/Sphero.hs
Applicative instance: 


instance Applicative Sphero where
    pure a = Sphero (pure a)
    Sphero f <*> Sphero a = Sphero (f <*> a)
Monad instance: 


instance Monad Sphero where
    return a = Sphero (return a)
    Sphero ma >>= kmb = Sphero $ do
        a <- ma
        let Sphero mb = kmb a
        mb
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/data-textual-0.3.0.2/src/Data/Textual.hs
Applicative instance: 


instance Applicative Parsed where
  pure = Parsed
  {-# INLINE pure #-}
  Parsed f       <*> Parsed a       = Parsed (f a)
  Malformed ls e <*> _              = Malformed ls e
  _              <*> Malformed ls e = Malformed ls e
  {-# INLINABLE (<*>) #-}
Applicative instance: 


instance Applicative Parser where
  pure a = Parser $ \ls n i c _ → c ls n i a
  {-# INLINE pure #-}
  p <*> p' = Parser $ \ls n i c h →
               runParser p ls n i
                 (\ls' n' i' f →
                    runParser p' ls' n' i'
                      (\ls'' n'' i'' a → c ls'' n'' i'' (f a)) h)
                 h
  {-# INLINE (<*>) #-}
  p *> p' = Parser $ \ls n i c h →
              runParser p ls n i (\ls' n' i' _ → runParser p' ls' n' i' c h) h
  {-# INLINE (*>) #-}
  p <* p' = Parser $ \ls n i c h →
              runParser p ls n i
                        (\ls' n' i' a →
                           runParser p' ls' n' i'
                                     (\ls'' n'' i'' _ → c ls'' n'' i'' a) h)
                        h
  {-# INLINE (<*) #-}
Monad instance: 


instance Monad Parser where
  return = pure
  {-# INLINE return #-}
  p >>= f = Parser $ \ls n i c h →
              runParser p ls n i
                        (\ls' n' i' a → runParser (f a) ls' n' i' c h) h
  {-# INLINE (>>=) #-}
  (>>) = (*>)
  {-# INLINE (>>) #-}
  fail = PC.unexpected
  {-# INLINE fail #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ralist-0.1.0.0/Data/RAList.hs
Monad instance: 


instance Monad RAList where
    return x = RAList 1 (Cons 1 (Leaf x) Nil)
    (>>=) = flip concatMap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sym-0.9/Data/Permgram.hs
Monad instance: 


instance Monad Permgram where
    return x = permgram (P.fromList [0]) [x]
    w >>= f  = joinPermgram $ fmap f w
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/antisplice-0.8.0.1/src/Game/Antisplice/Utils/Fail.hs
Monad instance: 


instance Monad m => Monad (FailT e m) where
  return a = Fail $ return $ Right a
  m >>= f = Fail $ do
    v <- runFailT m
    case v of
      Left e -> return $ Left e
      Right x -> runFailT $ f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/antisplice-0.8.0.1/src/Game/Antisplice/Utils/Counter.hs
Monad instance: 


instance Monad m => Monad (CounterT m) where
  return a = Counter $ \s -> return (a,s)
  m >>= f = Counter $ \s -> do (a,s') <- runCounterT m s; runCounterT (f a) s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/antisplice-0.8.0.1/src/Game/Antisplice/Monad/Dungeon.hs
Monad instance: 


instance Monad m => Monad (RoomT m) where
  return a = Room $ \s -> return (a,s)
  m >>= f = Room $ \s -> do (a,s') <- runRoomT m s; runRoomT (f a) s'
Monad instance: 


instance Monad m => Monad (ObjectT m) where
  return a = Object $ \s -> return (a,s)
  m >>= f = Object $ \s -> do (a,s') <- runObjectT m s; runObjectT (f a) s'
Monad instance: 


instance Monad m => Monad (PlayerT m) where
  return a = Player $ \s -> return (a,s)
  m >>= f = Player $ \s -> do (a,s') <- runPlayerT m s; runPlayerT (f a) s'
Monad instance: 


instance Monad m => Monad (DungeonT m) where
  return a = Dungeon $ \s -> return (a,s)
  m >>= f = Dungeon $ \s -> do (a,s') <- runDungeonT m s; runDungeonT (f a) s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/antisplice-0.8.0.1/src/Game/Antisplice/Monad/Vocab.hs
Monad instance: 


instance Monad m => Monad (VocabT m) where
  return a = Vocab $ \s -> return (a,s)
  m >>= f = Vocab $ \s -> do (a,s') <- runVocabT m s; runVocabT (f a) s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/progression-0.5.0.2/Progression/Config.hs
Monad instance: 


instance Monad OptM where
  fail = Error
  return = Result

  ShowHelp >>= _ = ShowHelp
  (Error e) >>= _ = Error e
  (Result x) >>= f = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/progression-0.5.0.2/Progression/Plot.hs
Monad instance: 


instance Monad FailM where
  fail = Fail
  return = Fine
  (Fail s) >>= _ = Fail s
  (Fine x) >>= f = f x
Applicative instance: 


instance Applicative FailM where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/audiovisual-0.0/src/Data/Audio.hs
Applicative instance: 


instance Applicative Source where
  pure a = Source (const a)
  Source f <*> Source g = Source (f <*> g)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/clafer-0.4.4/src/Language/Clafer/Front/ErrM.hs
Monad instance: 


instance Monad Err where
  return      = pure
  fail        = Bad noPos
  Ok a  >>= f = f a
  Bad p s >>= _ = Bad p s
Applicative instance: 


instance Applicative Err where
  pure = Ok
  (Bad p s) <*> _ = Bad p s
  (Ok f) <*> o  = fmap f o
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/direct-murmur-hash-1.0.1/Data/Digest/Murmur3.hs
Applicative instance: 

instance Applicative Identity where
  pure = return
  (<*>) = ap
Monad instance: 

instance Monad Identity where
  return a = MakeIdentity a
  (>>=) x f = f $ identityAction x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/PTQ-0.0.7/src/Parser.hs
Applicative instance: 


instance Applicative Parser where
    pure  = return
    (<*>) = ap
Monad instance: 


instance Monad Parser where
    return x = Parser $ \_ s ts -> [(x,s,ts)]
    m >>= f = Parser $ \env s ts ->
              do (v,s',ts') <- runParser m env s ts
                 runParser (f v) env s' ts'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haxl-0.3.1.0/Haxl/Core/Monad.hs
Monad instance: 


instance Monad (GenHaxl u) where
  return a = GenHaxl $ \_env _ref -> return (Done a)
  GenHaxl m >>= k = GenHaxl $ \env ref -> do
    e <- m env ref
    case e of
      Done a       -> unHaxl (k a) env ref
      Throw e      -> return (Throw e)
      Blocked cont -> return (Blocked (cont :>>= k))

  -- We really want the Applicative version of >>
  (>>) = (*>)
Applicative instance: 


instance Applicative (GenHaxl u) where
  pure = return
  GenHaxl f <*> GenHaxl a = GenHaxl $ \env ref -> do
    r <- f env ref
    case r of
      Throw e -> return (Throw e)
      Done f' -> do
        ra <- a env ref
        case ra of
          Done a'    -> return (Done (f' a'))
          Throw e    -> return (Throw e)
          Blocked a' -> return (Blocked (f' :<$> a'))
      Blocked f' -> do
        ra <- a env ref  -- left is blocked, explore the right
        case ra of
          Done a'    -> return (Blocked (($ a') :<$> f'))
          Throw e    -> return (Blocked (f' :<*> Cont (throw e)))
          Blocked a' -> return (Blocked (f' :<*> a'))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/data-object-yaml-0.3.4.2/Data/Object/Yaml.hs
Monad instance: 

instance Monad m => Monad (PErrorT m) where
    return = PErrorT . return . Right
    (PErrorT m) >>= f = PErrorT $ do
        e <- m
        case e of
            Left e' -> return $ Left e'
            Right a -> runPErrorT $ f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/swagger2-2.1.2.1/src/Data/Swagger/Declare.hs
Applicative instance: 


instance (Applicative m, Monad m, Monoid d) => Applicative (DeclareT d m) where
  pure x = DeclareT (\_ -> pure (mempty, x))
  DeclareT df <*> DeclareT dx = DeclareT $ \d -> do
    ~(d',  f) <- df d
    ~(d'', x) <- dx (d <> d')
    return (d' <> d'', f x)
Monad instance: 


instance (Applicative m, Monad m, Monoid d) => Monad (DeclareT d m) where
  return x = DeclareT (\_ -> pure (mempty, x))
  DeclareT dx >>= f = DeclareT $ \d -> do
    ~(d',  x) <- dx d
    ~(d'', y) <- runDeclareT (f x) (d <> d')
    return (d' <> d'', y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/swagger2-2.1.2.1/src/Data/Swagger/Internal/Schema/Validation.hs
Applicative instance: 


instance Applicative Result where
  pure = Passed
  Passed f <*> Passed x = Passed (f x)
  Failed xs <*> Failed ys = Failed (xs <> ys)
  Failed xs <*> _ = Failed xs
  _ <*> Failed ys = Failed ys
Monad instance: 


instance Monad Result where
  return = pure
  Passed x >>=  f = f x
  Failed xs >>= f = Failed xs
Applicative instance: 


instance Applicative (Validation schema) where
  pure x = Validation (\_ _ -> pure x)
  Validation f <*> Validation x = Validation (\c s -> f c s <*> x c s)
Monad instance: 


instance Monad (Validation s) where
  return = pure
  Validation x >>= f = Validation (\c s -> x c s >>= \x -> runValidation (f x) c s)
  (>>) = (*>)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/xml-hamlet-0.4.0.9/Text/Hamlet/XMLParse.hs
Monad instance: 

instance Monad Result where
    return = Ok
    Error s >>= _ = Error s
    Ok v >>= f = f v
    fail = Error
Applicative instance: 

instance Applicative Result where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fenfire-0.1/Utils.hs
Applicative instance: 


instance (Applicative f, Applicative g) => Applicative (Comp f g) where
    pure = Comp . pure . pure
    Comp f <*> Comp x = Comp $ forA2 f x (<*>)
Monad instance: 


instance Monad m => Monad (BreadthT m) where
    return  = BreadthT . return
    m >>= f = BreadthT (runBreadthT m >>= runBreadthT . f)
Monad instance: 


instance Monad m => Monad (MaybeT m) where
    return x = MaybeT $ return (Just x)
    m >>= f  = MaybeT $ do x <- runMaybeT m
                           maybe (return Nothing) (runMaybeT . f) x
    fail _   = mzero
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fenfire-0.1/_darcs/pristine/Utils.hs
Applicative instance: 


instance (Applicative f, Applicative g) => Applicative (Comp f g) where
    pure = Comp . pure . pure
    Comp f <*> Comp x = Comp $ forA2 f x (<*>)
Monad instance: 


instance Monad m => Monad (BreadthT m) where
    return  = BreadthT . return
    m >>= f = BreadthT (runBreadthT m >>= runBreadthT . f)
Monad instance: 


instance Monad m => Monad (MaybeT m) where
    return x = MaybeT $ return (Just x)
    m >>= f  = MaybeT $ do x <- runMaybeT m
                           maybe (return Nothing) (runMaybeT . f) x
    fail _   = mzero
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fenfire-0.1/_darcs/pristine/Preprocessor/Hsx/ParseMonad.hs
Monad instance: 


instance Monad P where
        return a = P $ \_i _x _y _l s _m -> Ok s a
        P m >>= k = P $ \i x y l s mode ->
                case m i x y l s mode of
                    Failed loc msg -> Failed loc msg
                    Ok s' a -> runP (k a) i x y l s' mode
        fail s = P $ \_r _col _line loc _stk _m -> Failed loc s
Monad instance: 


instance Monad (Lex r) where
        return a = Lex $ \k -> k a
        Lex v >>= f = Lex $ \k -> v (\a -> runL (f a) k)
        Lex v >> Lex w = Lex $ \k -> v (\_ -> w k)
        fail s = Lex $ \_ -> fail s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fenfire-0.1/_darcs/pristine/Preprocessor/Hsx/Transform.hs
Monad instance: 


instance Monad HsxM where
 return x = MkHsxM (\s -> (x,s))
 (MkHsxM f) >>= k = MkHsxM (\s -> let (a, s') = f s
                                      (MkHsxM f') = k a
                                   in f' s')
Monad instance: 


instance Monad RN where
 return a = RN $ \s -> (a,s)
 (RN f) >>= k = RN $ \s -> let (a,s') = f s
                               (RN g) = k a
                            in g s'
Monad instance: 


instance Monad Tr where
 return a = Tr $ \s -> return (a, s)
 (Tr f) >>= k = Tr $ \s ->
                  do (a, s') <- f s
                     let (Tr f') = k a
                     f' s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fenfire-0.1/_darcs/pristine/Preprocessor/Hsx/Pretty.hs
Monad instance: 


instance Monad (DocM s) where
        (>>=) = thenDocM
        (>>) = then_DocM
        return = retDocM
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fenfire-0.1/Preprocessor/Hsx/ParseMonad.hs
Monad instance: 


instance Monad P where
        return a = P $ \_i _x _y _l s _m -> Ok s a
        P m >>= k = P $ \i x y l s mode ->
                case m i x y l s mode of
                    Failed loc msg -> Failed loc msg
                    Ok s' a -> runP (k a) i x y l s' mode
        fail s = P $ \_r _col _line loc _stk _m -> Failed loc s
Monad instance: 


instance Monad (Lex r) where
        return a = Lex $ \k -> k a
        Lex v >>= f = Lex $ \k -> v (\a -> runL (f a) k)
        Lex v >> Lex w = Lex $ \k -> v (\_ -> w k)
        fail s = Lex $ \_ -> fail s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fenfire-0.1/Preprocessor/Hsx/Transform.hs
Monad instance: 


instance Monad HsxM where
 return x = MkHsxM (\s -> (x,s))
 (MkHsxM f) >>= k = MkHsxM (\s -> let (a, s') = f s
                                      (MkHsxM f') = k a
                                   in f' s')
Monad instance: 


instance Monad RN where
 return a = RN $ \s -> (a,s)
 (RN f) >>= k = RN $ \s -> let (a,s') = f s
                               (RN g) = k a
                            in g s'
Monad instance: 


instance Monad Tr where
 return a = Tr $ \s -> return (a, s)
 (Tr f) >>= k = Tr $ \s ->
                  do (a, s') <- f s
                     let (Tr f') = k a
                     f' s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fenfire-0.1/Preprocessor/Hsx/Pretty.hs
Monad instance: 


instance Monad (DocM s) where
        (>>=) = thenDocM
        (>>) = then_DocM
        return = retDocM
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/api-tools-0.5.2/src/Data/API/JSON.hs
Applicative instance: 


instance Applicative ParserWithErrs where
  pure x    = ParserWithErrs $ \ _ _ -> ([], Just x)
  pf <*> ps = ParserWithErrs $ \ q z ->
                  let (es_f, mb_f) = runParserWithErrs pf q z
                      (es_s, mb_s) = runParserWithErrs ps q z
                  in (es_f ++ es_s, mb_f <*> mb_s)
Monad instance: 


instance Monad ParserWithErrs where
  return   = pure
  px >>= f = ParserWithErrs $ \ q z ->
                  case runParserWithErrs px q z of
                    (es, Just x ) -> let (es', r) = runParserWithErrs (f x) q z
                                     in (es ++ es', r)
                    (es, Nothing) -> (es, Nothing)
  fail     = failWith . SyntaxError
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hails-0.9.2.2/Hails/Web/Router.hs
Monad instance: 


instance Monad RouteM where
  return a = Route (const . const . const $ return Nothing) a
  (Route rtA valA) >>= fn =
    let (Route rtB valB) = fn valA
    in Route (\pi conf req -> do
      resA <- rtA pi conf req
      case resA of
        Nothing -> rtB pi conf req
        Just _ -> return resA) valB
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/optparse-applicative-0.9.1.1/Options/Applicative/Internal.hs
Applicative instance: 


instance Applicative P where
  pure a = P $ pure a
  P f <*> P a = P $ f <*> a
Monad instance: 


instance Monad P where
  return a = P $ return a
  P x >>= k = P $ x >>= \a -> case k a of P y -> y
Applicative instance: 


instance Applicative ComplResult where
  pure = ComplResult
  (<*>) = ap
Monad instance: 


instance Monad ComplResult where
  return = pure
  m >>= f = case m of
    ComplResult r -> f r
    ComplParser p -> ComplParser p
    ComplOption c -> ComplOption c
Applicative instance: 


instance Applicative Completion where
  pure a = Completion $ pure a
  Completion f <*> Completion a = Completion $ f <*> a
Monad instance: 


instance Monad Completion where
  return a = Completion $ return a
  Completion x >>= k = Completion $ x >>= \a -> case k a of Completion y -> y
Applicative instance: 


instance Monad m => Applicative (ListT m) where
  pure = hoistList . pure
  (<*>) = ap
Monad instance: 


instance Monad m => Monad (ListT m) where
  return = pure
  xs >>= f = ListT $ do
    s <- stepListT xs
    case s of
      TNil -> return TNil
      TCons x xt -> stepListT $ f x `mplus` (xt >>= f)
Applicative instance: 


instance Monad m => Applicative (NondetT m) where
  pure = NondetT . pure
  NondetT m1 <*> NondetT m2 = NondetT (m1 <*> m2)
Monad instance: 


instance Monad m => Monad (NondetT m) where
  return = pure
  NondetT m1 >>= f = NondetT $ m1 >>= runNondetT . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/optparse-applicative-0.9.1.1/Options/Applicative/Help/Chunk.hs
Applicative instance: 


instance Applicative Chunk where
  pure = Chunk . pure
  Chunk f <*> Chunk x = Chunk (f <*> x)
Monad instance: 


instance Monad Chunk where
  return = pure
  m >>= f = Chunk $ unChunk m >>= unChunk . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/optparse-applicative-0.9.1.1/Options/Applicative/Types.hs
Applicative instance: 


instance Applicative ReadM where
  pure = ReadM . Right
  ReadM b <*> ReadM a = ReadM (b <*> a)
Monad instance: 


instance Monad ReadM where
  return = ReadM . Right
  ReadM m >>= f = ReadM $ m >>= runReadM . f
  fail = ReadM . Left . ErrorMsg
Applicative instance: 


instance Applicative Parser where
  pure = NilP . Just
  (<*>) = MultP
Monad instance: 


instance Monad ParserM where
  return x = ParserM $ \k -> k x
  ParserM f >>= g = ParserM $ \k -> f (\x -> runParserM (g x) k)
Applicative instance: 


instance Applicative ParserM where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/applicative-extras-0.1.8/Control/Applicative/Error.hs
Applicative instance: 


instance Applicative Failing where
   pure = Success
   Failure msgs <*> Failure msgs' = Failure (msgs ++ msgs')
   Success _ <*> Failure msgs' = Failure msgs'
   Failure msgs' <*> Success _ = Failure msgs'
   Success f <*> Success x = Success (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/applicative-extras-0.1.8/Control/Applicative/Compose.hs
Applicative instance: 


{- The composition of any two Applicatives is an idiom -}
instance (Applicative f, Applicative g) => Applicative (f :+: g) where
   pure x = Compose$ (pure pure) <*> (pure x)
   Compose fs <*> Compose xs = Compose $ pure (<*>) <*> fs <*> xs
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/applicative-extras-0.1.8/Control/Applicative/Backwards.hs
Applicative instance: 


instance (Applicative t) => Applicative (Backwards t) where
 pure a = Backwards (pure a)
 (Backwards f) <*> (Backwards a) = Backwards (a <**> f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/indexed-extras-0.2/Control/Monad/Indexed/State.hs
Monad instance: 


instance Monad (IxState i i) where
        return = ireturn
        m >>= k = ibind k m
Applicative instance: 


instance Applicative (IxState i i) where
        pure = ireturn
        (<*>) = iap
Monad instance: 


instance Monad m => Monad (IxStateT m i i) where
        return = ireturn
        m >>= k = ibind k m
Applicative instance: 


instance Monad m => Applicative (IxStateT m i i) where
        pure = ireturn
        (<*>) = iap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monoids-0.3.2/Data/Monoid/Monad.hs
Applicative instance: 


instance Monad m => Applicative (MonadSum m) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unique-logic-0.3/src/UniqueLogic/ST/Expression.hs
Applicative instance: 


instance Applicative (Apply w s) where
   pure a = Apply $ return a
   Apply f <*> Apply a = Apply $ ap f a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/unique-logic-0.3/src/UniqueLogic/ST/SystemLog.hs
Applicative instance: 


instance Applicative (T w s) where
   pure = Cons . return
   (<*>) = ap
Monad instance: 


instance Monad (T w s) where
   return = Cons . return
   Cons x >>= k  = Cons $ run . k =<< x
Applicative instance: 


instance Monoid w => Applicative (Apply w s) where
   pure a = Apply $ pure a
   Apply f <*> Apply a = Apply $ f <*> a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/urlpath-5.0.0.1/src/Data/Url.hs
Applicative instance: 


instance Applicative m => Applicative (AbsoluteUrlT m) where
  pure x = AbsoluteUrlT $ const (pure x)
  f <*> x = AbsoluteUrlT $ \r ->
    runAbsoluteUrlT f r <*> runAbsoluteUrlT x r
Monad instance: 


instance Monad m => Monad (AbsoluteUrlT m) where
  return x = AbsoluteUrlT $ const (return x)
  m >>= f = AbsoluteUrlT $ \r ->
    runAbsoluteUrlT m r >>= (\x -> runAbsoluteUrlT (f x) r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/exception-transformers-0.4.0.4/Control/Monad/Exception.hs
Monad instance: 


instance (Monad m) => Monad (ExceptionT m) where
    return a = ExceptionT $ return (Right a)
    m >>= k  = ExceptionT $ do
        a <- runExceptionT m
        case a of
          Left l  -> return (Left l)
          Right r -> runExceptionT (k r)
    fail msg = ExceptionT $ return (Left (E.toException (userError msg)))
Applicative instance: 


instance (Functor m, Monad m) => Applicative (ExceptionT m) where
    pure a  = ExceptionT $ return (Right a)
    f <*> v = ExceptionT $ do
        mf <- runExceptionT f
        case mf of
            Left  e -> return (Left e)
            Right k -> do
                mv <- runExceptionT v
                case mv of
                    Left  e -> return (Left e)
                    Right x -> return (Right (k x))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/xmonad-contrib-gpl-0.12.1/XMonad/Util/WindowState2.hs
Applicative instance: 


-- to silent GHC 7.8. It will break under 7.10.
instance Applicative (StateQuery s) where
    pure  = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hoodle-types-0.4/src/Data/Hoodle/Zipper.hs
Applicative instance: 



-- |
instance Applicative SeqZipper where
  pure = singletonSZ
  SZ (f,(f1s,f2s)) <*> SZ (x,(y1s,y2s)) = SZ (f x, (zipWith id f1s y1s, zipWith id f2s y2s))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/NonEmptyList-0.0.9/Data/List/NonEmpty.hs
Applicative instance: 


instance Applicative NonEmpty where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad NonEmpty where
  return = flip NonEmpty []
  NonEmpty h t >>= f = let NonEmpty a b = f h
                           k = t >>= toList . f
                       in NonEmpty a (b ++ k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/NonEmptyList-0.0.9/Data/List/ZipNonEmpty.hs
Applicative instance: 


instance Applicative ZipNonEmpty where
  pure = zipNe . unsafeToNonEmpty . repeat
  f <*> a = let z = toList . ne
            in zipNe . unsafeToNonEmpty $ zipWith id (z f) (z a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghci-8.0.1/GHCi/TH.hs
Applicative instance: 


instance Applicative GHCiQ where
  f <*> a = GHCiQ $ \s ->
    do (f',s')  <- runGHCiQ f s
       (a',s'') <- runGHCiQ a s'
       return (f' a', s'')
  pure x = GHCiQ (\s -> return (x,s))
Monad instance: 


instance Monad GHCiQ where
  m >>= f = GHCiQ $ \s ->
    do (m', s')  <- runGHCiQ m s
       (a,  s'') <- runGHCiQ (f m') s'
       return (a, s'')

  fail = Fail.fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/generic-tree-15329.2/Data/LTree.hs
Applicative instance: 


instance Functor v => Applicative (LTree v) where {
  pure x = Leaf x;
  (<*>) (Leaf f)  (Leaf x)  = Leaf (f x);
  (<*>) (Leaf f)  (Stem ts) = Stem (fmap (fmap f) ts);
  (<*>) (Stem ss) t         = Stem (fmap (<*> t) ss);
};
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/generic-tree-15329.2/Data/Tree.hs
Applicative instance: 


instance (Functor v, Alternative v) => Applicative (Tree v) where {
  pure x = Node x empty;
  (<*>) (Node f ss) t@(Node x ts) = Node (f x) (fmap (fmap f) ts <|> fmap (<*> t) ss);
};
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Yampa-0.9.7/src/FRP/Yampa/Task.hs
Applicative instance: 


instance Applicative (Task a b) where
    pure x  = Task (\k -> k x)
    f <*> v = Task (\k -> (unTask f) (\c -> unTask v (k . c)))
Monad instance: 


instance Monad (Task a b) where
    tk >>= f = Task (\k -> (unTask tk) (\c -> unTask (f c) k))
    return x = Task (\k -> k x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/harmony-0.1.1.0/src/Language/ErrM.hs
Monad instance: 


instance Monad Err where
  return      = Ok
  fail        = Bad
  Ok a  >>= f = f a
  Bad s >>= _ = Bad s
Applicative instance: 


instance Applicative Err where
  pure = Ok
  (Bad s) <*> _ = Bad s
  (Ok f) <*> o  = liftM f o
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/iotransaction-0.1/src/Control/IoTransaction.hs
Monad instance: 


instance ExceptionalMonad m => Monad (UndoableM m) where
    {-
    We combine two UndoableMs by making a new one that executes the
    first one and then tries to execute the second; if the first fails,
    the UndoableM fails; if the second fails, the UndoableM undoes the first and
    then fails.  The new UndoableM returns the value retuned by the second
    along with an undo action that is a combination of the undo actions of the
    first and second UndoableMs.
    -}
    Do op >>= f  = Do $ do (val, undo)   <- op
                           (val', undo') <- runUndoableM (f val) `catchM` (\e -> undo >> throwM (e :: C.SomeException))
                           return (val', undo >> undo')

    return val = Do $ return (val, return ())
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/control-monad-free-0.6.1/Control/Monad/Free/Improve.hs
Monad instance: 

--  fmap f (C m) = C (m . (.f))

instance Monad (C mu) where
  return a = C (\h -> h a)
  C p >>= k = C (\h -> p (\a -> case k a of C q -> q h))
Applicative instance: 


instance Applicative (C mu) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/control-monad-free-0.6.1/Control/Monad/Free.hs
Monad instance: 


instance Functor f => Monad (Free f) where
    return          = Pure
    Pure a    >>= f = f a
    Impure fa >>= f = Impure (fmap (>>= f) fa)
Applicative instance: 


instance Functor f => Applicative (Free f) where
  pure = Pure
  Pure   f <*> x = fmap f x
  Impure f <*> x = Impure (fmap (<*> x) f)
Applicative instance: 


instance (Functor f, Functor a, Monad a) => Applicative (FreeT f a) where
    pure = FreeT . return . Left
    (<*>) = ap
Monad instance: 


instance (Functor f, Monad m) => Monad (FreeT f m) where
    return = FreeT . return . Left
    m >>= f = FreeT $ unFreeT m >>= \r ->
        case r of
             Left  x  -> unFreeT $ f x
             Right xc -> return . Right $ fmap (>>= f) xc
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/paragon-0.1.9/src/Language/Java/Paragon/TypeCheck/Monad/TcCont.hs
Monad instance: 




instance Monad (TcCont r) where
  return x = TcCont $ \k -> k x
  TcCont f >>= h = TcCont $ \k ->
                    f (\a -> let TcCont g = h a in g k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/paragon-0.1.9/src/Language/Java/Paragon/TypeCheck/Monad/TcBase.hs
Monad instance: 



instance Monad TcBase where
  return x = TcBase $ \_ _ _ _ -> return $ Right x
  TcBase f >>= k = TcBase $ \tm ty u ec -> do
                        esa <- f tm ty u ec
                        case esa of
                          Left err -> return $ Left err
                          Right a -> do
                              let TcBase g = k a
                              g tm ty u ec
  fail err = TcBase $ \_ _ _ ec -> return (Left $ ec err)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/paragon-0.1.9/src/Language/Java/Paragon/TypeCheck/Monad/TcMonad.hs
Monad instance: 


-------------------------------------


instance Monad (Tc r) where
  return x = Tc $ \_ s -> return (x, s, [])
  Tc f >>= k = Tc $ \e s0 -> do
                     (a, s1, cs1) <- f e s0
                     let Tc g = k a
                     (b, s2, cs2) <- g e s1
                     return (b, s2, cs1 ++ cs2)
  fail err = Tc $ \_ _ -> fail err
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-memo-0.4.1/Control/Monad/Trans/Memo/StateCache.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (StateCache c m) where
    {-# INLINE pure #-}
    pure = return
    {-# INLINE (<*>) #-}
    fa <*> aa = StateCache $ \ !c -> do
        (f, c') <- runStateCache fa c
        (a, c'') <- runStateCache aa c'
        return (f a, c'')
Monad instance: 


instance (Monad m) => Monad (StateCache c m) where
    {-# INLINE return #-}
    return a = StateCache $ \ !c -> return (a, c)
    {-# INLINE (>>=) #-}
    m >>= k  = StateCache $ \ !c -> do
        (a, !c') <- runStateCache m c
        runStateCache (k a) c'
    {-# INLINE (>>) #-}
    m >> n   = StateCache $ \ !c -> do
        (_, !c') <- runStateCache m c
        runStateCache n c'
    fail str = StateCache $ \_ -> fail str
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-memo-0.4.1/Control/Monad/Trans/Memo/ReaderCache.hs
Applicative instance: 


instance (Applicative m) => Applicative (ReaderCache arr m) where
    {-# INLINE pure #-}
    pure a  = ReaderCache $ \_ -> pure a
    {-# INLINE (<*>) #-}
    f <*> v = ReaderCache $ \ !c -> evalReaderCache f c <*> evalReaderCache v c
Monad instance: 


instance (Monad m) => Monad (ReaderCache c m) where
    {-# INLINE return #-}
    return a = ReaderCache $ \ !c -> return a
    {-# INLINE (>>=) #-}
    m >>= k  = ReaderCache $ \ !c -> do
        a <- evalReaderCache m c
        evalReaderCache (k a) c
    {-# INLINE (>>) #-}
    m >> k   = ReaderCache $ \ !c -> do
        evalReaderCache m c
        evalReaderCache k c
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/data-cycle-0.1.2/Data/Cycle.hs
Applicative instance: 


instance Applicative Cycle where
  pure = singleton
  fs <*> xs = fromList (toList fs <*> toList xs)
Monad instance: 


instance Monad Cycle where
  return = pure
  xs >>= fn = fromList $ toList xs >>= (toList . fn)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/BiGUL-1.0.1/src/Generics/BiGUL/Interpreter.hs
Applicative instance: 


instance Applicative BiGULResult where
  pure x = BiGULResult (Just x, BTSuccess)
  (<*>)  = ap
Monad instance: 


instance Monad BiGULResult where
  return = pure
  BiGULResult (Just x , t) >>= f = f x
  BiGULResult (Nothing, t) >>= f = BiGULResult (Nothing, t)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hsdev-0.2.0.0/src/HsDev/Project/Types.hs
Applicative instance: 


instance Applicative Extensions where
        pure = Extensions [] []
        (Extensions l lo f) <*> (Extensions r ro x) = Extensions (ordNub $ l ++ r) (ordNub $ lo ++ ro) (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/options-1.2.1.1/lib/Options.hs
Applicative instance: 


instance Applicative DefineOptions where
        pure a = DefineOptions a (\key -> (key, [])) (\key _ -> Right (key, a))
        (DefineOptions acc_default acc_getInfo acc_parse) <*> (DefineOptions defaultValue getInfo parse) = DefineOptions
                (acc_default defaultValue)
                (\key -> case acc_getInfo key of
                        (key', infos) -> case getInfo key' of
                                (key'', infos') -> (key'', infos ++ infos'))
                (\key tokens -> case acc_parse key tokens of
                        Left err -> Left err
                        Right (key', fn) -> case parse key' tokens of
                                Left err -> Left err
                                Right (key'', a) -> Right (key'', fn a))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/options-1.2.1.1/lib/Options/Tokenize.hs
Applicative instance: 


instance Applicative Tok where
        pure = return
        (<*>) = ap
Monad instance: 


instance Monad Tok where
        return = Tok . return
        m >>= f = Tok (unTok m >>= unTok . f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-core-0.8.0.1/src/Synthesizer/Interpolation/Class.hs
Applicative instance: 


instance Applicative (MAC a v) where
   {-# INLINE pure #-}
   {-# INLINE (<*>) #-}
   pure x = MAC $ const (x, const x)
   MAC f <*> MAC x =
      MAC $ \av ->
         let (xav,add) = x av
             (g,fadd)  = f av
         in  (g xav, \y -> fadd y (add y))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-core-0.8.0.1/src/Synthesizer/Basic/Wave.hs
Applicative instance: 


instance App.Applicative (T t) where
   {-# INLINE pure #-}
   pure y = Cons (const y)
   {-# INLINE (<*>) #-}
   Cons f <*> Cons y = Cons (\t -> f t (y t))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-core-0.8.0.1/src/Synthesizer/State/Signal.hs
Applicative instance: 


instance App.Applicative T where
   pure = singleton
   x <*> y = liftA2 ($) x y
Monad instance: 


instance Monad T where
   return = singleton
   x >>= k =
      runViewL x $ \f s0 ->
      flip generate (fmap (mapFst k) $ f s0) $ \m ->
      m >>=
      let go (y,s) =
             mplus
                (fmap (\(y1,ys) -> (y1, Just (ys,s))) (viewL y))
                (fmap (mapFst k) (f s) >>= go)
      in  go
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-core-0.8.0.1/src/Synthesizer/Plain/Filter/Recursive/Universal.hs
Applicative instance: 


instance App.Applicative Parameter where
   {-# INLINE pure #-}
   pure x = Parameter x x x x x x
   {-# INLINE (<*>) #-}
   f <*> p = Parameter
      (k1 f $ k1 p) (k2 f $ k2 p) (ampIn f $ ampIn p) (ampI1 f $ ampI1 p) (ampI2 f $ ampI2 p) (ampLimit f $ ampLimit p)
Applicative instance: 


instance App.Applicative Result where
   {-# INLINE pure #-}
   pure x = Result x x x x
   {-# INLINE (<*>) #-}
   f <*> p = Result
      (highpass f $ highpass p) (bandpass f $ bandpass p) (lowpass f $ lowpass p) (bandlimit f $ bandlimit p)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-core-0.8.0.1/src/Synthesizer/Plain/Filter/Recursive/SecondOrder.hs
Applicative instance: 


instance App.Applicative Parameter where
   {-# INLINE pure #-}
   pure x = Parameter x x x x x
   {-# INLINE (<*>) #-}
   f <*> p = Parameter
      (c0 f $ c0 p) (c1 f $ c1 p) (c2 f $ c2 p) (d1 f $ d1 p) (d2 f $ d2 p)
Applicative instance: 


instance App.Applicative State where
   {-# INLINE pure #-}
   pure x = State x x x x
   {-# INLINE (<*>) #-}
   f <*> p = State
      (u1 f $ u1 p) (u2 f $ u2 p) (y1 f $ y1 p) (y2 f $ y2 p)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-core-0.8.0.1/src/Synthesizer/Plain/Filter/Recursive/Allpass.hs
Applicative instance: 


instance App.Applicative Parameter where
   {-# INLINE pure #-}
   pure x = Parameter x
   {-# INLINE (<*>) #-}
   Parameter f <*> Parameter k =
      Parameter (f k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-core-0.8.0.1/src/Synthesizer/Plain/Filter/Recursive/FirstOrder.hs
Applicative instance: 


instance App.Applicative Parameter where
   {-# INLINE pure #-}
   pure x = Parameter x
   {-# INLINE (<*>) #-}
   Parameter f <*> Parameter k =
      Parameter (f k)
Applicative instance: 


instance App.Applicative Result where
   {-# INLINE pure #-}
   pure x = Result x x
   {-# INLINE (<*>) #-}
   f <*> p = Result (highpass_ f $ highpass_ p) (lowpass_ f $ lowpass_ p)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-core-0.8.0.1/src/Synthesizer/Plain/Filter/Recursive/Moog.hs
Applicative instance: 


instance App.Applicative Parameter where
   {-# INLINE pure #-}
   pure x = Parameter x (Filt1.Parameter x)
   {-# INLINE (<*>) #-}
   f <*> p = Parameter
      (feedback f $ feedback p) (lowpassParam f <*> lowpassParam p)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-core-0.8.0.1/src/Synthesizer/Interpolation.hs
Applicative instance: 


instance Applicative (PrefixReader y) where
   {-# INLINE pure #-}
   {-# INLINE (<*>) #-}
   pure = PrefixReader . pure . pure
   (PrefixReader f) <*> (PrefixReader x) =
       PrefixReader (liftA2 (<*>) f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/synthesizer-core-0.8.0.1/src/Synthesizer/Causal/Process.hs
Applicative instance: 


instance Applicative (T a) where
   pure = ArrowUtil.pure
   (<*>) = ArrowUtil.apply
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/snap-predicates-0.3.1/src/Snap/Route.hs
Monad instance: 


instance Monad (Routes m) where
    return  = Routes . return
    m >>= f = Routes $ _unroutes m >>= _unroutes . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hi3status-0.1.1.0/lib-src/Hi3Status/Block/Internal.hs
Applicative instance: 


instance Applicative BlockM where
    pure a = BlockM $ \_ _ _ -> return a
    (BlockM f) <*> (BlockM a) = BlockM $ \p u c -> (f p u c) <*> (a p u c)
Monad instance: 


instance Monad BlockM where
    BlockM a >>= m = BlockM $ \p u c -> do
        a' <- a p u c
        runBlockM (m a') p u c
    return = pure
    fail e = BlockM $ \_ _ _ -> fail e
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/kangaroo-0.4.0/src/Data/ParserCombinators/Kangaroo/ParseMonad.hs
Monad instance: 





instance Monad (GenKangaroo ust) where
  return = returnKang
  (>>=)  = bindKang
Applicative instance: 



instance Applicative (GenKangaroo ust) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/euphoria-0.8.0.0/FRP/Euphoria/Update.hs
Applicative instance: 


instance Applicative Update where
    pure x = Update (const x) (mempty :: Event ())
    Update f_final f_evt <*> Update a_final a_evt = Update
        (\(f_s, a_s) -> f_final f_s (a_final a_s))
        ((left <$> f_evt) `mappend` (right <$> a_evt))
        where
            left f = (f, mempty)
            right a = (mempty, a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/tweak-0.1.0.1/src/Control/Tweak/Internal.hs
Applicative instance: 


instance Applicative Maker where
   pure = Maker . fmap Pure . newVar

   Maker mf <*> Maker mx = Maker $ do
      apply mf mx
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lens-family-core-1.2.1/src/Lens/Family/State/Zoom.hs
Applicative instance: 


instance (Monoid c, Monad m) => Applicative (Zooming m c) where
  pure a = Zooming (return (mempty, a))
  Zooming f <*> Zooming x = Zooming $ do
    (a, f') <- f
    (b, x') <- x
    return (a `mappend` b, f' x')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/lens-family-core-1.2.1/src/Lens/Family/Clone.hs
Applicative instance: 


instance Applicative (IKleeneStore b b') where
  pure = Unit
  Unit f <*> a = fmap f a
  Battery f b <*> a = Battery (flip <$> f <*> a) b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/machinecell-3.2.0/src/Control/Arrow/Machine/Misc/Discrete.hs
Applicative instance: 


instance
    ArrowApply a => Applicative (Alg a i)
  where
    pure = Alg . constant
    af <*> aa = Alg $ (eval af &&& eval aa) >>> arr2 ($)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/machinecell-3.2.0/src/Control/Arrow/Machine/Types.hs
Applicative instance: 


instance
    ArrowApply a => Applicative (ProcessA a i)
  where
    pure = arr . const
    pf <*> px = (pf &&& px) >>> arr (uncurry ($))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chatty-utils-0.7.3.3/Data/Chatty/Fail.hs
Applicative instance: 


instance Monad m => Applicative (FailT e m) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad m => Monad (FailT e m) where
  return a = Fail $ return $ Right a
  m >>= f = Fail $ do
    v <- runFailT m
    case v of
      Left e -> return $ Left e
      Right x -> runFailT $ f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chatty-utils-0.7.3.3/Data/Chatty/Atoms.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (AtomStoreT m) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad m => Monad (AtomStoreT m) where
  return a = AtomStore $ \s -> return (a,s)
  m >>= f = AtomStore $ \s -> do (a,s') <- runAtomStoreT m s; runAtomStoreT (f a) s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chatty-utils-0.7.3.3/Data/Chatty/Counter.hs
Applicative instance: 


instance (Functor m,Monad m) => Applicative (CounterT m) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad m => Monad (CounterT m) where
  return a = Counter $ \s -> return (a,s)
  m >>= f = Counter $ \s -> do (a,s') <- runCounterT m s; runCounterT (f a) s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/chatty-utils-0.7.3.3/Data/Chatty/ListBuilder.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (StrictBuilderT i m) where
  (<*>) = ap
  pure = return
Monad instance: 


instance Monad m => Monad (StrictBuilderT i m) where
  return a = StrictBuilder $ \s -> return (a,s)
  m >>= f = StrictBuilder $ \s -> do (a,s') <- runStrictBuilderT m s; runStrictBuilderT (f a) s'
Applicative instance: 


instance (Functor m,Monad m) => Applicative (LazyBuilderT i m) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad m => Monad (LazyBuilderT i m) where
  return a = LazyBuilder $ \s -> return (a,s)
  m >>= f = LazyBuilder $ \s -> do (a,s') <- runLazyBuilderT m s; runLazyBuilderT (f a) s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/SyntaxMacros-1.0.3/src/Language/Grammars/Grammar.hs
Applicative instance: 


instance Applicative (PreProductions l env) where
 pure f = PP [ Pure f ]

 (PP f) <*> (PP g) = PP [ Star f' g' | f' <- f, g' <- g ]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/network-transport-tcp-0.5.1/tests/TestQC.hs
Monad instance: 


instance Monad Unifier where
  return x = Unifier $ \subst -> Just (x, subst)
  x >>= f  = Unifier $ \subst -> case runUnifier x subst of
                                   Nothing -> Nothing
                                   Just (a, subst') -> runUnifier (f a) subst'
  fail _str = mzero
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/timeplot-1.0.9/Tools/TimePlot/Incremental.hs
Applicative instance: 


instance Applicative (StreamSummary a) where
  pure r = Summary (\_ -> pure r)  r
  (!fs) <*> (!xs) = Summary (\a -> insert fs a <*> insert xs a) (finalize fs $ finalize xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/formal-0.1.0/src/hs/Formal/TypeCheck/Types.hs
Monad instance: 


instance Monad Z where
    return x = Z x
    (Z x) >>= f = f x
    (Error x) >>= _ = Error x
    fail x = Error x
Monad instance: 


instance Monad TI where
  fail x     = TI (\y -> error$ x ++ "\n" ++ msg y)
  return x   = TI (\y -> (y, x))
  TI f >>= g = TI (\x -> case f x of
                          (y, x) -> let TI gx = g x
                                   in  gx y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/formal-0.1.0/src/hs/Formal/Optimize.hs
Monad instance: 


instance Monad Optimizer where

    fail   x = Optimizer (\y -> error x)
    return x = Optimizer (\y -> (y, x))

    Optimizer f >>= g =
        Optimizer (\x -> case f x of (y, x) -> let Optimizer gx = g x in gx y)
Applicative instance: 


instance Applicative Optimizer where

    pure = return
    x <*> y = do f <- x
                 f <$> y
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/formal-0.1.0/src/hs/Formal/Javascript/Backend.hs
Monad instance: 


        instance Monad JS where
          fail x     = JS (\_ -> error$ x)
          return x   = JS (\y -> (y, x))
          JS f >>= g = JS (\x -> case f x of
                                  (y, x') -> let JS gx = g x'
                                             in  gx y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Limit-1.0/src/Data/Limit.hs
Monad instance: 


instance Monad Limit where
    Unbounded >>= _ = Unbounded
    (Bounded x) >>= k = k x

    Unbounded >> _ = Unbounded
    (Bounded _) >> k = k

    return = Bounded
    fail _ = Unbounded
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/asn1-data-0.7.2/Data/ASN1/Get.hs
Applicative instance: 


instance Applicative Get where
    pure  = return
    (<*>) = ap
Monad instance: 


-- Definition directly from Control.Monad.State.Strict
instance Monad Get where
    return a = Get $ \ s0 b0 m0 p0 _ ks -> ks s0 b0 m0 p0 a

    m >>= g  = Get $ \s0 b0 m0 p0 kf ks ->
        let ks' s1 b1 m1 p1 a = unGet (g a) s1 b1 m1 p1 kf ks
         in unGet m s0 b0 m0 p0 kf ks'

    fail     = failDesc
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/haskhol-core-1.1.0/src/HaskHOL/Core/State/Monad.hs
Monad instance: 


instance Monad (HOL cls thry) where
    return x = HOL $ \ _ _ -> return x
    m >>= k = HOL $ \ acid st ->
        do b <- runHOLUnsafe m acid st
           runHOLUnsafe (k b) acid st
    fail = throwHOL . HOLException
Applicative instance: 


instance Applicative (HOL cls thry) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Yampa-core-0.2.0/src/FRP/Yampa/Task.hs
Applicative instance: 


instance Applicative (Task a b) where
    pure x  = Task (\k -> k x)
    f <*> v = Task (\k -> (unTask f) (\c -> unTask v (k . c)))
Monad instance: 


instance Monad (Task a b) where
    tk >>= f = Task (\k -> unTask tk (\c -> unTask (f c) k))
    return x = Task (\k -> k x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/fmlist-0.9/Data/FMList.hs
Monad instance: 


instance Monad FMList where
  return     = one
  m >>= g    = transform (\f -> foldMap f . g) m
  m >> k     = transform (\f -> const (foldMap f k)) m
  fail _     = nil
Applicative instance: 


instance Applicative FMList where
  pure       = one
  gs <*> xs  = transform (\f g -> unFM xs (f . g)) gs
  as <*  bs  = transform (\f a -> unFM bs (const (f a))) as
  as  *> bs  = transform (\f   -> const (unFM bs f)) as
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/slim-0.0.1/src/Slim.hs
Applicative instance: 


instance Applicative (Behavior (Local t)) where
  pure x = LocalB (return (pure x))
  LocalB mbf <*> LocalB mbx = LocalB ((<*>) <$> mbf <*> mbx)
Applicative instance: 


instance Applicative (Behavior Shared) where
  pure x = SharedB (return x) mempty
  SharedB mf e1 <*> SharedB mx e2 = SharedB (mf <*> mx) (e1 <> e2)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/parsec3-1.0.1.8/Text/Parsec/Prim.hs
Applicative instance: 


instance Applicative.Applicative (ParsecT s u m) where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad (ParsecT s u m) where
    return x = parserReturn x
    p >>= f  = parserBind p f
    fail msg = parserFail msg
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Workflow-0.8.3/Control/Workflow.hs
Monad instance: 


instance Monad m =>  Monad (WF  s m) where
    return  x = WF (\s ->  return  (s, x))
    WF g >>= f = WF (\s -> do
                (s1, x) <- g s
                let WF fun=  f x
                fun s1)
Applicative instance: 


instance  (Monad m, Functor m) => Applicative  (WF s m) where
   pure x= return x
   WF f <*> WF g= WF $ \s ->  do
        (s1, k) <- f s
        (s2, x) <- g s1
        return  (s2,k x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/trifecta-1.6/src/Text/Trifecta/Result.hs
Applicative instance: 


instance Applicative Result where
  pure = Success
  {-# INLINE pure #-}
  Success f <*> Success a = Success (f a)
  Success _ <*> Failure y = Failure y
  Failure x <*> Success _ = Failure x
  Failure x <*> Failure y =
    Failure $ ErrInfo (vsep [_errDoc x, _errDoc y]) (_errDeltas x <> _errDeltas y)
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/trifecta-1.6/src/Text/Trifecta/Parser.hs
Applicative instance: 


instance Applicative Parser where
  pure a = Parser $ \ eo _ _ _ _ _ -> eo a mempty
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Parser where
  return a = Parser $ \ eo _ _ _ _ _ -> eo a mempty
  {-# INLINE return #-}
  Parser m >>= k = Parser $ \ eo ee co ce d bs ->
    m (\a e -> unparser (k a) (\b e' -> eo b (e <> e')) (\e' -> ee (e <> e')) co ce d bs) ee
      (\a es d' bs' -> unparser (k a)
         (\b e' -> co b (es <> _expected e') d' bs')
         (\e ->
           let errDoc = explain (renderingCaret d' bs') e { _expected = _expected e <> es }
               errDelta = _finalDeltas e
           in  ce $ ErrInfo errDoc (d' : errDelta)
         )
         co ce d' bs') ce d bs
  {-# INLINE (>>=) #-}
  (>>) = (*>)
  {-# INLINE (>>) #-}
  fail s = Parser $ \ _ ee _ _ _ _ -> ee (failed s)
  {-# INLINE fail #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/trifecta-1.6/src/Text/Trifecta/Util/It.hs
Applicative instance: 


instance Applicative (It r) where
  pure = Pure
  Pure f  <*> Pure a  = Pure $ f a
  Pure f  <*> It a ka = It (f a) $ fmap f . ka
  It f kf <*> Pure a  = It (f a) $ fmap ($a) . kf
  It f kf <*> It a ka = It (f a) $ \r -> kf r <*> ka r
Monad instance: 


instance Monad (It r) where
  return = Pure
  Pure a >>= f = f a
  It a k >>= f = It (extract (f a)) $ \r -> case k r of
    It a' k' -> It (indexIt (f a') r) $ k' >=> f
    Pure a' -> simplifyIt (f a') r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Hawk-0.0.2/src/Control/Monad/Either.hs
Monad instance: 


instance Monad m => Monad (EitherT a m) where
  return  = EitherT . return . Right
  m >>= k = EitherT $ do
    a <- runEitherT m
    case a of
        Left  l -> return (Left l)
        Right r -> runEitherT (k r)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/combinator-interactive-0.1.2/Data/Combinator.hs
Monad instance: 


instance Monad Expr where
    return = Var
    Var x >>= f = f x
    (a :$ b) >>= f = (a >>= f) :$ (b >>= f)
    I >>= _ = I
    K >>= _ = K
    S >>= _ = S
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rowrecord-0.1/Text/RowRecord.hs
Monad instance: 


instance Monad Result where
   return = Success
   Success x >>= f = f x
   Failure e >>= _ = Failure e
Applicative instance: 


instance Applicative Result where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/estimator-1.2.0.0/src/Numeric/Estimator/Augment.hs
Applicative instance: 


instance (Applicative state, Applicative extra) => Applicative (AugmentState state extra) where
  pure v = AugmentState (pure v) (pure v)
  v1 <*> v2 = AugmentState
    { getState = getState v1 <*> getState v2
    , getExtra = getExtra v1 <*> getExtra v2
    }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/estimator-1.2.0.0/src/Numeric/Estimator/Model/SensorFusion.hs
Applicative instance: 


instance Applicative StateVector where
    pure v = StateVector
        { stateOrient = pure v
        , stateVel = pure v
        , statePos = pure v
        , stateGyroBias = pure v
        , stateWind = pure v
        , stateMagNED = pure v
        , stateMagXYZ = pure v
        }
    v1 <*> v2 = StateVector
        { stateOrient = stateOrient v1 <*> stateOrient v2
        , stateVel = stateVel v1 <*> stateVel v2
        , statePos = statePos v1 <*> statePos v2
        , stateGyroBias = stateGyroBias v1 <*> stateGyroBias v2
        , stateWind = stateWind v1 <*> stateWind v2
        , stateMagNED = stateMagNED v1 <*> stateMagNED v2
        , stateMagXYZ = stateMagXYZ v1 <*> stateMagXYZ v2
        }
Applicative instance: 


instance Applicative DisturbanceVector where
    pure v = DisturbanceVector
        { disturbanceGyro = pure v
        , disturbanceAccel = pure v
        }
    v1 <*> v2 = DisturbanceVector
        { disturbanceGyro = disturbanceGyro v1 <*> disturbanceGyro v2
        , disturbanceAccel = disturbanceAccel v1 <*> disturbanceAccel v2
        }
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/KiCS-0.9.3/src/Curry/Compiler/SafeCalls.hs
Monad instance: 


instance Monad (Safe IO) where
  return x = Safe (return (Just x))
  (Safe act) >>= f = Safe $ do
     res <- act
     maybe (return Nothing) (\x->let Safe act = f x in act) res
  fail s = Safe (putStrLn s >> return Nothing)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/getemx-0.1/Emx/Emx.hs
Applicative instance: 


instance Applicative (Either a) where
    pure = Right
    (Right f) <*> (Right x) = Right $ f x
    (Left f) <*> _ = Left f
    _ <*> (Left x) = Left x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/libexpect-0.3.2/System/Expect/ExpectCombinators.hs
Monad instance: 


instance Monad ExpectM where
  return a = ExpectM (\x -> return (a, x))
  (ExpectM f) >>= g = ExpectM (\x -> do { (a, x') <- f x; expectMProc (g a) x'})
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-distributed-0.2/Simulation/Aivika/Distributed/Optimistic/Internal/DIO.hs
Monad instance: 


instance Monad DIO where

  {-# INLINE return #-}
  return = DIO . const . return

  {-# INLINE (>>=) #-}
  (DIO m) >>= k = DIO $ \ps ->
    m ps >>= \a ->
    let m' = unDIO (k a) in m' ps
Applicative instance: 


instance Applicative DIO where

  {-# INLINE pure #-}
  pure = return

  {-# INLINE (<*>) #-}
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gooey-0.1.0.0/src/Control/GUI.hs
Applicative instance: 


-- | A UX is an applicative if its left datatype is a monoid. It replies to
-- 'pure' with an empty left value while the right value is the argument
-- wrapped in an event. It means "the argument happens instantly with no
-- user interface".
instance Monoid a => Applicative (UX a) where
    pure a = UX mempty $ Event a
    (UX uia f) <*> (UX uib b) = UX (uia <> uib) (f <*> b)
Applicative instance: 


-- | A GUI is applicative if its UX\'s left value is a monoid. It responds
-- to 'pure' by returning a GUI that has no user interface and immediately
-- produces the argument. It responds to '<*>' by applying the left
-- argument to the right. Each side\'s left UX value will be 'mappend' \'d.
instance (Monad m, Monoid a) => Applicative (GUI m i a) where
    pure = GUI . pure . pure
    (GUI vf) <*> (GUI va) = GUI $ ((<*>) <$> vf) <*> va
Monad instance: 


-- | A GUI is a monad if its UX's left value is a monoid. It responds to
-- '>>=' by returning a new GUI that runs until it produces a value, then
-- that value is used to create yet another GUI.
instance (Monad m, Monoid a) => Monad (GUI m i a) where
    (GUI v) >>= f = GUI $ Var $ \i -> do
        (UX a e, v') <- runVar v i
        case e of
            NoEvent -> return (UX a NoEvent, runGUI $ GUI v' >>= f)
            Event b -> runVar (runGUI $ f b) i
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/urldisp-happstack-0.1/Happstack/UrlDisp.hs
Applicative instance: 


instance Monad m => Applicative (StateT UrlS m) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/monad-par-0.3.4.8/Control/Monad/Par/Scheds/Sparks.hs
Monad instance: 


--------------------------------------------------------------------------------
-- <boilerplate>

instance Monad Par where
  return = pure
  Done x >>= k = k x
Applicative instance: 


instance Applicative Par where
   (<*>) = ap
   pure  = Done
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/turingMachine-0.1.3.0/src/Math/Model/Turing/FourWays.hs
Applicative instance: 


instance Applicative Tracks where
        pure x = Track [] (pure x) []
        (<*>) (Track _ ft _) (Track _ t _) = Track [] (ft <*> t) []
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/turingMachine-0.1.3.0/src/Math/Model/Turing/TwoWays.hs
Applicative instance: 


instance Applicative Tape where
        pure x = T [] x []
        --
        (<*>) (T fs f gs) (T xs a ys) = T [] (f a) []
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/turingMachine-0.1.3.0/src/Data/State.hs
Applicative instance: 


-- |Same as Maybe
instance Applicative State where
        pure = Q
        QE <*> _ = QE
        (Q f) <*> q = fmap f q
Monad instance: 


-- |Same as Maybe
instance Monad State where
        return = pure
        QE >>= _ = QE
        (Q q) >>= f = f q
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/MonadRandom-0.4.2.3/Control/Monad/Random.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (RandT g m) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/iconv-0.4.1.3/Codec/Text/IConv/Internal.hs
Applicative instance: 


instance Applicative IConv where
  pure  = returnI
  (<*>) = ap
Monad instance: 


instance Monad IConv where
  (>>=)  = bindI
--  m >>= f = (m `bindI` \a -> consistencyCheck `thenI` returnI a) `bindI` f
  (>>)   = thenI
  return = returnI
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/data-fresh-0.2013.251.0/src/Control/Monad/Trans/Fresh/Delta.hs
Applicative instance: 


instance Applicative m => Applicative (FreshT v m) where
    pure x = FreshT $ \s -> pure (x, s)
    FreshT ff <*> FreshT xx = FreshT $ \(_ :< Triplet l _ r)
        -> (\(f, sf) (x, _) -> (f x, sf)) <$> ff l <*> xx r
Monad instance: 


instance Monad m => Monad (FreshT v m) where
    return x = FreshT $ \s -> return (x, s)
    FreshT aa >>= f = FreshT $ \(_ :< Triplet l _ r) -> do
        (a, _) <- aa l
        let FreshT ff = f a
        ff r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/data-fresh-0.2013.251.0/src/Control/Monad/Trans/Fresh/Stream.hs
Applicative instance: 


instance (Functor m, Monad m) => Applicative (FreshT v m) where
    pure = return
    FreshT ff <*> FreshT xx = FreshT $ \s -> do
        (fv, s1) <- ff s
        (xv, s2) <- xx s1
        return (fv xv, s2)
Monad instance: 


instance Monad m => Monad (FreshT v m) where
    return x = FreshT $ \s -> return (x, s)
    FreshT aa >>= f = FreshT $ \s -> do
        (a, s1) <- aa s
        let FreshT ff = f a
        ff s1
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/data-fresh-0.2013.251.0/src/Data/Triplet.hs
Applicative instance: 


instance Applicative Triplet where
    pure x = Triplet x x x
    Triplet fl fm fr <*> Triplet xl xm xr = Triplet (fl xl) (fm xm) (fr xr)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/vector-0.9.1/Data/Vector.hs
Monad instance: 


instance Monad Vector where
  {-# INLINE return #-}
  return = singleton

  {-# INLINE (>>=) #-}
  (>>=) = flip concatMap
Applicative instance: 


instance Applicative.Applicative Vector where
  {-# INLINE pure #-}
  pure = singleton

  {-# INLINE (<*>) #-}
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/bsparse-0.0.5/Data/ByteString/Parse.hs
Monad instance: 


instance Monad Parser where
    fail errorMsg = Parser $ \buf err _ -> err buf ("failed: " ++ errorMsg)
    return v = Parser $ \buf _ ok -> ok buf v
    m >>= k = Parser $ \buf err ok ->
         runParser m buf err (\buf' a -> runParser (k a) buf' err ok)
Applicative instance: 

instance Applicative Parser where
    pure      = return
    (<*>) d e = d >>= \b -> e >>= \a -> return (b a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wai-extra-3.0.9/Network/Wai/UrlMap.hs
Applicative instance: 


instance Applicative UrlMap' where
    pure x                        = UrlMap' [([], x)]
    (UrlMap' xs) <*> (UrlMap' ys) = UrlMap' [ (p, f y) |
                                              (p, y) <- ys,
                                              f <- map snd xs ]
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Dflow-0.0.1/src/Control/RTSP.hs
Monad instance: 



instance Monad (RTA s c) where
   return v = RTA $ \ s q t -> (v, s, q, t)
   rv >>= f = RTA $ \s q t ->
      let (v1, s1, q1, t1) = unRTA rv s q t
      in unRTA (f v1) s1 q1 t1
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-parser-2.1/Language/Parser.hs
Monad instance: 

instance Monad m => Monad (ParserT s m) where join = coerceJoin ParserT
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/definitive-parser-2.1/Data/Syntax.hs
Monad instance: 

instance NodeFunctor n m => Monad (SyntaxT n m) where join = coerceJoin SyntaxT
Monad instance: 

instance (NodeFunctor n m,Monad m) => Monad (ThunkT n m) where join = coerceJoin ThunkT
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/wai-request-spec-0.9.1.0/src/Network/Wai/RequestSpec/Internal/Parser.hs
Applicative instance: 


instance Applicative Result where
  pure = Success
  (Failure e) <*> (Failure e') = Failure (e <> e')
  (Failure e) <*> _            = Failure e
  _           <*> (Failure e)  = Failure e
  (Success f) <*> (Success x)  = Success (f x)
  {-# INLINE pure #-}
  {-# INLINE (<*>) #-}
Monad instance: 


instance Monad Result where
  return = pure
  (Failure e) >>= _ = Failure e
  (Success x) >>= f = f x
  {-# INLINE return #-}
  {-# INLINE (>>=) #-}
Monad instance: 


instance Monad P where
  return a = P $ \_ ks -> ks a mempty
  (P m) >>= k = P $ \kf ks ->
    m kf
      (\a e ->
        runP (k a) (\e'    -> kf (e <> e'))
                   ks
      )
  {-# INLINE return #-}
  {-# INLINE (>>=) #-}
Applicative instance: 


instance Applicative P where
  pure = return
  (P f) <*> (P p) = P $ \kf ks ->
    p (\e   ->
          f (\e'    -> kf (e <> e'))
            (\_  e' -> kf (e <> e'))
      )
      (\a e ->
          f (\e'    -> kf (e <> e'))
            (\f' e' -> ks (f' a) e')
      )
  {-# INLINE pure #-}
  {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/socks-0.5.5/Network/Socks5/Parse.hs
Monad instance: 


instance Monad Parser where
    fail errorMsg = Parser $ \buf err _ -> err buf ("failed: " ++ errorMsg)
    return v = Parser $ \buf _ ok -> ok buf v
    m >>= k = Parser $ \buf err ok ->
         runParser m buf err (\buf' a -> runParser (k a) buf' err ok)
Applicative instance: 

instance Applicative Parser where
    pure      = return
    (<*>) d e = d >>= \b -> e >>= \a -> return (b a)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/RepLib-0.5.4/Generics/RepLib/Lib.hs
Applicative instance: 


instance Applicative M where
  pure x = M x []
  (<*>)  = ap
Monad instance: 


instance Monad M where
 return x = M x []
 (M x xs) >>= k = M r (rs1 ++ rs2)
   where
     M r rs1 = k x
     rs2 = [r' | x' <- xs, let M r' _ = k x']
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/darcs-2.8.5/src/Darcs/IO.hs
Monad instance: 


instance Monad TolerantIO where
    f >>= g = runTM $ runIO f >>= runIO . g
    f >> g = runTM $ runIO f >> runIO g
    fail s = runTM $ fail s
    return x = runTM $ return x
Monad instance: 


instance Monad SilentIO where
    f >>= g = runTM $ runIO f >>= runIO . g
    f >> g = runTM $ runIO f >> runIO g
    fail s = runTM $ fail s
    return x = runTM $ return x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/darcs-2.8.5/src/Darcs/Patch/ReadMonads.hs
Monad instance: 


instance Monad SM where
    (>>=)  = bindSM
    return = returnSM
    fail   = failSM
Applicative instance: 


instance Applicative SM where
  pure = returnSM
  a <*> b =
    a `bindSM` \c ->
    b `bindSM` \d ->
    returnSM (c d)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hdph-0.0.1/src/Control/Parallel/HdpH/Internal/Type/Par.hs
Monad instance: 


-- The Monad instance is where we differ from Control.Monad.Cont,
-- the difference being the use of strict application ($!).
instance Monad (ParM m) where
    return a = Par $ \ c -> c $! a
    p >>= k  = Par $ \ c -> unPar p $ \ a -> unPar (k $! a) c
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hdph-0.0.1/src/Control/Parallel/HdpH/Internal/Misc.hs
Monad instance: 


-- The Monad instance is where we differ from Control.Monad.Cont,
-- the difference being the use of strict application ($!).
instance Monad (Cont r) where
    return a = Cont $ \ c -> c $! a
    m >>= k  = Cont $ \ c -> runCont m $ \ a -> runCont (k $! a) c
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/rsagl-0.6.0.1/RSAGL/Auxiliary/ApplicativeWrapper.hs
Applicative instance: 


instance (Applicative f) => Applicative (ApplicativeWrapper f) where
    pure = ApplicativeWrapper . Right
    (ApplicativeWrapper (Right f)) <*> (ApplicativeWrapper (Right a)) = ApplicativeWrapper $ Right $ f a
    f <*> a = wrapApplicative $ toApplicative f <*> toApplicative a
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Updater-0.3/Updater/Internal.hs
Applicative instance: 


--- START: INSTANCES ---

-- TODO: cleanup 
instance Applicative Updater where
        pure a = Updater $ \giveMeA -> giveMeA a
        (Updater giveMeNext1) <*> (Updater giveMeNext2) = Updater $ \restCalc state -> do
                varF <- newIORef Nothing
                varX <- newIORef Nothing
                varCleanup <- newIORef $ return ()

                let update state' = do
                                f' <- readIORef varF
                                x' <- readIORef varX
                                case (f', x') of
                                        (Just f, Just x) -> do
                                                join $ readIORef varCleanup
                                                upstateC <- restCalc (f x) state'
                                                writeIORef varCleanup $ stateOnCleanup upstateC
                                                return $ upstateC {
                                                        stateOnCleanup = return ()
                                                        }
                                        _ -> return mempty

                upState1 <- giveMeNext1 (\x state' -> writeIORef varF (Just x) >> update state') state
                upState2 <- giveMeNext2 (\x state' -> writeIORef varX (Just x) >> update state') state

                return $ upState1 `mappend` upState2 `mappend` mempty {
                        stateOnCleanup = join $ readIORef varCleanup
                        }
Monad instance: 


instance Monad Updater where
        (Updater giveMeNext) >>= valueToNextUpd = Updater $ updater where
                updater end =   giveMeNext $  \value -> runUpdater' (valueToNextUpd value) end
        return a = Updater $ \end -> end a
        fail _ = Updater $ \_ _ -> return mempty
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/logicst-0.1.0.0/src/Control/Monad/ST/Logic/Internal.hs
Applicative instance: 


instance Applicative (LogicT s m) where
  pure = LogicT . pure
  {-# INLINE pure #-}
  f <*> a = LogicT $ unLogicT f <*> unLogicT a
  {-# INLINE (<*>) #-}
#ifndef CLASS_OldApplicative
  a *> b = LogicT $ unLogicT a *> unLogicT b
  {-# INLINE (*>) #-}
  a <* b = LogicT $ unLogicT a <* unLogicT b
  {-# INLINE (<*) #-}
Monad instance: 


instance Monad (LogicT s m) where
  return = LogicT . return
  {-# INLINE return #-}
  m >>= k = LogicT $ unLogicT m >>= unLogicT . k
  {-# INLINE (>>=) #-}
  m >> n = LogicT $ unLogicT m >> unLogicT n
  {-# INLINE (>>) #-}
  fail = LogicT . fail
  {-# INLINE fail #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sci-ratio-0.2.1.0/tests/Main.hs
Applicative instance: 


instance Applicative Test where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad Test where
  return x     = Test $ \ s -> return (x, s)
  Test f >>= u = Test $ \ s -> do
    (x, s') <- f s
    runTest (u x) s'
  fail s       = failTest "aborted" >> fail s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gf-3.8/treebanks/susanne/Parser.hs
Monad instance: 


instance Monad P where
  return x = P (\pgf cnc ts -> Just (ts, x))
  f >>= g  = P (\pgf cnc ts -> case runP f pgf cnc ts of
                                    Nothing     -> Nothing
                                    Just (ts,x) -> runP (g x) pgf cnc ts)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gf-3.8/treebanks/PennTreebank/Monad.hs
Monad instance: 


instance Monad (P t e) where
  return x = P (\gr pgf m ts -> Just (x,ts))
  f >>= g  = P (\gr pgf m ts -> case unP f gr pgf m ts of
                                  Just (x,ts) -> unP (g x) gr pgf m ts
                                  Nothing     -> Nothing)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gf-3.8/treebanks/talbanken/MonadSP.hs
Monad instance: 


instance Monad m => Monad (P t e m) where
  return x = P $ \gr pgf m ts -> return (Just (x,ts))
  f >>= g  = P $ \gr pgf m ts -> unP f gr pgf m ts >>= \r -> case r of
                                  Just (x,ts') -> unP (g x) gr pgf m ts'
                                  Nothing      -> return Nothing
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gf-3.8/src/binary/Data/Binary/Put.hs
Applicative instance: 


instance Applicative PutM where
        pure    = return
        m <*> k = Put $
            let PairS f w  = unPut m
                PairS x w' = unPut k
            in PairS (f x) (w `mappend` w')
Monad instance: 


-- Standard Writer monad, with aggressive inlining
instance Monad PutM where
    return a = Put $ PairS a mempty
    {-# INLINE return #-}

    m >>= k  = Put $
        let PairS a w  = unPut m
            PairS b w' = unPut (k a)
        in PairS b (w `mappend` w')
    {-# INLINE (>>=) #-}

    m >> k  = Put $
        let PairS _ w  = unPut m
            PairS b w' = unPut k
        in PairS b (w `mappend` w')
    {-# INLINE (>>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gf-3.8/src/runtime/haskell/PGF/TypeCheck.hs
Applicative instance: 


instance Applicative (TcM s) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad (TcM s) where
  return x = TcM (\abstr k h -> k x)
  f >>= g  = TcM (\abstr k h -> unTcM f abstr (\x -> unTcM (g x) abstr k h) h)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gf-3.8/src/compiler/GF/CompileInParallel.hs
Applicative instance: 


instance (Functor m,Monad m) => Applicative (CollectOutput m) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad m => Monad (CollectOutput m) where
  return x = CO (return (done,x))
  CO m >>= f = CO $ do (o1,x) <- m
                       let CO m2 = f x
                       (o2,y) <- m2
                       return (o1>>o2,y)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gf-3.8/src/compiler/GF/Compile/TypeCheck/ConcreteNew.hs
Monad instance: 


instance Monad TcM where
  return x = TcM (\ms msgs -> TcOk x ms msgs)
  f >>= g  = TcM (\ms msgs -> case unTcM f ms msgs of
                                TcOk x ms msgs -> unTcM (g x) ms msgs
                                TcFail    msgs -> TcFail msgs)
  fail     = tcError . pp
Applicative instance: 


instance Applicative TcM where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gf-3.8/src/compiler/GF/Compile/GeneratePMCFG.hs
Applicative instance: 


instance Applicative CnvMonad where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad CnvMonad where
    return a   = CM (\gr c s -> c a s)
    CM m >>= k = CM (\gr c s -> m gr (\a s -> unCM (k a) gr c s) s)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gf-3.8/src/compiler/GF/Data/ErrM.hs
Monad instance: 


instance Monad Err where
  return      = Ok
  fail        = Bad
  Ok a  >>= f = f a
  Bad s >>= f = Bad s
Applicative instance: 


instance Applicative Err where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gf-3.8/src/compiler/GF/Data/BacktrackM.hs
Applicative instance: 


instance Applicative (BacktrackM s) where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad (BacktrackM s) where
    return a   = BM (\c s b -> c a s b)
    BM m >>= k = BM (\c s b -> m (\a s b -> unBM (k a) c s b) s b)
        where unBM (BM m) = m
    fail _ = mzero
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gf-3.8/src/compiler/GF/Infra/SIO.hs
Applicative instance: 


instance Applicative SIO where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad SIO where
  return x = SIO (const (return x))
  SIO m1 >>= xm2 = SIO $ \ h -> m1 h >>= \ x -> unS (xm2 x) h
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gf-3.8/src/compiler/GF/Infra/CheckM.hs
Monad instance: 


instance Monad Check where
  return x = Check $ \{-ctxt-} ws -> (ws,Success x)
  f >>= g  = Check $ \{-ctxt-} ws ->
               case unCheck f {-ctxt-} ws of
                 (ws,Success x) -> unCheck (g x) {-ctxt-} ws
                 (ws,Fail msg)  -> (ws,Fail msg)
Applicative instance: 


instance Applicative Check where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/gf-3.8/src/tools/c/GFCC/ErrM.hs
Monad instance: 


instance Monad Err where
  return      = Ok
  fail        = Bad
  Ok a  >>= f = f a
  Bad s >>= f = Bad s
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/csound-catalog-0.5.0/src/Csound/Catalog/Wave/WoodwindAlg.hs
Applicative instance: 


instance Applicative Rnd where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad Rnd where
    return = Rnd . return
    (Rnd a) >>= f = Rnd $ a >>= unRnd . f
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uniform-io-1.2.0.0/src/System/IO/Uniform/Streamline.hs
Monad instance: 


instance Monad m => Monad (Streamline m) where
  --return :: (Monad m) => a -> Streamline m a
  return x = Streamline  $ \cl -> return (x, cl)
  --(>>=) :: Monad m => Streamline m a -> (a -> Streamline m b) -> Streamline m b
  a >>= b = Streamline $ \cl -> do
    (x, cl') <- withTarget' a cl
    withTarget' (b x) cl'
Applicative instance: 


instance (Functor m, Monad m) => Applicative (Streamline m) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/uniform-io-1.2.0.0/src/System/IO/Uniform/Streamline/Scanner.hs
Applicative instance: 

instance Applicative IOScannerState where
  pure = Running
  Finished <*> _ = Finished
  _ <*> Finished = Finished
  (LastPass f) <*> (LastPass x) = LastPass $ f x
  (LastPass f) <*> (Running x) = LastPass $ f x
  (Running f) <*> (LastPass x) = LastPass $ f x
  (Running f) <*> (Running x) = Running $ f x
Monad instance: 

instance Monad IOScannerState where
  return = pure
  Finished >>= _ = Finished
  (LastPass x) >>= f = case f x of
    Finished -> Finished
    LastPass y -> LastPass y
    Running y -> LastPass y
  (Running x) >>= f = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/Transhare-0.9/Data/Transhare.hs
Applicative instance: 


instance Applicative TransResult where
  pure a = Original a
  (Original x) <*> (Original y) = Original (x y)
  tx <*> ty = Transformed (getTrans tx (getTrans ty))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/EditTimeReport-1.0/QueryAST.hs
Monad instance: 


instance Monad E where
  return = Ok
  m >>= k = case m of { Ok a -> k a ; Failed e -> Failed e }
  fail = Failed
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/satchmo-2.9.9.3/Satchmo/SAT/Mini.hs
Monad instance: 


instance Monad SAT where
    return x = SAT $ \ s -> return x
    SAT m >>= f = SAT $ \ s -> do
        x <- m s ; let { SAT n = f x } ; n s
Applicative instance: 


instance Applicative SAT where
    pure = return
    a <*> b = a >>= \ f -> fmap f b
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/THEff-0.1.1.0/src/Control/THEff.hs
Applicative instance: 


instance Applicative (Eff w) where
    pure = return
    Eff f <*> Eff g = Eff $ \k -> f (\v -> g (k . v))
Monad instance: 


instance Monad (Eff w) where
    return x = Eff $ \k -> k x
    m >>= f =  Eff $ \k -> runEff m (\v -> runEff (f v) k)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/BASIC-0.1.5.0/Language/BASIC/Parser.hs
Monad instance: 


-- Yuck!  But this is the only way I could figure out
-- how to make a Monad like Expr actually be able to save
-- every statement.
-- Now if we could just write 'x' instead of 'X' there
-- would be no need for unsafePerformIO.
instance Monad Expr where
    a >> b = unsafePerformIO $ do push (flex a); push (flex b)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hxt-filter-8.4.2/src/Control/Monad/MonadStateIO.hs
Monad instance: 


instance Monad (StateIO state) where
    return v
        = STIO ( \s -> return (v, s))

    STIO cmd >>= f
        = STIO ( \s ->
                  cmd s >>= \ (rl, s') ->
                  (trans . f) rl s'
                )
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-lattice-0.1.1/Simulation/Aivika/Lattice/Internal/LIO.hs
Monad instance: 


instance Monad LIO where

  {-# INLINE return #-}
  return = LIO . const . return

  {-# INLINE (>>=) #-}
  (LIO m) >>= k = LIO $ \ps ->
    m ps >>= \a ->
    let m' = unLIO (k a) in m' ps
Applicative instance: 


instance Applicative LIO where

  {-# INLINE pure #-}
  pure = return

  {-# INLINE (<*>) #-}
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/aivika-lattice-0.1.1/Simulation/Aivika/Lattice/Internal/Estimate.hs
Monad instance: 


instance Monad m => Monad (Estimate m) where

  {-# INLINE return #-}
  return a = Estimate $ \p -> return a

  {-# INLINE (>>=) #-}
  (Estimate m) >>= k =
    Estimate $ \p ->
    do a <- m p
       let Estimate m' = k a
       m' p
Applicative instance: 


instance Applicative m => Applicative (Estimate m) where

  {-# INLINE pure #-}
  pure = Estimate . const . pure

  {-# INLINE (<*>) #-}
  (Estimate x) <*> (Estimate y) = Estimate $ \p -> x p <*> y p
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/ghcjs-perch-0.3.3/src/Internal/Perch.hs
Applicative instance: 


instance Applicative PerchM
Monad instance: 


instance Monad PerchM where
  (>>) x y = mappend (unsafeCoerce x) y
  (>>=) = error "bind (>>=) invocation in the Perch monad creating DOM elements"
  return = mempty
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hackport-0.5/cabal/Cabal/Distribution/Compat/ReadP.hs
Applicative instance: 


instance Applicative (P s) where
  pure x = Result x Fail
  (<*>) = ap
Monad instance: 


instance Monad (P s) where
  return = AP.pure

  (Get f)      >>= k = Get (f >=> k)
  (Look f)     >>= k = Look (f >=> k)
  Fail         >>= _ = Fail
  (Result x p) >>= k = k x `mplus` (p >>= k)
  (Final r)    >>= k = final [ys' | (x,s) <- r, ys' <- run (k x) s]

  fail = Fail.fail
Applicative instance: 


instance Applicative (Parser r s) where
  pure x  = R (\k -> k x)
  (<*>) = ap
Monad instance: 


instance Monad (Parser r s) where
  return = AP.pure
  fail = Fail.fail
  R m >>= f = R (\k -> m (\a -> let R m' = f a in m' k))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hackport-0.5/cabal/Cabal/Distribution/Simple/BuildTarget.hs
Applicative instance: 


instance Applicative Match where
  pure a = ExactMatch 0 [a]
  (<*>) = ap
Monad instance: 


instance Monad Match where
  return = AP.pure

  NoMatch      d ms >>= _ = NoMatch d ms
  ExactMatch   d xs >>= f = addDepth d
                          $ foldr matchPlus matchZero (map f xs)
  InexactMatch d xs >>= f = addDepth d .  forceInexact
                          $ foldr matchPlus matchZero (map f xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hackport-0.5/cabal/Cabal/Distribution/PackageDescription/Parse.hs
Applicative instance: 


#if __GLASGOW_HASKELL__ >= 710
instance (Monad m) => Applicative (StT s m) where
#else
instance (Monad m, Functor m) => Applicative (StT s m) where
#endif
    pure a = StT (\s -> return (a,s))
    (<*>) = ap
Monad instance: 



instance Monad m => Monad (StT s m) where
#if __GLASGOW_HASKELL__ < 710
    return a = StT (\s -> return (a,s))
#endif
    StT f >>= g = StT $ \s -> do
                        (a,s') <- f s
                        runStT (g a) s'
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hackport-0.5/cabal/Cabal/Distribution/PackageDescription.hs
Applicative instance: 


instance Applicative Condition where
  pure  = Var
  (<*>) = ap
Monad instance: 


instance Monad Condition where
  return = AP.pure
  -- Terminating cases
  (>>=) (Lit x) _ = Lit x
  (>>=) (Var x) f = f x
  -- Recursing cases
  (>>=) (CNot  x  ) f = CNot (x >>= f)
  (>>=) (COr   x y) f = COr  (x >>= f) (y >>= f)
  (>>=) (CAnd  x y) f = CAnd (x >>= f) (y >>= f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/hackport-0.5/cabal/Cabal/Distribution/ParseUtils.hs
Applicative instance: 


instance Applicative ParseResult where
        pure = ParseOk []
        (<*>) = ap
Monad instance: 



instance Monad ParseResult where
        return = AP.pure
        ParseFailed err >>= _ = ParseFailed err
        ParseOk ws x >>= f = case f x of
                               ParseFailed err -> ParseFailed err
                               ParseOk ws' x' -> ParseOk (ws'++ws) x'
        fail = Fail.fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/infinite-search-0.12/Data/Searchable.hs
Monad instance: 


instance Monad Set where
    return = Set . const
    m >>= f = bigUnion (fmap f m)
Applicative instance: 


instance Applicative Set where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/scanner-0.2/lib/Scanner/Internal.hs
Applicative instance: 


instance Applicative Scanner where
  {-# INLINE pure #-}
  pure = return
  {-# INLINE (<*>) #-}
  (<*>) = ap

  {-# INLINE (*>) #-}
  (*>) = (>>)

  {-# INLINE (<*) #-}
  s1 <* s2 = s1 >>= \a -> s2 >> return a
Monad instance: 


instance Monad Scanner where
  {-# INLINE return #-}
  return a = Scanner $ \bs next ->
    next bs a

  {-# INLINE (>>=) #-}
  s1 >>= s2 = Scanner $ \bs next ->
    run s1 bs $ \bs' a ->
      run (s2 a) bs' next

  {-# INLINE  fail #-}
  fail err = Scanner $ \bs _ ->
    Fail bs err
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/spdx-0.2.1.0/src/Data/SPDX/LatticeSyntax.hs
Applicative instance: 


instance Applicative LatticeSyntax where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad LatticeSyntax where
  return = LVar
  LVar x    >>= f = f x
  LBound b  >>= _ = LBound b
  LJoin a b >>= f = LJoin (a >>= f) (b >>= f)
  LMeet a b >>= f = LMeet (a >>= f) (b >>= f)
Applicative instance: 


instance Applicative (Eval v) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad (Eval v) where
  return = Eval . return
  Eval m >>= k = Eval $ m >>= unEval . k
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/binembed-0.1.0.3/src/binembed.hs
Applicative instance: 


instance Applicative CodeGen where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad CodeGen where
  return a = CodeGen $ \_e -> (a, mempty)
  CodeGen a >>= b = CodeGen $ \e -> let (aa, ao) = a e
                                        (bb, bo) = runCodeGen (b aa) e
                                    in  (bb, ao `mappend` bo)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/language-objc-0.4.2.8/src/Language/ObjC/Parser/ParserMonad.hs
Monad instance: 


instance Monad (LP s) where
  {-# INLINE return #-}
  return a = LP $ \s !pSt -> (POk pSt a, s)
  {-# INLINE (>>=) #-}
  (LP m) >>= f = LP $ \s !pSt ->
                   let (r1, s1) = m s2 pSt
                       (r2, s2) = case r1 of
                                     POk pSt' a -> unLP (f a) s pSt'
                                     PFailed err pos -> (PFailed err pos, s)
                   in (r2, s1)
  {-# INLINE fail #-}
  fail m = LP $ \s pSt -> (PFailed [m] (curPos pSt), s)
Applicative instance: 


instance Applicative (LP s) where
  {-# INLINE pure #-}
  pure = return
  {-# INLINE (<*>) #-}
  f <*> m = f >>= \f' -> m >>= \m' -> pure (f' m')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/language-objc-0.4.2.8/src/Language/ObjC/Analysis/TravMonad.hs
Monad instance: 


instance Monad (Trav s) where
    return x  = Trav (\s -> Right (x,s))
    m >>= k   = Trav (\s -> case unTrav m s of
                              Right (x,s1) -> unTrav (k x) s1
                              Left e       -> Left e)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/compact-string-0.3.1/test/QuickCheckUtils.hs
Monad instance: 


instance Monad ((->) r) where
    return = const
    f >>= k = \ r -> k (f r) r
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/darcs-beta-2.7.99.2/src/Darcs/IO.hs
Monad instance: 


instance Monad TolerantIO where
    f >>= g = runTM $ runIO f >>= runIO . g
    f >> g = runTM $ runIO f >> runIO g
    fail s = runTM $ fail s
    return x = runTM $ return x
Monad instance: 


instance Monad SilentIO where
    f >>= g = runTM $ runIO f >>= runIO . g
    f >> g = runTM $ runIO f >> runIO g
    fail s = runTM $ fail s
    return x = runTM $ return x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/darcs-beta-2.7.99.2/src/Darcs/Patch/ReadMonads.hs
Monad instance: 


instance Monad SM where
    (>>=)  = bindSM
    return = returnSM
    fail   = failSM
Applicative instance: 


instance Applicative SM where
  pure = returnSM
  a <*> b =
    a `bindSM` \c ->
    b `bindSM` \d ->
    returnSM (c d)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/iterIO-0.2.2/Data/IterIO/Trans.hs
Monad instance: 


instance (Monad m) => Monad (IterStateT s m) where
    return a = IterStateT $ \s -> return (a, s)
    (IterStateT mf) >>= k = IterStateT $ \s -> do (a, s') <- mf s
                                                  let (IterStateT kf) = k a
                                                  kf $! s'
    fail = IterStateT . const . fail
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/iterIO-0.2.2/Data/IterIO/Iter.hs
Applicative instance: 


instance (Monad m) => Applicative (Iter t m) where
    pure   = return
    (<*>)  = ap
    (*>)   = (>>)
    a <* b = do r <- a; b >> return r
Monad instance: 


instance (Monad m) => Monad (Iter t m) where
    {-# INLINE return #-}
    return a = Iter $ Done a

    {-# INLINE (>>=) #-}
    -- Because check calls itself and (>>=) recursively, IterF and
    -- IterM likely cannot be inlined.  However, inlining Done and
    -- Fail (which can occur quite often for parsing failures) in the
    -- first part of this function seems to give about a 1-2% speedup.
    m >>= k = Iter $ \c0 -> case runIter m c0 of
                              (Done a c)   -> runIter (k a) c
                              (Fail e _ c) -> Fail e Nothing c
                              r          -> check r
        where check (IterM mm)             = IterM $ mm >>= return . check
              check (IterF i)              = IterF $ i >>= k
              check (IterC (CtlArg a n c)) = IterC $ CtlArg a (n >=> k) c
              check (Fail e _ c)           = Fail e Nothing c
              check (Done a c)             = runIter (k a) c

    fail msg = Iter $ Fail (IterException $ toException $ ErrorCall msg)
                                       Nothing . Just
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/simple-0.9.0.0/src/Web/Simple/Controller/Trans.hs
Applicative instance: 


instance (Monad m, Functor m) => Applicative (ControllerT s m) where
  pure = return
  (<*>) = ap
Monad instance: 


instance Monad m => Monad (ControllerT s m) where
  return a = ControllerT $ \st _ -> return $ (Right a, st)
  (ControllerT act) >>= fn = ControllerT $ \st0 req -> do
    (eres, st) <- act st0 req
    case eres of
      Left resp -> return (Left resp, st)
      Right result -> do
        let (ControllerT fres) = fn result
        fres st req
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/directory-layout-0.7.4.1/src/System/Directory/Layout/Interpreter.hs
Applicative instance: 


instance Semigroup e => Applicative ((\/) e) where
  pure = Result
  Error f  <*> Error x  = Error (f <> x)
  Error f  <*> _        = Error f
  _        <*> Error x  = Error x
  Result f <*> Result x = Result (f x)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/pipes-extra-0.2.0/Control/Pipe/PutbackPipe.hs
Monad instance: 


instance Monad m => Monad (PutbackPipe a b m) where
    return = PutbackPipe . return
    (PutbackPipe p) >>= f = PutbackPipe (p >>= unPutback . f)
Applicative instance: 


instance Monad m => Applicative (PutbackPipe a b m) where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/netcore-1.0.0/nettle-openflow/src/Nettle/OpenFlow/StrictPut.hs
Monad instance: 


instance Monad PutM where
  return x = PutM (\ptr -> return (x, ptr))
  {-# INLINE return #-}
  (PutM m) >>= f = PutM (\(!ptr) -> do { (a, ptr') <- m ptr ; let (PutM g) = f a in g ptr' } )
  {-# INLINE (>>=) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/binary-strict-0.4.8.3/src/Data/Binary/BitPut.hs
Applicative instance: 


instance Applicative BitPutM where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad BitPutM where
   return a = BitPutM (a,BB.empty)
   m >>= k = BitPutM (let (a, w) = unPut m
                          (b, w') = unPut (k a)
                       in (b, w `BB.append` w'))

   m >> k = BitPutM (let (_, w) = unPut m
                         (b, w') = unPut k
                      in (b, w `BB.append` w'))
   {-# INLINE (>>) #-}
Applicative instance: 


instance Monad m => Applicative (BitPutT m) where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad m => Monad (BitPutT m) where
   return a = BitPutT $ return (a, BB.empty)
   m >>= k = BitPutT $ do
      ~(a, w) <- unPutT m
      ~(b, w') <- unPutT (k a)
      return (b, w `BB.append` w')
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/binary-strict-0.4.8.3/src/Data/Binary/Strict/IncrementalGet.hs
Monad instance: 


instance Monad (Get r) where
  return a = Get (\s -> \k -> k a s)
  m >>= k = Get (\s -> \cont -> unGet m s (\a -> \s' -> unGet (k a) s' cont))
  fail err = Get (\s -> const $ IFailed s err)
Applicative instance: 


instance Applicative (Get r) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/binary-strict-0.4.8.3/src/Data/Binary/Strict/BitGet.hs
Applicative instance: 


instance Applicative BitGet where
  pure  = return
  (<*>) = ap
Monad instance: 


instance Monad BitGet where
  return a = BitGet (\s -> (Right a, s))
  m >>= k = BitGet (\s -> case unGet m s of
                            (Left err, s') -> (Left err, s')
                            (Right a, s') -> unGet (k a) s')
  fail err = BitGet (\s -> (Left err, s))
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/binary-strict-0.4.8.3/src/Data/Binary/Strict/Get.hs
Monad instance: 


instance Monad Get where
  return a = Get (\s -> (Right a, s))
  m >>= k = Get (\s -> case unGet m s of
                            (Left err, s') -> (Left err, s')
                            (Right a, s') -> unGet (k a) s')
  fail err = Get (\s -> (Left err, s))
Applicative instance: 


instance Applicative Get where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/sme-0.1/SME/ME.hs
Monad instance: 


instance Monad ME where
    return x                = Return x
    (Return x)       >>= f  = f x
    (Write file s p) >>= f  = Write file s (p >>= f)
    (Read file g)    >>= f  = Read file (\i -> g i >>= f)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/clist-0.1.0.0/Data/CList.hs
Applicative instance: 


instance Applicative (CList Zero) where
    pure x = Nil
    Nil <*> Nil = Nil
Applicative instance: 


instance (Applicative (CList n)) => Applicative (CList (Succ n)) where
    pure x = x :. pure x
    f:.fs <*> x:.xs = f x :. (fs <*> xs)
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/stateWriter-0.2.8/Control/Monad/Trans/RSS/Strict.hs
Monad instance: 


instance (Monad m) => Monad (RSST r w s m) where
    return a = RSST $ \_ s -> return (a, s)
    m >>= k  = RSST $ \r s -> do
        (a, (s', w))  <- runRSST' m r s
        runRSST' (k a) r (s',w)
    fail msg = RSST $ \_ _ -> fail msg
Applicative instance: 


instance (Functor m, Monad m) => Applicative (RSST r w s m) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/stateWriter-0.2.8/Control/Monad/Trans/RSS/Lazy.hs
Monad instance: 


instance (Monad m) => Monad (RSST r w s m) where
    return a = RSST $ \_ s -> return (a, s)
    m >>= k  = RSST $ \r s -> do
        ~(a, (s', w))  <- runRSST' m r s
        runRSST' (k a) r (s',w)
    fail msg = RSST $ \_ _ -> fail msg
Applicative instance: 


instance (Functor m, Monad m) => Applicative (RSST r w s m) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/operational-0.2.3.3/src/Control/Monad/Operational.hs
Monad instance: 


    -- basic instances
instance Monad m => Monad (ProgramT instr m) where
    return = Lift . return
    (>>=)  = Bind
Applicative instance: 


instance Monad m => Applicative (ProgramT instr m) where
    pure   = return
    (<*>)  = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/direct-binary-files-1.0/BinaryFiles.hs
Monad instance: 



instance Monad Identity where
  return a = Identity a
  (Identity x) >>= f = f x
Monad instance: 



instance Monad (PrimitiveMonad backend)
         => Monad (BackendSpecificSerialization backend context) where
  return a = BackendSpecificSerialization $ \internals _ _ _ ->
               return $ Right (internals, a)
  (BackendSpecificSerialization x) >>= f =
    BackendSpecificSerialization $ \internals context tags window -> do
      v <- x internals context tags window
      case v of
        Left failure -> return $ Left failure
        Right (internals', y) ->
          serializationAction (f y) internals' context tags window
Monad instance: 



instance Monad (PrimitiveMonad backend)
         => Monad (BackendSpecificDeserialization backend context) where
  return a = BackendSpecificDeserialization $ \internals _ _ _ ->
    return $ Right (internals, a)
  (BackendSpecificDeserialization x) >>= f =
    BackendSpecificDeserialization $ \internals context tags window -> do
      v <- x internals context tags window
      case v of
        Left failure -> return $ Left failure
        Right (internals', y) ->
          deserializationAction (f y) internals' context tags window
Monad instance: 



instance forall context
         . Monad (ContextualSerialization context) where
  return a = ContextualSerialization $ return a
  x >>= f =
    ContextualSerialization $ do
      v <- contextualSerializationAction x
      contextualSerializationAction $ f v
Monad instance: 



instance forall context
         . Monad (ContextualDeserialization context) where
  return a = ContextualDeserialization $ return a
  x >>= f =
    ContextualDeserialization $ do
      v <- contextualDeserializationAction x
      contextualDeserializationAction $ f v
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/buffer-builder-0.2.4.3/src/Data/BufferBuilder.hs
Applicative instance: 


instance Applicative BufferBuilder where
    {-# INLINE pure #-}
    pure = BB . const . pure

    {-# INLINE (<*>) #-}
    (BB f) <*> (BB a) = BB $ \h -> (f h) <*> (a h)
Monad instance: 


instance Monad BufferBuilder where
    {-# INLINE return #-}
    return = BB . const . return

    {-# INLINE (>>=) #-}
    (BB lhs) >>= next = BB $ \h -> do
        a <- lhs h
        unBB (next a) h
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/xmonad-bluetilebranch-0.9.1.4/XMonad/Core.hs
Applicative instance: 

#endif

instance Applicative X where
  pure = return
  (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/exposed-containers-0.5.5.1/tests/seq-properties.hs
Applicative instance: 


instance Applicative M where
    pure x = Action 0 x
    Action m f <*> Action n x = Action (m+n) (f x)
Monad instance: 


instance Monad M where
    return x = Action 0 x
    Action m x >>= f = let Action n y = f x in Action (m+n) y
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/exposed-containers-0.5.5.1/Data/Graph.hs
Monad instance: 


instance Monad (SetM s) where
    return x     = SetM $ const (return x)
    {-# INLINE return #-}
    SetM v >>= f = SetM $ \s -> do { x <- v s; runSetM (f x) s }
    {-# INLINE (>>=) #-}
Applicative instance: 


instance Applicative (SetM s) where
    pure x = SetM $ const (return x)
    {-# INLINE pure #-}
    SetM f <*> SetM v = SetM $ \s -> f s >>= (`fmap` v s)
    -- We could also use the following definition
    --   SetM f <*> SetM v = SetM $ \s -> f s <*> v s
    -- but Applicative (ST s) instance is present only in GHC 7.2+
    {-# INLINE (<*>) #-}
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/exposed-containers-0.5.5.1/Data/Sequence.hs
Monad instance: 


instance Monad Seq where
    return = singleton
    xs >>= f = foldl' add empty xs
      where add ys x = ys >< f x
Applicative instance: 


instance Applicative Seq where
    pure = singleton
    fs <*> xs = foldl' add empty fs
      where add ys f = ys >< fmap f xs
Monad instance: 


instance Monad Id where
    return = Id
    m >>= k = k (runId m)
Applicative instance: 


instance Applicative Id where
    pure = return
    (<*>) = ap
Monad instance: 


instance Monad (State s) where
    {-# INLINE return #-}
    {-# INLINE (>>=) #-}
    return x = State $ \ s -> (s, x)
    m >>= k = State $ \ s -> case runState m s of
        (s', x) -> runState (k x) s'
Applicative instance: 


instance Applicative (State s) where
    pure = return
    (<*>) = ap
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/exposed-containers-0.5.5.1/Data/Tree.hs
Applicative instance: 


instance Applicative Tree where
    pure x = Node x []
    Node f tfs <*> tx@(Node x txs) =
        Node (f x) (map (f <$>) txs ++ map (<*> tx) tfs)
Monad instance: 


instance Monad Tree where
    return x = Node x []
    Node x ts >>= f = Node x' (ts' ++ map (>>= f) ts)
      where Node x' ts' = f x
Results from: /home/stephen/Projects/ParRegexSearch/hackage/package/OGL-0.0.3/Graphics/Rendering/OGL/GL/IOState.hs
Monad instance: 


instance Monad (IOState s) where
   return a = IOState $ \s -> return (a, s)
   m >>= k  = IOState $ \s -> do (a, s') <- runIOState m s ; runIOState (k a) s'
   fail str = IOState $ \_ -> fail str
